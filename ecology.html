<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#0f172a">
<title>Twekkelerveld Ecology Digital Twin</title>

<!-- CesiumJS -->
<script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
<link href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css" rel="stylesheet"/>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- jsPDF for PDF report -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<!-- Fonts & Icons -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
  /* UI styling */
  :root {
    --bg-dark: #020617;
    --panel-bg: rgba(2, 6, 23, 0.85);
    --panel-bg-2: rgba(15, 23, 42, 0.75);
    --border: rgba(148, 163, 184, 0.18);
    --border-strong: rgba(45, 212, 191, 0.35);
    --primary: #2dd4bf;
    --primary-hover: #14b8a6;
    --text-main: #f8fafc;
    --text-sub: rgba(226, 232, 240, 0.72);
    --danger: #fb7185;
    --gold: #fbbf24;
    --blue: #60a5fa;
    --purple: #c084fc;
  }

  body, html, #cesiumContainer {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: 'Inter', sans-serif;
    background: var(--bg-dark);
    overflow: hidden;
  }

  #cesiumContainer { 
    position: absolute; 
    top: 0; 
    left: 0; 
    z-index: 0; 
  }

  #uiLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    z-index: 100;
  }

  .top-bar {
    pointer-events: auto;
    align-self: center;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    padding: 10px 16px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    gap: 12px;
    box-shadow: 0 10px 28px rgba(0,0,0,0.35);
    backdrop-filter: blur(14px);
    z-index: 101;
  }

  .app-title {
    font-weight: 800;
    font-size: 13px;
    color: var(--text-main);
    letter-spacing: 0.2px;
  }

  .btn-overview {
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--border);
    color: var(--text-main);
    padding: 6px 12px;
    border-radius: 999px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: 0.18s;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .btn-overview:hover { background: rgba(45, 212, 191, 0.85); color: #0b1220; border-color: rgba(45, 212, 191, 0.45); }

  /* Weather widget styles */
  .weather-widget {
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--border);
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 12px;
    color: var(--text-main);
  }
  .weather-bar {
    width: 60px;
    height: 4px;
    background: rgba(255,255,255,0.15);
    border-radius: 5px;
    position: relative;
    overflow: hidden;
  }
  .weather-bar-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 0%;
    background: var(--primary);
  }

  /* STATIC PANELS - Scrollable but Fixed */
  .panel {
    pointer-events: auto;
    width: clamp(240px, 24vw, 340px);
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 14px 34px rgba(0,0,0,0.45);
    backdrop-filter: blur(16px);
    z-index: 102;
    /* Static scrolling behavior */
    max-height: calc(100vh - 220px);
    overflow-y: auto;
  }

  #leftPanel { 
    position: absolute; 
    top: 72px; 
    left: 14px; 
    z-index: 103;
  }

  #rightPanel {
    position: absolute; 
    top: 72px; 
    right: 14px;
    z-index: 103;
  }

  .panel-top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom: 2px;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(255,255,255,0.07);
  }
  .panel-title{
    display:flex;
    align-items:center;
    gap:8px;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: rgba(45, 212, 191, 0.95);
    font-weight: 800;
  }

  #bottomPanel {
    pointer-events: auto;
    align-self: center;
    width: min(560px, calc(100vw - 40px));
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 14px 20px;
    backdrop-filter: blur(12px);
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    margin-bottom: 20px;
    z-index: 101;
  }

  h3 {
    margin: 0;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    color: rgba(45, 212, 191, 0.95);
    font-weight: 800;
    border-bottom: 1px solid rgba(255,255,255,0.07);
    padding-bottom: 8px;
    margin-bottom: 4px;
  }

  .layer-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 10px;
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06);
    transition: 0.18s;
    cursor: pointer;
    gap: 10px;
  }
  .layer-item:hover {
    border-color: var(--border-strong);
    background: rgba(255,255,255,0.05);
  }

  .layer-label {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-main);
    display: flex;
    align-items: center;
    gap: 8px;
    user-select: none;
  }
  .layer-actions{ display:flex; align-items:center; gap:8px; flex-shrink: 0; }

  .info-btn{
    pointer-events:auto;
    border:none;
    background: rgba(255,255,255,0.04);
    color: rgba(226,232,240,0.65);
    width: 28px;
    height: 28px;
    border-radius: 10px;
    cursor: pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    transition: .18s;
    border: 1px solid rgba(148,163,184,0.18);
  }
  .info-btn:hover{
    color: white;
    border-color: rgba(45,212,191,0.45);
    box-shadow: 0 0 0 3px rgba(45,212,191,0.08);
  }

  .switch {
    width: 34px;
    height: 18px;
    background: rgba(148,163,184,0.22);
    border-radius: 999px;
    position: relative;
    transition: 0.25s;
    border: 1px solid rgba(148,163,184,0.18);
  }
  .switch::after {
    content:'';
    position:absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    background: rgba(226,232,240,0.85);
    border-radius: 50%;
    transition: 0.25s;
  }
  .switch.active {
    background: rgba(45, 212, 191, 0.85);
    border-color: rgba(45, 212, 191, 0.35);
  }
  .switch.active::after {
    transform: translateX(16px);
    background: #0b1220;
  }

  .slider-container {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 12px;
    color: var(--text-sub);
  }
  input[type=range] { flex: 1; accent-color: var(--primary); cursor: pointer; }
  .slider-val {
    font-weight: 800;
    color: var(--text-main);
    min-width: 82px;
    text-align: right;
  }

  .stats-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }
  .stat-box {
    background: rgba(0,0,0,0.30);
    border-radius: 12px;
    padding: 10px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.06);
  }
  .stat-num { font-size: 16px; font-weight: 800; color: var(--text-main); }
  .stat-name { font-size: 9px; text-transform: uppercase; color: var(--text-sub); margin-top: 2px; letter-spacing: 0.5px; }

  .species-grid { display: flex; gap: 6px; margin-bottom: 10px; }
  .species-opt {
    flex: 1;
    background: rgba(0,0,0,0.30);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 12px;
    padding: 7px 6px;
    text-align: center;
    cursor: pointer;
    transition: 0.18s;
    opacity: 0.68;
    user-select: none;
  }
  .species-opt:hover { opacity: 1; border-color: rgba(45,212,191,0.55); }
  .species-opt.selected {
    opacity: 1;
    background: rgba(45, 212, 191, 0.12);
    border-color: rgba(45,212,191,0.75);
    box-shadow: 0 0 0 3px rgba(45,212,191,0.08);
  }
  .spec-icon { font-size: 18px; margin-bottom: 4px; display: block; }
  .spec-name { font-size: 10px; font-weight: 700; color: var(--text-main); display: block; }
  .spec-cost { font-size: 9px; color: var(--gold); }

  #btnPlant, #btnFacade {
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 12px;
    background: rgba(45, 212, 191, 0.90);
    color: #0b1220;
    font-weight: 900;
    font-size: 12px;
    cursor: pointer;
    box-shadow: 0 10px 22px rgba(0,0,0,0.25);
    transition: 0.18s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  #btnPlant:hover, #btnFacade:hover { transform: translateY(-1px); filter: brightness(1.03); }

  #btnPlant.planting {
    background: #f59e0b;
    animation: pulse 1.5s infinite;
    color: #451a03;
  }
  #btnFacade.facading {
    background: #22c55e;
    animation: pulseGreen 1.5s infinite;
    color: #052e16;
  }

  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4); }
    70% { box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
    100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
  }
  @keyframes pulseGreen {
    0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.35); }
    70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
    100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
  }

  .small-btn {
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(148,163,184,0.28);
    color: rgba(226,232,240,0.80);
    padding: 8px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 11px;
    width: 100%;
    margin-top: 10px;
    transition: .18s;
  }
  .small-btn:hover {
    background: rgba(255,255,255,0.04);
    border-color: rgba(45,212,191,0.45);
    color: white;
  }

  /* =======================================
     Gauge Overview Styles
     Creates a grid of four semicircular gauges to display
     scenario impact metrics (CO‚ÇÇ sequestration, stormwater
     runoff reduction, cooling effect and investment). Each
     gauge uses a Chart.js doughnut chart with a custom plugin
     to render the numeric value and caption in the centre.
  ======================================= */
  .gauge-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    margin-bottom: 10px;
  }
  .gauge-box {
    position: relative;
    background: rgba(0,0,0,0.30);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 16px;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 120px;
  }
  .gauge-box canvas {
    width: 100% !important;
    height: 100% !important;
  }

  .gauge-box .gauge-value {
    position: absolute;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
    font-weight: 700;
    color: var(--text-main);
    pointer-events: none;
  }
  .gauge-box .gauge-caption {
    position: absolute;
    top: 70%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 9px;
    font-weight: 600;
    text-transform: uppercase;
    color: var(--text-sub);
    pointer-events: none;
  }

  /* Increase right panel width for gauge layout */
  #rightPanel {
    width: clamp(260px, 28vw, 380px);
  }

  #ecoPopup {
    position: absolute;
    width: 290px;
    max-width: 320px;
    background: rgba(2, 6, 23, 0.95);
    border: 1px solid rgba(45,212,191,0.45);
    border-radius: 14px;
    padding: 14px;
    color: white;
    display: none;
    z-index: 200;
    pointer-events: auto;
    box-shadow: 0 14px 40px rgba(0,0,0,0.75);
    backdrop-filter: blur(12px);
  }
  .pop-row {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    margin-bottom: 6px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    padding-bottom: 3px;
    gap: 12px;
  }
  .pop-label { color: rgba(226,232,240,0.62); }
  .pop-val { font-weight: 700; color: #f8fafc; text-align:right; }

  /* Table style for dynamic popups */
  .pop-table { width: 100%; border-collapse: collapse; font-size: 11px; }
  .pop-table td { padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.06); vertical-align: top; }
  .pop-table tr:last-child td { border-bottom: none; }
  .pop-table .k { color: rgba(226,232,240,0.6); width: 40%; }
  .pop-table .v { color: #fff; font-weight: 600; text-align: right; }

  #overviewModal, #layerInfoModal, #mcdaModal {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.80);
    backdrop-filter: blur(8px);
    z-index: 999;
    display: none;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
  }

  .modal-content {
    background: #0b1220;
    width: 780px;
    max-height: 85vh;
    overflow-y: auto;
    border-radius: 18px;
    border: 1px solid rgba(148,163,184,0.20);
    box-shadow: 0 24px 70px rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
  }
  .modal-content.small { width: 680px; }

  .modal-header {
    padding: 20px;
    border-bottom: 1px solid rgba(255,255,255,0.08);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(90deg, rgba(45, 212, 191, 0.10), transparent);
  }

  .modal-body { padding: 24px; color: rgba(226,232,240,0.80); font-size: 13px; line-height: 1.6; }
  .close-btn { background: none; border: none; color: rgba(226,232,240,0.55); font-size: 28px; cursor: pointer; }
  .close-btn:hover { color: white; }

  #toast {
    position: absolute;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(45, 212, 191, 0.92);
    color: #052e2a;
    padding: 8px 14px;
    border-radius: 999px;
    font-weight: 900;
    font-size: 12px;
    opacity: 0;
    transition: 0.25s;
    z-index: 300;
    pointer-events: none;
    box-shadow: 0 10px 24px rgba(0,0,0,0.35);
  }

  .compare-panel {
    margin-top: 10px;
    padding: 10px;
    background: rgba(0,0,0,0.32);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.28);
  }

  /* --------------------------------------------------------------------
     Panel collapse controls
     Small buttons allow the left and right panels to be hidden.  When
     collapsed the panel itself is hidden and a slim toggle appears at
     the edge of the viewport so it can be restored.  These styles
     govern the look of the collapse buttons and the toggle tabs.
  -------------------------------------------------------------------- */
  .collapse-btn {
    background: none;
    border: none;
    color: var(--text-sub);
    cursor: pointer;
    font-size: 14px;
    padding: 2px;
    transition: color 0.18s;
    pointer-events: auto;
  }
  .collapse-btn:hover {
    color: var(--primary);
  }
  #leftPanelToggle, #rightPanelToggle {
    position: absolute;
    top: 200px;
    z-index: 104;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    padding: 8px 6px;
    display: none;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    backdrop-filter: blur(12px);
    cursor: pointer;
    /* Ensure the toggle tabs can be clicked even though their parent has pointer‚Äëevents: none */
    pointer-events: auto;
  }
  #leftPanelToggle {
    left: 0;
    border-radius: 0 12px 12px 0;
  }
  #rightPanelToggle {
    right: 0;
    border-radius: 12px 0 0 12px;
  }
  #leftPanelToggle i, #rightPanelToggle i {
    color: var(--primary);
    font-size: 14px;
  }
  .compare-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: rgba(226,232,240,0.62);
    margin-bottom: 6px;
  }
  .compare-row { margin-bottom: 8px; }
  .compare-label {
    font-size: 11px;
    color: var(--text-main);
    display: flex;
    justify-content: space-between;
    gap: 12px;
  }
  .compare-bars {
    margin-top: 4px;
    height: 6px;
    background: rgba(2,6,23,0.70);
    border-radius: 999px;
    overflow: hidden;
    position: relative;
    border: 1px solid rgba(255,255,255,0.06);
  }
  .compare-bar-before, .compare-bar-after { position: absolute; top: 0; bottom: 0; left: 0; }
  .compare-bar-before { background: rgba(148,163,184,0.50); }
  .compare-bar-after { background: rgba(45,212,191,0.90); opacity: 0.95; }
  .compare-delta { font-size: 10px; color: rgba(226,232,240,0.62); margin-top: 3px; }

  .rec-list { margin-top: 8px; display: flex; flex-direction: column; gap: 8px; }
  .rec-item {
    padding: 10px;
    background: rgba(15,23,42,0.55);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.22);
    font-size: 11px;
    cursor: pointer;
    transition: 0.18s;
  }
  .rec-item:hover { border-color: rgba(45,212,191,0.45); box-shadow: 0 0 0 3px rgba(45,212,191,0.08); }
  .rec-title { font-weight: 900; color: var(--text-main); margin-bottom: 2px; }
  .rec-meta { color: rgba(226,232,240,0.62); font-size: 10px; }

  .scenario-box{
    padding: 10px;
    background: rgba(0,0,0,0.25);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.22);
  }
  .scenario-types{
    display:flex;
    flex-wrap: wrap;
    gap:8px;
    margin-top:8px;
  }
  .sc-type{
    flex:1;
    border: 1px solid rgba(148,163,184,0.22);
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    padding: 8px 6px;
    font-size: 10px;
    color: rgba(226,232,240,0.65);
    cursor:pointer;
    text-align:center;
    user-select:none;
    transition: .18s;
  }
  .sc-type:hover{ border-color: rgba(45,212,191,0.45); color: white; }
  .sc-type.selected{
    border-color: rgba(45,212,191,0.75);
    color: white;
    background: rgba(45,212,191,0.10);
    box-shadow: 0 0 0 3px rgba(45,212,191,0.08);
  }
  .scenario-list{ display:flex; flex-direction:column; gap:8px; margin-top:10px; }
  .scenario-item{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:10px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(148,163,184,0.22);
    border-radius: 14px;
    font-size: 11px;
    color: var(--text-main);
  }
  .scenario-item small{ color: rgba(226,232,240,0.62); display:block; margin-top:2px; }
  .scenario-item button{
    border:none;
    background: rgba(251,113,133,0.12);
    color: rgba(254,202,202,0.95);
    border: 1px solid rgba(251,113,133,0.28);
    width: 34px; height: 34px;
    border-radius: 12px;
    cursor:pointer;
    transition:.18s;
  }
  .scenario-item button:hover{
    background: rgba(251,113,133,0.18);
    border-color: rgba(251,113,133,0.45);
  }

  #legendBox{
    margin-top: 12px;
    padding:10px;
    background: rgba(0,0,0,0.25);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.22);
  }
  #legendTitle{
    font-size:10px;
    color: rgba(226,232,240,0.62);
    text-transform:uppercase;
    margin-bottom:6px;
    letter-spacing:.7px;
  }
  .leg-row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    font-size:11px;
    color: rgba(226,232,240,0.78);
    padding:6px 0;
    border-bottom: 1px solid rgba(255,255,255,0.04);
  }
  .leg-row:last-child{ border-bottom:none; }
  .leg-chip{ display:flex; align-items:center; gap:8px; }
  .chip{
    width: 12px; height: 12px;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.20);
    flex-shrink:0;
  }
  .chip.line{ width: 18px; height: 3px; border-radius: 3px; border:none; }

  .mcda-grid{ display:grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 10px; }
  .mcda-card{ border: 1px solid rgba(148,163,184,0.22); border-radius: 14px; padding: 12px; background: rgba(255,255,255,0.03); }
  .mcda-card label{ display:block; font-size: 11px; color: rgba(226,232,240,0.80); margin-bottom: 6px; text-transform: uppercase; letter-spacing: .6px; }
  .mcda-card select, .mcda-card input{
    width: 100%;
    padding: 10px;
    border-radius: 12px;
    border: 1px solid rgba(148,163,184,0.22);
    background: rgba(2,6,23,0.55);
    color: rgba(226,232,240,0.92);
    outline: none;
    font-family: Inter, sans-serif;
    font-size: 12px;
  }
  .mcda-actions{ display:flex; gap: 10px; margin-top: 16px; }
  .mcda-actions button{
    flex:1;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(45,212,191,0.30);
    background: rgba(45,212,191,0.10);
    color: rgba(226,232,240,0.92);
    font-weight: 900;
    cursor: pointer;
    transition: .18s;
  }
  .mcda-actions button:hover{ border-color: rgba(45,212,191,0.60); background: rgba(45,212,191,0.14); }

  .hint-pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px dashed rgba(148,163,184,0.35);
    background: rgba(2,6,23,0.28);
    color: rgba(226,232,240,0.75);
    font-size: 11px;
    margin-top: 10px;
  }

  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: rgba(2,6,23,0.8); }
  ::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.35); border-radius: 6px; }
  ::-webkit-scrollbar-thumb:hover { background: rgba(45,212,191,0.60); }

  /* =======================================
     Assistant Chat Styles
     Provides a simple chat interface for the ecology assistant.
  ======================================= */
  #assistantContainer {
    position: absolute;
    right: 20px;
    bottom: 20px;
    width: 320px;
    max-height: 50vh;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    pointer-events: auto;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index: 500;
  }
  #assistantMessages {
    flex: 1;
    padding: 12px;
    overflow-y: auto;
  }
  .assistant-message {
    margin-bottom: 8px;
    font-size: 12px;
    line-height: 1.4;
  }
  .assistant-message.user {
    text-align: right;
    color: #bae6fd;
  }
  .assistant-message.bot {
    text-align: left;
    color: var(--text-main);
  }
  #assistantChips {
    padding: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  .assistant-chip {
    font-size: 10px;
    padding: 4px 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(148,163,184,0.25);
    border-radius: 999px;
    cursor: pointer;
    user-select: none;
    transition: 0.18s;
  }
  .assistant-chip:hover {
    border-color: var(--primary);
    background: rgba(45,212,191,0.20);
    color: white;
  }
  #assistantInputArea {
    display: flex;
    padding: 8px;
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  #assistantInput {
    flex: 1;
    padding: 6px 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(148,163,184,0.28);
    border-radius: 12px;
    color: var(--text-main);
    font-size: 12px;
    outline: none;
  }
  #assistantSend {
    margin-left: 6px;
    background: var(--primary);
    border: none;
    color: #0b1220;
    font-weight: 700;
    padding: 6px 10px;
    border-radius: 12px;
    cursor: pointer;
    transition: 0.18s;
  }
  #assistantSend:hover {
    background: var(--primary-hover);
  }

  /* === Custom additions for improved AI Assistant === */
  /* Make the assistant panel less transparent for better readability */
  #assistantContainer {
    background: rgba(15, 23, 42, 0.95);
  }
  /* Header bar within the assistant, showing title and a close button */
  #assistantHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(2, 6, 23, 0.85);
  }
  #assistantHeader .assistant-title {
    font-size: 13px;
    font-weight: 800;
    color: var(--text-main);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  #assistantHeader .assistant-title i {
    font-size: 14px;
  }
  #assistantClose {
    background: none;
    border: none;
    color: var(--text-sub);
    font-size: 18px;
    cursor: pointer;
    transition: 0.18s;
  }
  #assistantClose:hover {
    color: var(--primary);
  }
  /* Floating toggle button for the assistant (collapsible like a messenger icon) */
  .assistant-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 52px;
    height: 52px;
    border-radius: 50%;
    background: var(--primary);
    /*
     * Use white for the assistant toggle icon/text so the suggestion
     * robot letter is clearly visible on the coloured button.  The
     * previous dark colour caused the glyph to blend with the button,
     * appearing almost transparent.
     */
    color: #ffffff;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
    cursor: pointer;
    z-index: 600;
  }
  .assistant-toggle:hover {
    background: var(--primary-hover);
  }
  /* Hide class to toggle visibility */
  .hide {
    display: none !important;
  }

  /* Suggestions dropdown for predictive ecological terms */
  #assistantSuggestions {
    padding: 8px;
    border-top: 1px solid rgba(255,255,255,0.06);
    max-height: 120px;
    overflow-y: auto;
    background: rgba(2, 6, 23, 0.85);
    display: none;
  }
  #assistantSuggestions .suggestion-item {
    padding: 6px 8px;
    font-size: 12px;
    border-radius: 8px;
    cursor: pointer;
    color: var(--text-main);
    transition: 0.18s;
  }
  #assistantSuggestions .suggestion-item:hover {
    background: rgba(45,212,191,0.20);
    color: var(--primary);
  }

  /* =======================================
     Readability fixes (NDVI / MCDA / modals)
     Ensures text is bright enough on dark panels.
  ======================================= */
  .assistant-message{ white-space: pre-line; }

  .modal-content, .modal-content * { color: rgba(248,250,252,0.90); }
  .modal-body { color: rgba(248,250,252,0.88); }
  .modal-body a { color: var(--primary); text-decoration: underline; }
  .modal-body code { color: #fff; background: rgba(255,255,255,0.06); padding:2px 6px; border-radius:8px; }

  #mcdaModal .mcda-card label { color: rgba(248,250,252,0.92); }
  #mcdaModal .mcda-card select, #mcdaModal .mcda-card input { color: rgba(248,250,252,0.95); }
  #mcdaModal .mcda-card select option { color: #0b1220; } /* keeps options readable in most browsers */

  #layerInfoBody, #layerInfoBody * { color: rgba(248,250,252,0.90); }

</style>
  <script src="./config.js"></script>
</head>
<body>

<div id="cesiumContainer"></div>

<!-- hidden canvases used for raster probing -->
<canvas id="canvasNDVI" style="display:none;"></canvas>
<canvas id="canvasUHI" style="display:none;"></canvas>

<div id="uiLayer">

  <div class="top-bar">
    <i class="fas fa-leaf" style="color:var(--primary)"></i>
    <span class="app-title">Ecology Digital Twin <span style="font-weight:500; opacity:0.65;">| Twekkelerveld</span></span>
    <div style="width:1px; height:15px; background:rgba(255,255,255,0.16);"></div>
    <button class="btn-overview" onclick="openOverview()">
      <i class="fas fa-info-circle"></i> Ecological Overview
    </button>

    <!-- Weather widget shows current temperature and countdown to the next snowfall or heat event -->
    <div id="weatherWidget" class="weather-widget" onclick="showWeatherDetails()" style="cursor:pointer;">
      <span id="weatherTemp">--¬∞C</span>
      <div class="weather-bar">
        <div id="weatherBarFill" class="weather-bar-fill"></div>
      </div>
      <span id="weatherEvent" style="font-size:10px; opacity:0.8;">Loading‚Ä¶</span>
    </div>
  </div>

  <div class="panel" id="leftPanel">
    <!-- Collapse button for left panel -->
    <button class="collapse-btn" onclick="toggleLeftPanel()" title="Collapse left panel" style="align-self:flex-end;"><i class="fa-solid fa-chevron-left"></i></button>
    <h3>Layers</h3>

    <!-- Layer 1: Open Data (Renamed file) -->
    <div class="layer-item" onclick="toggleLayer('trees_open')">
      <div class="layer-label"><i class="fas fa-tree" style="color:#2dd4bf"></i> Tree Inventory (Open)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('trees_open', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-trees_open"></div>
      </div>
    </div>

    <!-- Layer 2: Municipality Data (New) -->
    <div class="layer-item" onclick="toggleLayer('trees_muni')">
      <div class="layer-label"><i class="fas fa-tree" style="color:#60a5fa"></i> Tree Points (Muni)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('trees_muni', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-trees_muni"></div>
      </div>
    </div>

    <div class="layer-item" onclick="toggleLayer('greenery')">
      <div class="layer-label"><i class="fas fa-vector-square" style="color:#99f6e4"></i> Green Spaces</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('greenery', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-greenery"></div>
      </div>
    </div>

    <div class="layer-item" onclick="toggleLayer('buildings3d')">
      <div class="layer-label"><i class="fas fa-building" style="color:#e5e7eb"></i> Buildings (LOD 2.2)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('buildings3d', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-buildings3d"></div>
      </div>
    </div>

    <div style="width:100%; height:1px; background:rgba(255,255,255,0.10); margin:10px 0;"></div>
    <h3>Advanced Metrics</h3>

    <div class="layer-item" onclick="toggleLayer('corridors')">
      <div class="layer-label"><i class="fas fa-route" style="color:#fbbf24"></i> Well‚Äëbeing Corridors</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('corridors', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch" id="sw-corridors"></div>
      </div>
    </div>

    <!-- Heat-Stress Priority Layer removed (functionality intentionally disabled) -->

    <div class="layer-item" onclick="toggleLayer('heatmap')">
      <div class="layer-label"><i class="fas fa-fire" style="color:#ef4444"></i> Heatmap (UHI)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('heatmap', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch" id="sw-heatmap"></div>
      </div>
    </div>

    <div id="legendBox">
      <div id="legendTitle">Legend</div>
      <div id="legendBody"></div>
    </div>
  </div>

  <!-- Right Panel: Static, no collapse button -->
  <div class="panel" id="rightPanel">
    <div class="panel-top">
      <div class="panel-title">
        <i class="fa-solid fa-sliders" style="color:var(--primary)"></i>
        <span>Urban Forest Simulator</span>
      </div>
      <!-- Collapse button for right panel -->
      <button class="collapse-btn" onclick="toggleRightPanel()" title="Collapse right panel"><i class="fa-solid fa-chevron-right"></i></button>
    </div>

    <div class="panel-content" id="rightPanelContent">
      <div class="stats-row">
        <div class="stat-box">
          <div class="stat-num" id="valTrees" style="color:var(--gold)">0</div>
          <div class="stat-name">New Trees</div>
        </div>
        <div class="stat-box">
          <div class="stat-num" id="valFacades" style="color:#22c55e">0</div>
          <div class="stat-name">Green Facades</div>
        </div>
      </div>

      <h3>Performance Trade-offs</h3>
      <div style="height:150px; position:relative;">
        <canvas id="tradeoffChart"></canvas>
      </div>
      <button class="small-btn" onclick="downloadCharts()">
        <i class="fas fa-download"></i> Download Chart
      </button>


      <h3>Financial Tradeoffs</h3>
      <div class="scenario-box" style="margin-top:-4px;">
        <div style="font-size:11px;color:rgba(226,232,240,0.80);">
          Enter a budget and objective ‚Üí get a plan with clear trade‚Äëoffs. (This is advisory; you still place trees/facades/polygons on the map.)
        </div>
        <div class="mcda-grid" style="grid-template-columns: 1fr 1fr; margin-top:10px;">
          <div class="mcda-card">
            <label>Budget (‚Ç¨)</label>
            <input id="budgetInput" type="number" min="0" step="50" value="1000" />
          </div>
          <div class="mcda-card">
            <label>Objective</label>
            <select id="budgetObjective">
              <option value="balanced" selected>Balanced</option>
              <option value="cooling">Cooling (reduce heat)</option>
              <option value="carbon">CO‚ÇÇ</option>
              <option value="biodiversity">Biodiversity</option>
              <option value="stormwater">Stormwater</option>
            </select>
          </div>
        </div>
        <div class="mcda-actions" style="margin-top:12px;">
          <button onclick="runBudgetPlanner()"><i class="fa-solid fa-scale-balanced"></i> Suggest Plan</button>
          <button onclick="clearBudgetPlanner()"><i class="fa-solid fa-eraser"></i> Clear</button>
        </div>
        <div id="budgetResults" style="margin-top:10px;font-size:11px;color:rgba(226,232,240,0.82); line-height:1.55;"></div>
      </div>


      <h3>Select Tree Species</h3>
      <div class="species-grid">
        <div class="species-opt selected" onclick="selectSpecies('oak', this)">
          <span class="spec-icon" style="color:#fbbf24">üå≥</span>
          <span class="spec-name">Oak</span>
          <span class="spec-cost">‚Ç¨250</span>
        </div>
        <div class="species-opt" onclick="selectSpecies('birch', this)">
          <span class="spec-icon" style="color:#fb923c">üåø</span>
          <span class="spec-name">Birch</span>
          <span class="spec-cost">‚Ç¨100</span>
        </div>
        <div class="species-opt" onclick="selectSpecies('pine', this)">
          <span class="spec-icon" style="color:#bef264">üå≤</span>
          <span class="spec-name">Pine</span>
          <span class="spec-cost">‚Ç¨150</span>
        </div>
      </div>

      <button id="btnPlant" onclick="togglePlanting()">
        <i class="fas fa-plus-circle"></i> Plant Selected Tree
      </button>

      <h3 style="margin-top:10px;">Select Green Facade Type</h3>
      <div class="species-grid">
        <div class="species-opt selected" onclick="selectFacadeType('ivy', this)">
          <span class="spec-icon" style="color:#22c55e">ü™¥</span>
          <span class="spec-name">Ivy</span>
          <span class="spec-cost">‚Ç¨3.5k</span>
        </div>
        <div class="species-opt" onclick="selectFacadeType('livingwall', this)">
          <span class="spec-icon" style="color:#16a34a">üß±</span>
          <span class="spec-name">Living Wall</span>
          <span class="spec-cost">‚Ç¨6k</span>
        </div>
        <div class="species-opt" onclick="selectFacadeType('trellis', this)">
          <span class="spec-icon" style="color:#84cc16">üåø</span>
          <span class="spec-name">Trellis</span>
          <span class="spec-cost">‚Ç¨2k</span>
        </div>
      </div>

      <button id="btnFacade" onclick="toggleFacading()">
        <i class="fa-solid fa-square-plus"></i> Apply Green Facade (click a building)
      </button>

      <button onclick="downloadReport()" class="small-btn" style="border-style:dashed;">
        <i class="fas fa-file-alt"></i> Download PDF Report (with Map Snapshot)
      </button>

      <button onclick="exportScenarioGeoJSON()" class="small-btn">
        <i class="fa-solid fa-file-code"></i> Export Scenario GeoJSON
      </button>

      <!-- Impact Overview Gauges -->
      <h3>Impact Overview</h3>
      <div id="gaugeGrid" class="gauge-grid">
        <!-- CO‚ÇÇ Sequestration Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeCo2"></canvas>
          <div class="gauge-value" id="gaugeCo2Value">0</div>
          <div class="gauge-caption">CO‚ÇÇ</div>
        </div>
        <!-- Stormwater Runoff Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeWater"></canvas>
          <div class="gauge-value" id="gaugeWaterValue">0</div>
          <div class="gauge-caption">Water</div>
        </div>
        <!-- Cooling Effect Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeUhi"></canvas>
          <div class="gauge-value" id="gaugeUhiValue">0</div>
          <div class="gauge-caption">Cooling</div>
        </div>
        <!-- Investment Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeCost"></canvas>
          <div class="gauge-value" id="gaugeCostValue">0</div>
          <div class="gauge-caption">Investment</div>
        </div>

        <!-- Biodiversity Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeBio"></canvas>
          <div class="gauge-value" id="gaugeBioValue">0</div>
          <div class="gauge-caption">Biodiversity</div>
        </div>
      </div>

      <!-- Secondary metric (temporary tree removal cost) remains below gauges -->
      <div class="pop-row">
        <span class="pop-label">Tree Removal Temp Cost</span>
        <span class="pop-val" id="valCutTemp" style="color:#f87171">+0.000¬∞C</span>
      </div>

      <!-- Growth Projection: shows low/medium/high projections for selected municipal trees -->
      <h3 id="growthHeader" style="margin-top:10px; display:none;">Growth Projection <i class="fa-solid fa-circle-info" style="margin-left:6px; font-size:13px; cursor:pointer;" onclick="openLayerInfo('growthProjection', event)"></i></h3>
      <div id="growthPanel" style="display:none;">
        <div class="pop-row">
          <span class="pop-label">DBH Increment</span>
          <span class="pop-val" id="valDbhGrowth">‚Äî</span>
        </div>
        <div class="pop-row">
          <span class="pop-label">AGB Next (kg)</span>
          <span class="pop-val" id="valAgbGrowth">‚Äî</span>
        </div>
        <div class="pop-row">
          <span class="pop-label">CO‚ÇÇ Next (kg/yr)</span>
          <span class="pop-val" id="valCo2Growth">‚Äî</span>
        </div>
      </div>

      <div class="compare-panel" id="comparePanel">
        <div class="compare-header">
          <span>Scenario Comparison</span>
          <button class="small-btn" style="width:auto;padding:6px 10px;font-size:10px;margin-top:0;" onclick="toggleCompare()">
            Toggle
          </button>
        </div>
        <div id="compareBody">
          <div class="compare-row">
            <div class="compare-label">
              <span>CO‚ÇÇ Sequestration</span>
              <span id="cmpCo2Text">Baseline 0 ‚Üí 0</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpCo2Before"></div>
              <div class="compare-bar-after" id="cmpCo2After"></div>
            </div>
            <div class="compare-delta" id="cmpCo2Delta"></div>
          </div>

          <div class="compare-row">
            <div class="compare-label">
              <span>Cooling (UHI)</span>
              <span id="cmpUhiText">Baseline 0 ‚Üí 0¬∞C</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpUhiBefore"></div>
              <div class="compare-bar-after" id="cmpUhiAfter"></div>
            </div>
            <div class="compare-delta" id="cmpUhiDelta"></div>
          </div>

          <div class="compare-row">
            <div class="compare-label">
              <span>Stormwater</span>
              <span id="cmpWaterText">Baseline 0 ‚Üí 0 L/yr</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpWaterBefore"></div>
              <div class="compare-bar-after" id="cmpWaterAfter"></div>
            </div>
            <div class="compare-delta" id="cmpWaterDelta"></div>
          </div>

          <div class="compare-row">
            <div class="compare-label">
              <span>Investment</span>
              <span id="cmpCostText">Baseline ‚Ç¨0 ‚Üí ‚Ç¨0</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpCostBefore"></div>
              <div class="compare-bar-after" id="cmpCostAfter"></div>
            </div>
            <div class="compare-delta" id="cmpCostDelta"></div>
          </div>
        </div>
      </div>

      <h3>Intervention Prioritization (MCDA)</h3>
      <button class="small-btn" onclick="openMCDA()">
        <i class="fas fa-compass"></i> Decision Support Wizard
      </button>
      <div id="recList" class="rec-list">
        <div class="rec-item">
          <div class="rec-title">No priorities yet</div>
          <div class="rec-meta">Uses building attributes (hidden) + UHI + NDVI + corridor proximity. Run the wizard.</div>
        </div>
      </div>

      <h3>Draw Greenery Scenario</h3>
      <div class="scenario-box">
        <div style="font-size:11px;color:rgba(226,232,240,0.80);">
          Draw a polygon anywhere ‚Üí choose greenery type ‚Üí updates biodiversity proxy + cooling + stormwater.
        </div>

        <div class="scenario-types">
          <div class="sc-type selected" id="sc-grass" onclick="selectScenarioType('grass', this)">üå± Grass</div>
          <div class="sc-type" id="sc-shrubs" onclick="selectScenarioType('shrubs', this)">üåø Shrubs</div>
          <div class="sc-type" id="sc-trees" onclick="selectScenarioType('trees', this)">üå≥ Trees</div>
          <div class="sc-type" id="sc-mixed" onclick="selectScenarioType('mixed', this)">üåæ Mixed</div>
          <!-- Additional intervention types -->
          <div class="sc-type" id="sc-raingarden" onclick="selectScenarioType('raingarden', this)">üíß Rain&nbsp;Garden</div>
          <div class="sc-type" id="sc-greenroof" onclick="selectScenarioType('greenroof', this)">üè† Green&nbsp;Roof</div>
          <div class="sc-type" id="sc-permeable" onclick="selectScenarioType('permeable', this)">üõ£Ô∏è Permeable</div>
          <div class="sc-type" id="sc-shading" onclick="selectScenarioType('shading', this)">üèñÔ∏è Shading</div>
          <div class="sc-type" id="sc-removeimpervious" onclick="selectScenarioType('removeimpervious', this)">üöß Remove&nbsp;Impervious</div>
        </div>

        <div class="hint-pill"><i class="fa-solid fa-pencil"></i> Tip: In draw mode, hold <b>SHIFT</b> and drag = smooth freehand </div>

        <button class="small-btn" onclick="startPolygonDraw()">
          <i class="fa-solid fa-pencil"></i> Start Draw
        </button>
        <button class="small-btn" onclick="cancelPolygonDraw()">
          <i class="fa-solid fa-xmark"></i> Cancel Drawing
        </button>

        <div class="scenario-list" id="scenarioList"></div>
      </div>

      <button id="btnUndo" class="small-btn" onclick="undoRemoval()">
        <i class="fas fa-undo"></i> Undo Last Action
      </button>
    </div>
  </div>

  <div id="bottomPanel">
    <h3><i class="fas fa-clock"></i> Temporal & Physics Simulation</h3>

    <div class="slider-container">
      <i class="fas fa-seedling" style="width:15px; text-align:center;"></i>
      <!-- Growth Projection label with info button -->
      <span>Growth Projection</span>
      <!-- Info button opens the growth projection definition modal -->
      <button class="info-btn" onclick="openLayerInfo('growthProjection', event)" title="How is growth projection calculated?" style="margin-left:6px; width:26px; height:26px;">
        <i class="fa-solid fa-circle-info"></i>
      </button>
      <input type="range" min="1" max="30" value="1" id="sliderYear" oninput="updateGrowth(this.value)">
      <span class="slider-val" id="lblYear">Year 1</span>
    </div>

    <div class="slider-container">
      <i class="fas fa-sun" style="width:15px; text-align:center; color:#fbbf24;"></i>
      <span>Shadow Time</span>
      <input type="range" min="0" max="23" step="0.5" value="12" id="sliderTime" oninput="updateSun(this.value)">
      <span class="slider-val" id="lblTime">12:00</span>
    </div>

    <div class="slider-container">
      <i class="fa-solid fa-cloud-sun" style="width:15px; text-align:center; color:#fbbf24;"></i>
      <span>Shadows</span>
      <input type="range" min="0" max="1" step="1" value="1" id="shadowToggle" oninput="toggleShadowsFromSlider(this.value)">
      <span class="slider-val" id="lblShadows">ON</span>
    </div>
  </div>

  <!--
    Toggle tabs for collapsing panels.  These elements remain hidden until a
    panel is collapsed.  When a panel is hidden, its corresponding toggle
    appears on the edge of the viewport; clicking it will restore the
    panel.  Left panel toggle shows a right‚Äëfacing chevron; right panel
    toggle shows a left‚Äëfacing chevron.
  -->
  <div id="leftPanelToggle" onclick="toggleLeftPanel()"><i class="fa-solid fa-chevron-right"></i></div>
  <div id="rightPanelToggle" onclick="toggleRightPanel()"><i class="fa-solid fa-chevron-left"></i></div>
</div>

<!-- Assistant Chat Container: provides a natural‚Äëlanguage interface for the ecology twin -->
  <!-- Updated assistant container with header and collapsible functionality -->
  <div id="assistantContainer" class="hide">
    <div id="assistantHeader">
      <span class="assistant-title"><i class="fa-solid fa-robot"></i> AI Assistant</span>
      <button id="assistantClose">√ó</button>
    </div>
    <div id="assistantMessages"></div>
    <div id="assistantChips"></div>
    <div id="assistantSuggestions"></div>
    <div id="assistantInputArea">
      <input type="text" id="assistantInput" placeholder="Ask the ecology assistant..." />
      <button id="assistantSend">Send</button>
    </div>
  </div>
  <!-- Floating toggle to show/hide the assistant -->
  <button id="assistantToggle" class="assistant-toggle"><i class="fa-solid fa-robot"></i></button>

<div id="overviewModal">
  <div class="modal-content">
    <div class="modal-header">
      <span style="font-size:18px; font-weight:900; color:white;">Detailed Ecological Summary</span>
      <button class="close-btn" onclick="closeOverview()">√ó</button>
    </div>
    <div class="modal-body">
      <div class="report-section">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fas fa-temperature-high"></i> 1. Urban Heat Island (UHI)
        </div>
        <p><strong>Description:</strong> The Urban Heat Island (UHI) layer uses surface temperature proxies to highlight pockets of heat across the city. It shows relative temperatures based on the underlying raster; cooler areas appear green while hotter areas trend toward browns. UHI arises from heat‚Äëabsorbing materials, limited vegetation and anthropogenic heat sources.</p>
        <p><strong>Priority rule:</strong> This digital twin uses UHI values above 35¬†¬∞C combined with NDVI below 0.20 at a building‚Äôs centroid to flag heat‚Äëstressed buildings for cooling interventions.</p>
        <p><strong>Analysis tip:</strong> Overlay the UHI heatmap with vegetation (NDVI) to quickly identify where planting trees or installing green roofs can reduce temperatures.</p>
      </div>

      <div class="report-section">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fas fa-route"></i> 2. Well‚Äëbeing Corridors & Movement
        </div>
        <p><strong>Description:</strong> Well‚Äëbeing corridors are polylines linking parks and other green spaces to illustrate ecological connectivity and provide walkable routes for residents. Connected habitats improve genetic diversity and species richness, and corridors reduce plant extinction rates while boosting colonisation and mental well‚Äëbeing.</p>
        <p><strong>Dynamic arrows:</strong> The corridor lines feature animated arrowheads moving along the direction of travel. These arrows symbolise flow and make it easier to see the intended direction of ecological or pedestrian movement.</p>
        <p><strong>Use case:</strong> Turn on well‚Äëbeing corridors together with green spaces to understand how parks, lawns and trees can be connected into continuous networks that benefit both biodiversity and human well‚Äëbeing.</p>
      </div>

      <div class="report-section">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fa-solid fa-draw-polygon"></i> 3. Scenario Polygons (Smooth Draw)
        </div>
        <p><strong>Functionality:</strong> Scenario polygons let you draw intervention areas for grass, shrubs, trees or mixed vegetation. The drawing is smoothed automatically to produce natural boundaries.</p>
        <p><strong>Impacts:</strong> Each vegetation type modifies NDVI, cooling effect, stormwater infiltration and biodiversity proxies based on predefined parameters. After drawing, gauges and comparison panels update to reflect your scenario‚Äôs ecological benefits.</p>
        <p><strong>Tip:</strong> Use mixed vegetation to balance cooling, biodiversity and water management, or experiment with different types to see trade‚Äëoffs.</p>
      </div>

      <div class="report-section" style="border:none;">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fa-solid fa-city"></i> 4. 3D Context + Shadows
        </div>
        <p><strong>Details:</strong> Level‚Äëof‚ÄëDetail¬†2.2 (LOD¬†2.2) models offer realistic roof and wall geometry for buildings. They provide context for proposed interventions and allow shadow‚Äëcasting simulations.</p>
        <p><strong>Hidden attributes:</strong> Each building contains metadata such as BAG ID, construction year and footprint area (from the LOD¬†1 layer). Select a building to reveal these attributes in the popup.</p>
        <p><strong>Shadows:</strong> Shadows are computed in real time. Use them to assess how building form and orientation influence potential tree planting and facade greening.</p>
      </div>
    </div>
  </div>
</div>

<div id="layerInfoModal">
  <div class="modal-content small">
    <div class="modal-header">
      <span id="layerInfoTitle" style="font-size:18px; font-weight:900; color:white;">Layer Info</span>
      <button class="close-btn" onclick="closeLayerInfo()">√ó</button>
    </div>
    <div class="modal-body" id="layerInfoBody"></div>
  </div>
</div>

<div id="mcdaModal">
  <div class="modal-content small">
    <div class="modal-header">
      <span style="font-size:18px; font-weight:900; color:white;">Decision Support Wizard (MCDA)</span>
      <button class="close-btn" onclick="closeMCDA()">√ó</button>
    </div>
    <div class="modal-body">
      <div style="color:rgba(226,232,240,0.80); font-size:12px;">
        Prioritizes buildings for interventions using UHI, NDVI, corridor proximity, footprint area and building age (attributes remain hidden).
      </div>

      <div class="mcda-grid">
        <div class="mcda-card">
          <label>Primary Objective</label>
          <select id="mcdaObjective">
            <option value="cooling">Cooling (reduce heat)</option>
            <option value="biodiversity">Biodiversity</option>
            <option value="stormwater">Stormwater reduction</option>
            <option value="balanced" selected>Balanced</option>
          </select>
        </div>

        <div class="mcda-card">
          <label>Corridor Importance</label>
          <select id="mcdaCorridor">
            <option value="low">Low</option>
            <option value="high" selected>High</option>
          </select>
        </div>

        <div class="mcda-card">
          <label>Budget Level</label>
          <select id="mcdaBudget">
            <option value="low">Low (prefer grass/shrubs)</option>
            <option value="medium" selected>Medium (mixed)</option>
            <option value="high">High (trees + facades)</option>
          </select>
        </div>

        <div class="mcda-card">
          <label>How many priorities?</label>
          <input id="mcdaTopN" type="number" min="1" max="15" value="5" />
        </div>
      </div>

      <div class="mcda-actions">
        <button onclick="runMCDA()"><i class="fa-solid fa-wand-magic-sparkles"></i> Generate Priorities</button>
        <button onclick="clearMCDA()"><i class="fa-solid fa-eraser"></i> Clear Markers</button>
      </div>

      <div style="margin-top:12px; font-size:11px; color:rgba(226,232,240,0.62);">
        Score uses: (UHI high) + (NDVI low) + (corridor proximity) + (age) + (footprint area). Results are also spatially de-clustered.
      </div>
    </div>
  </div>
</div>

<!-- Weather details pop-up (appears when clicking the weather bar) -->
<div id="weatherModal" style="position: absolute; top: 85px; right: 20px; width:260px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: 14px; padding: 14px; z-index: 500; display: none; box-shadow: 0 10px 28px rgba(0,0,0,0.45); backdrop-filter: blur(12px);">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <span style="font-size:14px; font-weight:800; color: var(--text-main);">Weather Details</span>
    <button onclick="closeWeatherModal()" style="background:none; border:none; color: rgba(226,232,240,0.65); font-size:18px; cursor:pointer; line-height:1;">√ó</button>
  </div>
  <div id="weatherDetailContent" style="margin-top:8px; font-size:12px;"></div>
</div>

<div id="ecoPopup">
  <div class="pop-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
    <h3 id="popType" class="pop-title" style="color:rgba(45, 212, 191, 0.95); margin:0; border:none; padding:0;">Object</h3>
    <button style="background:none; border:none; color:rgba(226,232,240,0.65); font-size:18px; cursor:pointer;" onclick="closePopup()">√ó</button>
  </div>
  <div id="popContent"></div>
</div>

<div id="toast">Action Complete</div>

<script>
/* ===========================================================
   CRITICAL FIX: Cesium Property Guard
=========================================================== */
(function(){
  const P = Cesium.Property;
  if(!P || P.__guarded) return;
  P.__guarded = true;

  const orig1 = P.getValueOrDefault;
  P.getValueOrDefault = function(property, time, defaultValue, result){
    if(property === null || property === undefined) return defaultValue;
    if(typeof property.getValue === "function") return orig1(property, time, defaultValue, result);
    return property;
  };

  const orig2 = P.getValueOrClonedDefault;
  P.getValueOrClonedDefault = function(property, time, defaultValue, result){
    if(property === null || property === undefined) return defaultValue;
    if(typeof property.getValue === "function") return orig2(property, time, defaultValue, result);
    return property;
  };
})();

/* ==============================
   CONFIG
================================ */

// Cesium ION token
Cesium.Ion.defaultAccessToken =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1NmE1ZGMwYy0xNTQxLTRmMzgtYWM3NS0wYWUzMjk3MjNmYTAiLCJpZCI6MzYwODkxLCJpYXQiOjE3NjM0ODU3MTF9.D_qofjwKf6t1mnUO06Hkz-t7xr2UrPHklhG3a5Lfz8E";

// Your ION asset (LOD 2.2)
const ION_LOD22_ASSET_ID = 4261194;

// Hidden (backend) building attributes file (LOD1 polygons)
// ==========================
// R2 helper (Cloudflare)
// ==========================
// Pull R2 settings from the global DT_CONFIG (set in config.js).  When no base is defined
// this will gracefully fall back to local relative paths.  A prefix can optionally be
// provided to namespace all objects in your bucket (e.g. `energy`, `ecology`), and is
// stripped of leading/trailing slashes to avoid double separators.
const R2_BASE = (window.DT_CONFIG?.R2_BASE || "").replace(/\/$/, "");
const R2_PREFIX = (window.DT_CONFIG?.R2_PREFIX || "").replace(/^\/+|\/+$/g, "");
function dataUrl(name) {
  // If no R2 base is defined we return the raw name (local relative path).
  if (!R2_BASE) return name;
  const clean = String(name || "").replace(/^\/+/, "");
  return R2_PREFIX ? `${R2_BASE}/${R2_PREFIX}/${clean}` : `${R2_BASE}/${clean}`;
}

const LOD1_BUILDINGS_GEOJSON = dataUrl("twekkelerveld_buildings_energy_ageEUI_wgs84_201225.geojson");

// Files
const GREENSPACES_GEOJSON     = dataUrl("greenspace_4326.geojson");
const TREES_OPEN_GEOJSON      = dataUrl("trees_co2_4326_final.geojson"); // Updated filename
// Municipality trees dataset; use correct filename (plural trees_ and point)
const TREES_MUNI_GEOJSON      = dataUrl("trees_point_municipality.geojson");
const NDVI_PNG                = dataUrl("NDVI.png");
const UHI_PNG                 = dataUrl("UHI.png");

// for age normalization
const NOW_YEAR = 2025;

/* Bounds used for raster probing */
const bounds = { west: 6.8445, south: 52.2249, east: 6.8661, north: 52.2363 };

/* --------------------------------------------------------------------
   UHI BOUNDS ADJUSTMENT
   The original UHI PNG did not perfectly align with the study area.
   To compensate for the observed offset, we apply a small longitudinal
   and latitudinal shift when overlaying the heatmap.  If the image
   still appears misaligned, tweak these offsets accordingly.
-------------------------------------------------------------------- */
// Reset offsets for the UHI heatmap. Previously negative longitude
// and positive latitude values were used to compensate for misalignment.
// Based on updated testing and the provided screenshot, those
// corrections were over‚Äëshifting the raster. Setting both values to
// zero ensures the heatmap aligns with the study area bounds. Adjust
// lon and lat here if future tweaks are needed.
const UHI_OFFSET = { lon: 0.0, lat: 0.0 };
const UHI_BOUNDS = {
  west: bounds.west + UHI_OFFSET.lon,
  south: bounds.south + UHI_OFFSET.lat,
  east: bounds.east + UHI_OFFSET.lon,
  north: bounds.north + UHI_OFFSET.lat
};

/* ==============================
   VIEWER
================================ */
const viewer = new Cesium.Viewer("cesiumContainer", {
  terrain: Cesium.Terrain.fromWorldTerrain(),
  animation: false,
  timeline: false,
  baseLayerPicker: false,
  selectionIndicator: false,
  infoBox: false,
  navigationHelpButton: false,
  sceneModePicker: false,
  homeButton: false,
  geocoder: false,
  shadows: true,
  contextOptions: { webgl: { preserveDrawingBuffer: true } }
});

viewer.cesiumWidget.creditContainer.style.display = "none";
viewer.scene.globe.enableLighting = true;
viewer.scene.globe.depthTestAgainstTerrain = true;
viewer.scene.postProcessStages.fxaa.enabled = true;

viewer.shadowMap.darkness = 0.35;
viewer.shadowMap.enabled = true;

viewer.camera.setView({
  destination: Cesium.Rectangle.fromDegrees(bounds.west, bounds.south, bounds.east, bounds.north)
});

viewer.canvas.addEventListener('contextmenu', (e) => e.preventDefault(), false);

/* ==============================
   SAFE GETTERS
================================ */
function safeGet(v, time){
  if(v === null || v === undefined) return v;
  return (typeof v.getValue === "function") ? v.getValue(time) : v;
}
function safePropString(entity, keys, time){
  if(!entity || !entity.properties) return "";
  for(const k of keys){
    const p = entity.properties[k];
    if(p === undefined || p === null) continue;
    const val = safeGet(p, time);
    if(val !== undefined && val !== null && String(val).trim() !== "") return String(val);
  }
  return "";
}
function safePropNumber(entity, keys, time){
  const s = safePropString(entity, keys, time);
  const n = Number(String(s).replace(",", "."));
  return Number.isFinite(n) ? n : null;
}
function safePolygonPositions(polygon, time){
  if(!polygon || !polygon.hierarchy) return [];
  const h = safeGet(polygon.hierarchy, time);
  if(!h) return [];
  if(h.positions && Array.isArray(h.positions)) return h.positions;
  if(Array.isArray(h)) return h;
  return [];
}

/* ==============================
   GROWTH PROJECTION UPDATE
   When a municipal tree is selected, display low/medium/high projections
   for DBH increment (cm), AGB (kg) and CO‚ÇÇ (kg/yr).  If no tree or an
   open dataset tree is selected this panel is hidden.
================================ */
function updateGrowthInfo(treeEntity){
  // Elements for growth panel and header
  const header = document.getElementById("growthHeader");
  const panel  = document.getElementById("growthPanel");
  // If no entity or entity is not municipal, hide panel
  if(!treeEntity || treeEntity._type !== "tree_muni"){
    if(header) header.style.display = "none";
    if(panel) panel.style.display  = "none";
    return;
  }
  const t = viewer.clock.currentTime || Cesium.JulianDate.now();
  // Helper to format triple values; uses a fallback of ‚Äú‚Äî‚Äù
  const formatTriple = (lo, med, hi, unit) => {
    const f = v => (v !== null && v !== undefined && v !== "" && !isNaN(v)) ? (Math.round(Number(v) * 100) / 100) : null;
    const fl = f(lo);
    const fm = f(med);
    const fh = f(hi);
    const pieces = [
      fl !== null ? fl + (unit || "") : "‚Äî",
      fm !== null ? fm + (unit || "") : "‚Äî",
      fh !== null ? fh + (unit || "") : "‚Äî"
    ];
    return pieces.join(" / ");
  };
  // Read DBH increment low/med/high
  const dbhLow  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.dbhIncLow,  t);
  const dbhMed  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.dbhIncMed,  t);
  const dbhHigh = safePropNumber(treeEntity, TREE_EXTRA_KEYS.dbhIncHigh, t);
  // Read AGB next low/med/high (kg)
  const agbLow  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.agbNextLow,  t);
  const agbMed  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.agbNextMed,  t);
  const agbHigh = safePropNumber(treeEntity, TREE_EXTRA_KEYS.agbNextHigh, t);
  // Read CO‚ÇÇ next low/med/high (kg/yr)
  const co2Low  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.co2NextLow,  t);
  const co2Med  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.co2NextMed,  t);
  const co2High = safePropNumber(treeEntity, TREE_EXTRA_KEYS.co2NextHigh, t);
  // Update DOM values
  const elDbh  = document.getElementById("valDbhGrowth");
  const elAgb  = document.getElementById("valAgbGrowth");
  const elCo2  = document.getElementById("valCo2Growth");
  if(elDbh) elDbh.innerText = formatTriple(dbhLow, dbhMed, dbhHigh, " cm");
  if(elAgb) elAgb.innerText = formatTriple(agbLow, agbMed, agbHigh, " kg");
  if(elCo2) elCo2.innerText = formatTriple(co2Low, co2Med, co2High, " kg/yr");
  if(header) header.style.display = "";
  if(panel)  panel.style.display  = "";
}

/* ==============================
   LAYERS REGISTRY
================================ */
const layers = {
  buildings3d: null,
  trees_open: null, // Open data trees
  trees_muni: null, // Muni data trees
  greenery: null,
  corridors: null,
  heatmap: null
};

/* ==============================
   RASTER PROBING (NDVI + UHI)
================================ */
const dataMaps = {
  ndvi: { ctx: null, width: 0, height: 0, min: 0.05, max: 0.65, loaded: false },
  uhi:  { ctx: null, width: 0, height: 0, min: 28.0, max: 40.0, loaded: false }
};

function loadMapData(id, url) {
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = url;
  img.onload = () => {
    const c = document.getElementById("canvas" + id.toUpperCase());
    c.width = img.width;
    c.height = img.height;

    const ctx = c.getContext("2d", { willReadFrequently: true });
    ctx.drawImage(img, 0, 0);
    dataMaps[id].ctx = ctx;
    dataMaps[id].width = img.width;
    dataMaps[id].height = img.height;
    dataMaps[id].loaded = true;
  };
  img.onerror = () => console.warn(`Image ${url} failed to load. Probing will use defaults.`);
}
loadMapData("ndvi", NDVI_PNG);
loadMapData("uhi",  UHI_PNG);

function getPixelData(lat, lon) {
  const u = (lon - bounds.west) / (bounds.east - bounds.west);
  const v = (bounds.north - lat) / (bounds.north - bounds.south);

  let res = { ndvi: "0.15", uhi: "34.5¬∞C", uhiVal: 34.5 };
  if (u < 0 || u > 1 || v < 0 || v > 1) return res;

  try {
    if (dataMaps.ndvi.ctx) {
      const x = Math.min(Math.floor(u * dataMaps.ndvi.width), dataMaps.ndvi.width - 1);
      const y = Math.min(Math.floor(v * dataMaps.ndvi.height), dataMaps.ndvi.height - 1);
      const p = dataMaps.ndvi.ctx.getImageData(x, y, 1, 1).data;
      const gray = (p[0] + p[1] + p[2]) / 3;
      const val = dataMaps.ndvi.min + (gray / 255) * (dataMaps.ndvi.max - dataMaps.ndvi.min);
      res.ndvi = val.toFixed(2);
    }
    if (dataMaps.uhi.ctx) {
      const x2 = Math.min(Math.floor(u * dataMaps.uhi.width), dataMaps.uhi.width - 1);
      const y2 = Math.min(Math.floor(v * dataMaps.uhi.height), dataMaps.uhi.height - 1);
      const p2 = dataMaps.uhi.ctx.getImageData(x2, y2, 1, 1).data;
      const gray2 = (p2[0] + p2[1] + p2[2]) / 3;
      const val2 = dataMaps.uhi.min + (gray2 / 255) * (dataMaps.uhi.max - dataMaps.uhi.min);
      res.uhiVal = val2;
      res.uhi = val2.toFixed(1) + "¬∞C";
    }
  } catch (e) {
    console.warn("Pixel read error:", e);
  }
  return res;
}

/* ==============================
   UHI HEATMAP LAYER
================================ */
const heatmapLayer = viewer.imageryLayers.addImageryProvider(
  new Cesium.SingleTileImageryProvider({
    url: UHI_PNG,
    // Use adjusted bounds for the UHI PNG to improve alignment
    rectangle: Cesium.Rectangle.fromDegrees(
      UHI_BOUNDS.west,
      UHI_BOUNDS.south,
      UHI_BOUNDS.east,
      UHI_BOUNDS.north
    )
  })
);
heatmapLayer.alpha = 0.45;
heatmapLayer.show = false; // Default off
layers.heatmap = heatmapLayer;

/* ==============================
   LOD 2.2 BUILDINGS
================================ */
let lod22Tileset = null;
(async () => {
  try{
    lod22Tileset = await Cesium.Cesium3DTileset.fromIonAssetId(ION_LOD22_ASSET_ID);
    lod22Tileset.maximumScreenSpaceError = 2;
    lod22Tileset.dynamicScreenSpaceError = true;
    lod22Tileset.shadows = Cesium.ShadowMode.ENABLED;
    lod22Tileset.show = true;

    lod22Tileset.style = new Cesium.Cesium3DTileStyle({
      color: "color('#d1d5db', 0.85)"
    });

    viewer.scene.primitives.add(lod22Tileset);
    layers.buildings3d = lod22Tileset;
  }catch(e){
    console.warn("LOD 2.2 tileset failed:", e);
    layers.buildings3d = { show: false };
    document.getElementById("sw-buildings3d")?.classList.remove("active");
    showToast("LOD 2.2 failed (check token access / asset sharing)");
  }
})();

/* ==============================
   CORRIDOR MATERIAL (moving arrows)
================================ */
(function registerPolylineFlow(){
  if(Cesium.Material.PolylineFlowType) return;

  Cesium.Material.PolylineFlowType = 'PolylineFlow';
  Cesium.Material.PolylineFlowSource = `
    czm_material czm_getMaterial(czm_materialInput materialInput)
    {
      czm_material material = czm_getDefaultMaterial(materialInput);
      vec2 st = materialInput.st;

      float s = fract(st.s * repeat - time);
      float t = st.t - 0.5;

      float body = smoothstep(0.12, 0.18, s) * (1.0 - smoothstep(0.52, 0.58, s));
      body *= (1.0 - smoothstep(0.18, 0.22, abs(t)));

      float head = smoothstep(0.52, 0.58, s) * (1.0 - smoothstep(0.82, 0.88, s));
      float k = clamp((s - 0.52) / 0.30, 0.0, 1.0);
      float w = mix(0.22, 0.02, k);
      head *= (1.0 - smoothstep(w, w + 0.02, abs(t)));

      float arrow = clamp(body + head, 0.0, 1.0);

      float base = 0.10;
      material.diffuse = color.rgb;
      material.alpha = color.a * (base + 0.90 * arrow);
      return material;
    }
  `;

  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineFlowType, {
    fabric: {
      type: Cesium.Material.PolylineFlowType,
      uniforms: {
        // Use a vibrant green for corridors and reduce the repeat count so arrows
        // are longer and more recognisable.  A smaller repeat value means
        // fewer, larger arrows along each polyline.
        color: new Cesium.Color(0.145, 0.86, 0.50, 0.95),
        time: 0,
        repeat: 8.0
      },
      source: Cesium.Material.PolylineFlowSource
    },
    translucent: () => true
  });
})();

function PolylineFlowMaterialProperty(options){
  options = options || {};
  this._definitionChanged = new Cesium.Event();
  this.color = options.color || Cesium.Color.fromCssColorString('#fbbf24');
  this.duration = options.duration || 1.8;
  this.repeat = options.repeat || 18.0;
  this._t0 = performance.now();
}
Object.defineProperties(PolylineFlowMaterialProperty.prototype, {
  isConstant: { get: () => false },
  definitionChanged: { get: function(){ return this._definitionChanged; } }
});
PolylineFlowMaterialProperty.prototype.getType = () => Cesium.Material.PolylineFlowType;
PolylineFlowMaterialProperty.prototype.getValue = function(_time, result){
  if(!result) result = {};
  result.color = this.color;
  const sec = (performance.now() - this._t0) / 1000.0;
  result.time = (sec / this.duration) % 1.0;
  result.repeat = this.repeat;
  return result;
};
PolylineFlowMaterialProperty.prototype.equals = function(other){ return this === other; };

/* ==============================
   GREEN SPACES + CORRIDORS
================================ */
let corridorPolylines = [];
let corridorEntities = [];

Cesium.GeoJsonDataSource.load(GREENSPACES_GEOJSON, {
  clampToGround: true,
  stroke: Cesium.Color.fromCssColorString("#2dd4bf"),
  strokeWidth: 2,
  fill: Cesium.Color.fromCssColorString("#14b8a6").withAlpha(0.30)
}).then(ds => {
  layers.greenery = ds;
  viewer.dataSources.add(ds);

  for (const e of ds.entities.values) {
    e._type = "green";
    if (e.polygon){
      e.polygon.classificationType = Cesium.ClassificationType.BOTH;
    }
  }

  const centroids = ds.entities.values
    .filter(x => x.polygon)
    .map(x => {
      const t = viewer.clock.currentTime || Cesium.JulianDate.now();
      return polygonCentroidCartesian(safePolygonPositions(x.polygon, t));
    })
    .filter(Boolean);

  corridorPolylines = [];
  corridorEntities = [];

  const maxLinkDist = 260;
  for(let i=0; i<centroids.length; i++){
    let bestJ = -1, bestD = Infinity;
    for(let j=0; j<centroids.length; j++){
      if(i===j) continue;
      const d = Cesium.Cartesian3.distance(centroids[i], centroids[j]);
      if(d < bestD && d <= maxLinkDist){ bestD = d; bestJ = j; }
    }
    if(bestJ !== -1){
      const positions = [centroids[i], centroids[bestJ]];
      corridorPolylines.push(positions);
      // Compute length and well‚Äëbeing score based on connectivity
      const lengthMeters = bestD;
      const score = Math.max(0, (1 - (lengthMeters / maxLinkDist)) * 100);

      const ent = viewer.entities.add({
        polyline: {
          positions,
          // Increase line width for better visibility
          width: 6,
          // Use a softer green colour and adjust arrow repeat for a more approachable look
          material: new PolylineFlowMaterialProperty({
            // light green (#86efac) conveys a friendlier feel than the previous dark green
            color: Cesium.Color.fromCssColorString('#86efac').withAlpha(0.95),
            // Slow down the arrow animation slightly
            duration: 2.8,
            // Increase repeat to create smaller, more subtle arrows along the corridor
            repeat: 12.0
          }),
          clampToGround: true
        },
        show: false
      });
      // Tag entity type and store length/score properties for popups
      ent._type = "corridor";
      ent._lengthMeters = lengthMeters;
      ent._wellBeingScore = score;
      corridorEntities.push(ent);
    }
  }

  layers.corridors = {
    show: false,
    toggle: (s) => {
      corridorEntities.forEach(e => e.show = s);
      viewer.scene.requestRender();
    }
  };

  updateLegend();
}).catch(e => console.warn("Green spaces load failed:", e));

/* ==============================
   LAYER 1: TREES OPEN DATA (Clickable)
================================ */
const TREE_KEYS = {
  species: ["species","soort","boomsoort","tree_type","type","genus","latin_name","naam"],
  height: ["tree_height_m1","tree_height_m","height_m","height","hoogte","hoogte_m","h_m"],
  co2: [
    "co2_yr_kg",        // new property name in final dataset
    "co2_yr_med",       // additional variant
    "co2_kg", "co2kg", "co2", "co2_stored_kg", "co2_storage_kg", "co2_kg_year", "co2_kg_yr"
  ]
};

/**
 * Additional property keys for trees.  These arrays list potential
 * property names across both the open and municipal tree datasets.
 * Using the same approach as TREE_KEYS, we search for the first
 * available key on the entity and return its value.  These keys
 * allow us to extract crown area, above‚Äëground biomass (AGB), size
 * class, and future growth metrics such as DBH increment and CO‚ÇÇ
 * projections.  If a property does not exist for the selected tree
 * the corresponding value will remain null and will be rendered as ‚Äú‚Äî‚Äù.
 */
const TREE_EXTRA_KEYS = {
  crown:      ["crown_m2","crown","area_m2","crown_area_m2"],
  agb:        ["agb_kg","agb","agb_m","agb_next_kg","agb_next"],
  sizeClass:  ["size_class","sizeclass","dbh_class","dbh_size_class"],
  dbhInc:     ["dbh_inc_cm","dbh_inc"],
  dbhIncLow:  ["dbh_inc_low"],
  dbhIncMed:  ["dbh_inc_med"],
  dbhIncHigh: ["dbh_inc_high"],
  agbNextLow:  ["agb_next_low"],
  agbNextMed:  ["agb_next_med"],
  agbNextHigh: ["agb_next_high"],
  co2NextLow:  ["co2_yr_low"],
  co2NextMed:  ["co2_yr_med"],
  co2NextHigh: ["co2_yr_high"]
};

Cesium.GeoJsonDataSource.load(TREES_OPEN_GEOJSON, { clampToGround: true })
.then(ds => {
  layers.trees_open = ds;
  viewer.dataSources.add(ds);

  for (const e of ds.entities.values) {
    e.billboard = undefined;

    const t = viewer.clock.currentTime || Cesium.JulianDate.now();

    const co2Stored = safePropNumber(e, TREE_KEYS.co2, t) ?? 0;
    const height = safePropNumber(e, TREE_KEYS.height, t) ?? 0;
    const species = safePropString(e, TREE_KEYS.species, t) || "Tree";

    const size = Math.max(3, Math.min(8, (co2Stored || 50) / 80));
    const color = (co2Stored > 600) ? "#0d9488" : (co2Stored > 400 ? "#2dd4bf" : "#99f6e4");

    e.point = {
      pixelSize: size,
      color: Cesium.Color.fromCssColorString(color),
      outlineColor: Cesium.Color.WHITE,
      outlineWidth: 1,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      disableDepthTestDistance: Number.POSITIVE_INFINITY
    };

    e._type = "tree_open";
    e._data = { co2Stored, height, species, baseSize: size };
  }
  updateLegend();
}).catch(e => console.warn("Open Data Trees load failed:", e));

/* ==============================
   LAYER 2: TREES MUNICIPALITY (Clickable with full info)
================================ */
Cesium.GeoJsonDataSource.load(TREES_MUNI_GEOJSON, { clampToGround: true })
.then(ds => {
  layers.trees_muni = ds;
  viewer.dataSources.add(ds);

  for (const e of ds.entities.values) {
    e.billboard = undefined;
    
    // Different visual style for Muni trees (blue-ish)
    e.point = {
      pixelSize: 6,
      color: Cesium.Color.fromCssColorString("#60a5fa"), // Blue-400
      outlineColor: Cesium.Color.WHITE,
      outlineWidth: 1,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      disableDepthTestDistance: Number.POSITIVE_INFINITY
    };

    e._type = "tree_muni";
    // We don't extract specific props here, we extract them dynamically on click
  }
  updateLegend();
}).catch(e => console.warn("Municipality Trees load failed:", e));

/* ==============================
   HIDDEN BACKEND BUILDINGS (LOD1 polygons)
================================ */
const LOD1_KEYS = {
  bag: ["bag_id","pand_id","id","identificatie","identification","rdf_seealso"],
  bouwjaar: ["bouwjaar","year","build_year","construction_year","bouwjaar_pand","vbo_bouwjaar"],
};

function getPropString(entity, keys){
  const t = viewer?.clock?.currentTime || Cesium.JulianDate.now();
  return safePropString(entity, keys, t);
}

let lod1Ds = null;
let _lod1ReadyResolve = null;
const lod1Ready = new Promise((resolve) => { _lod1ReadyResolve = resolve; });

let lod1Spatial = [];

function pointInRing(x, y, ring){
  let inside = false;
  for(let i=0, j=ring.length-1; i<ring.length; j=i++){
    const xi = ring[i][0], yi = ring[i][1];
    const xj = ring[j][0], yj = ring[j][1];
    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / ((yj - yi) + 1e-12) + xi);
    if(intersect) inside = !inside;
  }
  return inside;
}

function rebuildLod1SpatialIndex(){
  lod1Spatial = [];
  if(!lod1Ds) return;

  const t = viewer.clock.currentTime || Cesium.JulianDate.now();
  const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);

  for(const e of lod1Ds.entities.values){
    if(e._type !== 'lod1_building' || !e.polygon) continue;

    const pos = safePolygonPositions(e.polygon, t);
    if(!pos || pos.length < 3) continue;

    const ring = [];
    let minx=Infinity, miny=Infinity, maxx=-Infinity, maxy=-Infinity;

    for(const c3 of pos){
      const carto = Cesium.Cartographic.fromCartesian(c3);
      const p = proj.project(carto);
      const x = p.x, y = p.y;
      ring.push([x,y]);
      if(x<minx) minx=x; if(y<miny) miny=y; if(x>maxx) maxx=x; if(y>maxy) maxy=y;
    }

    const cen = polygonCentroidCartographic(pos);
    let cx=(minx+maxx)/2, cy=(miny+maxy)/2;
    if(cen){
      const cp = proj.project(cen);
      cx = cp.x; cy = cp.y;
    }

    lod1Spatial.push({
      entity: e,
      ring,
      bbox: {minx,miny,maxx,maxy},
      centroid: [cx,cy]
    });
  }
}

function findLod1BuildingByLonLat(lonDeg, latDeg){
  if(!lod1Spatial.length) return null;

  const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);
  const p = proj.project(Cesium.Cartographic.fromDegrees(lonDeg, latDeg));
  const x = p.x, y = p.y;

  const candidates = lod1Spatial.filter(r =>
    x>=r.bbox.minx && x<=r.bbox.maxx && y>=r.bbox.miny && y<=r.bbox.maxy
  );

  for(const c of candidates){
    if(pointInRing(x, y, c.ring)) return c.entity;
  }

  // fallback: nearest centroid within 60m
  let bestD2 = Infinity;
  let bestRec = null;
  for(const r of lod1Spatial){
    const dx = x - r.centroid[0];
    const dy = y - r.centroid[1];
    const d2 = dx*dx + dy*dy;
    if(d2 < bestD2){
      bestD2 = d2;
      bestRec = r;
    }
  }
  if(bestRec && Math.sqrt(bestD2) <= 60) return bestRec.entity;
  return null;
}

// Basic Env computation for MCDA (kept for wizard, removed from Heat-Stress Layer logic)
function computeEnvForEntity(e){
  try{
    if(!e || !e.polygon) return;
    const t = viewer.clock.currentTime || Cesium.JulianDate.now();
    const c = polygonCentroidCartographic(safePolygonPositions(e.polygon, t));
    if(!c){ e._env = null; e._centroid = null; return; }

    const lat = Cesium.Math.toDegrees(c.latitude);
    const lon = Cesium.Math.toDegrees(c.longitude);
    e._env = getPixelData(lat, lon);
    e._centroid = { lat, lon };
  }catch(_){ e._env = null; e._centroid = null; }
}

Cesium.GeoJsonDataSource.load(LOD1_BUILDINGS_GEOJSON, { clampToGround: true })
.then(ds => {
  lod1Ds = ds;
  viewer.dataSources.add(ds);

  const t = viewer.clock.currentTime || Cesium.JulianDate.now();

  for (const e of ds.entities.values) {
    if(!e.polygon) continue;
    // Keep invisible (backend-only)
    e.show = false;
    e._type = "lod1_building";
    e._bag = getPropString(e, LOD1_KEYS.bag);
    e._bouwjaar = getPropString(e, LOD1_KEYS.bouwjaar);

    // compute footprint area (m¬≤)
    const pos = safePolygonPositions(e.polygon, t);
    e._areaM2 = polygonAreaM2(pos);
    computeEnvForEntity(e);
  }

  ds.show = false; // hard hidden
  rebuildLod1SpatialIndex();
  if(_lod1ReadyResolve) _lod1ReadyResolve(true);
}).catch(e => {
  console.warn("Backend buildings (LOD1) load failed:", e);
  if(_lod1ReadyResolve) _lod1ReadyResolve(false);
});

/* ==============================
   LEGEND
================================ */
function setLegend(title, rows){
  const body = document.getElementById("legendBody");
  document.getElementById("legendTitle").innerText = title;

  body.innerHTML = "";
  rows.forEach(r => {
    const div = document.createElement("div");
    div.className = "leg-row";
    div.innerHTML = `
      <div class="leg-chip">
        <span class="chip ${r.type || ""}" style="background:${r.color};"></span>
        <span>${r.label}</span>
      </div>
      <span style="color:rgba(226,232,240,0.62);">${r.meta || ""}</span>
    `;
    body.appendChild(div);
  });
}

/* --------------------------------------------------------------------
   Panel collapse handlers
   These functions hide or show the side panels and reveal their
   corresponding toggle tabs.  When a panel is collapsed the panel
   element is hidden (display:none) and its toggle tab becomes
   visible; clicking the tab will restore the panel.  Feel free to
   adjust this logic to animate the transition or to remember
   collapsed state across sessions.
-------------------------------------------------------------------- */
function toggleLeftPanel(){
  const panel = document.getElementById('leftPanel');
  const toggle = document.getElementById('leftPanelToggle');
  if(!panel) return;
  if(panel.style.display === 'none'){
    panel.style.display = '';
    if(toggle) toggle.style.display = 'none';
  } else {
    panel.style.display = 'none';
    if(toggle) toggle.style.display = 'flex';
  }
}
function toggleRightPanel(){
  const panel = document.getElementById('rightPanel');
  const toggle = document.getElementById('rightPanelToggle');
  if(!panel) return;
  if(panel.style.display === 'none'){
    panel.style.display = '';
    if(toggle) toggle.style.display = 'none';
  } else {
    panel.style.display = 'none';
    if(toggle) toggle.style.display = 'flex';
  }
}

function updateLegend(){
  const on = (id) => document.getElementById("sw-"+id)?.classList.contains("active");

  if(on("heatmap")){
    // Custom legend for the UHI heatmap.  Colours are ordered from cool
    // (greens) through moderate (light green) to warm (brown) and very warm
    // (light brown).  Adjust colours or labels here to fine‚Äëtune the
    // representation of surface temperature.
    setLegend("UHI Heatmap", [
      { label: "UHI / Surface temp", color: "#16a34a", meta: "low" },       // dark green ‚Äì cooler areas
      { label: "UHI / Surface temp", color: "#4ade80", meta: "moderate" },  // light green
      { label: "UHI / Surface temp", color: "#92400e", meta: "high" },      // brown
      { label: "UHI / Surface temp", color: "#f5deb3", meta: "very high" } // light brown
    ]);
    return;
  }

  setLegend("Legend", [
    {label:"Trees (Open)", color:"#10b981", meta:"points"},
    {label:"Trees (Muni)", color:"#60a5fa", meta:"points"},
    {label:"Green spaces", color:"rgba(20,184,166,0.55)", meta:"polygons"},
    {label:"Corridors", color:"#fbbf24", meta:"moving arrows", type:"line"},
    {label:"Buildings", color:"rgba(209,213,219,0.75)", meta:"LOD 2.2"},
    {label:"Green facades", color:"rgba(34,197,94,0.85)", meta:"squares"}
  ]);
}

/* ==============================
   LAYER TOGGLES
================================ */
function toggleLayer(name){
  const sw = document.getElementById("sw-"+name);
  if(!sw) return;

  sw.classList.toggle("active");
  const isOn = sw.classList.contains("active");

  if(name === "corridors"){
    if(layers.corridors) layers.corridors.toggle(isOn);
    updateLegend();
    return;
  }

  if(name === "heatmap"){
    if(layers.heatmap) layers.heatmap.show = isOn;
    updateLegend();
    return;
  }

  if(name === "buildings3d"){
    if(layers.buildings3d && typeof layers.buildings3d.show !== "undefined"){
      layers.buildings3d.show = isOn;
      viewer.scene.requestRender();
    }
    return;
  }

  if(layers[name] && typeof layers[name].show !== "undefined"){
    layers[name].show = isOn;
    viewer.scene.requestRender();
    return;
  }
}

/* ==============================
   INFO MODALS
================================ */
const LAYER_INFO = {
  trees_open: {
    title: "Tree Inventory (Open Data)",
    html: `
      <p><strong>Description:</strong> Publicly available street tree inventory. Each point represents a documented tree from the city's open dataset.</p>
      <p><strong>Attributes:</strong></p>
      <ul style="margin-left:16px;">
        <li><b>Species</b> (taxonomic name)</li>
        <li><b>Height</b> (approximate metres)</li>
        <li><b>Crown area</b> (m¬≤)</li>
        <li><b>Above‚Äëground biomass (AGB)</b> if available</li>
        <li><b>Size class</b> (small, medium, large)</li>
        <li><b>CO‚ÇÇ stored</b> (kg of carbon stored in the tree)</li>
      </ul>
      <p>Click a tree to view these details in the popup. Growth projections (future DBH/AGB/CO‚ÇÇ) are only available for municipal records.</p>
    `
  },
  trees_muni: {
    title: "Tree Points (Municipality)",
    html: `
      <p><strong>Description:</strong> Official municipal tree registry capturing extensive biological and growth information about each tree.</p>
      <p><strong>Attributes:</strong></p>
      <ul style="margin-left:16px;">
        <li><b>Species</b> (common name and scientific name)</li>
        <li><b>Height</b> (m), <b>Crown area</b> (m¬≤) and <b>Diameter at Breast Height (DBH)</b> (cm)</li>
        <li><b>Size class</b> (S/M/L) based on canopy spread</li>
        <li><b>Above‚Äëground biomass (AGB)</b> (kg)</li>
        <li><b>CO‚ÇÇ stored</b> (kg of carbon in the tree)</li>
        <li><b>Growth projections</b>: low/medium/high forecasts for DBH increment, future biomass and annual CO‚ÇÇ sequestration</li>
      </ul>
      <p>Click a tree to view its current attributes. When a municipal tree is selected, the growth projections panel on the right shows how it may evolve over time.</p>
    `
  },
  greenery: {
    title: "Green Spaces",
    html: `
      <p><strong>Description:</strong> Polygons delineating parks, lawns, sports fields and other vegetated areas.</p>
      <p>These areas provide habitat, recreation space and are used when analysing corridor connectivity and scenario planning.</p>
    `
  },
  buildings3d: {
    title: "Buildings (LOD 2.2)",
    html: `
      <p><strong>Description:</strong> Level of Detail 2.2 building models sourced from Cesium ION (Asset ID: ${ION_LOD22_ASSET_ID}).</p>
      <p>Each model has a detailed roof and wall geometry. Hidden attributes from LOD1 include BAG ID, construction year and footprint area.</p>
      <p>Click a building to inspect these attributes in the popup.</p>
    `
  },
  corridors: {
    title: "Well‚Äëbeing Corridors (Moving Arrows)",
    html: `
      <p><strong>Description:</strong> Well‚Äëbeing corridors are lines connecting parks and other green spaces that facilitate movement for wildlife, pollinators and people. Connected habitats improve gene flow and genetic diversity, and studies have shown that plant species richness increases in connected gardens and corridors reduce plant extinction rates while boosting colonisation.</p>
      <p>These corridors also provide walkable routes for residents, supporting recreation and mental health. Each corridor has a well‚Äëbeing score based on its length and connectivity; shorter links yield higher scores because they allow easier wildlife movement and shorter walking distances for humans.</p>
    `
  },
  growthProjection: {
    title: "Growth Projection",
    html: `
      <p><strong>Description:</strong> The growth projection panel shows simulated changes in tree diameter at breast height (DBH), above‚Äëground biomass (AGB) and carbon sequestration over future years. These projections are calculated from allometric equations that relate biomass to wood density (œÅ), DBH (D) and tree height (H), such as AGB = 0.0673 √ó (œÅ √ó D¬≤ √ó H)<sup>0.96</sup>. By comparing low, medium and high growth scenarios, the projection helps to estimate future biomass and CO‚ÇÇ sequestration.</p>
      <p>Ecosystem services provided by trees‚Äîsuch as carbon storage, shade and habitat‚Äîcontribute to multiple components of human well‚Äëbeing, including health, security, social relations and freedom of choice. Growth projections therefore inform planning decisions that maximise ecological and human benefits.</p>
    `
  },
  heatmap: {
    title: "Heatmap (UHI)",
    html: `
      <p><strong>Description:</strong> Raster overlay representing the urban heat island (UHI) intensity based on surface temperature proxies.</p>
      <p>The values are measured in ¬∞C and interpolated per pixel from a georeferenced PNG (${UHI_PNG}). When toggled on, cooler and warmer areas are visualised across the city.</p>
    `
  }
};

function openLayerInfo(key, ev){
  if(ev) ev.stopPropagation();
  const box = document.getElementById("layerInfoModal");
  const t = document.getElementById("layerInfoTitle");
  const b = document.getElementById("layerInfoBody");

  const info = LAYER_INFO[key] || { title:"Layer Info", html:"<p>No details available.</p>" };
  t.innerText = info.title;
  b.innerHTML = info.html;
  // Optional: enrich with Wikipedia context
  try{ appendWikiToLayerInfo(key, b); }catch(e){}

  box.style.display = "flex";
}
function closeLayerInfo(){ document.getElementById("layerInfoModal").style.display = "none"; }
function openOverview(){ document.getElementById("overviewModal").style.display = "flex"; }
function closeOverview(){ document.getElementById("overviewModal").style.display = "none"; }
function openMCDA(){ document.getElementById('mcdaModal').style.display = 'flex'; }
function closeMCDA(){ document.getElementById('mcdaModal').style.display = 'none'; }

// Removed toggleRightPanel logic as user requested static panels

/* ==============================
   SIMULATION DATA
================================ */
let sim = { trees: 0, facades: 0, cost: 0, co2: 0, uhi: 0, bio: 1.20, water: 0 };
let impactLoss = { co2: 0, water: 0, temp: 0, money: 0 };
let undoStack = [];
let currentYear = 1;

const speciesData = {
  oak:  { name: "Oak",  cost: 250, Smax: 1600, k: 0.18, t0: 12, uhi: 0.012, bio: 0.05, water: 1000, color: "#eab308" },
  birch:{ name: "Birch",cost: 100, Smax:  900, k: 0.22, t0: 10, uhi: 0.005, bio: 0.02, water:  400, color: "#f97316" },
  pine: { name: "Pine", cost: 150, Smax: 1100, k: 0.20, t0: 11, uhi: 0.008, bio: 0.03, water:  600, color: "#84cc16" }
};
let selectedSpecies = "oak";

const facadeTypes = {
  ivy: { name: "Ivy", cost: 3500, co2: 6, uhi: 0.018, bio: 0.07, water: 120, color: "#22c55e" },
  livingwall: { name: "Living Wall", cost: 6000, co2: 10, uhi: 0.028, bio: 0.10, water: 180, color: "#16a34a" },
  trellis: { name: "Trellis", cost: 2000, co2: 4, uhi: 0.012, bio: 0.05, water: 80, color: "#84cc16" }
};
let selectedFacadeType = "ivy";

function treeStorageCO2(spec, age){
  const e = Math.exp(-spec.k * (age - spec.t0));
  return spec.Smax / (1 + e);
}
function treeAnnualCO2(spec, age){
  const e = Math.exp(-spec.k * (age - spec.t0));
  return spec.Smax * spec.k * e / Math.pow(1 + e, 2);
}

/* ==============================
   CHART
================================ */
let tradeoffChart = null;
// Gauges for impact overview
let gaugeCo2 = null;
let gaugeWater = null;
let gaugeUhi = null;
let gaugeCost = null;
// Additional biodiversity gauge for habitat suitability proxy
let gaugeBio = null;

/**
 * Helper to create a semi-circular gauge using Chart.js. The gauge
 * renders a percentage of the circle based on the first value in
 * dataset.data and uses a simple plugin to draw the numeric value
 * and caption in the centre. A custom colour can be supplied.
 *
 * @param {string} canvasId   The id of the canvas element
 * @param {string} color      The primary colour of the gauge arc
 * @param {string} caption    The caption displayed beneath the value
 * @returns {Chart}           The created Chart.js instance
 */
function createGauge(canvasId, color, caption){
  const ctx = document.getElementById(canvasId).getContext('2d');
  return new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Value', 'Remainder'],
      datasets: [{
        data: [0, 100],
        backgroundColor: [color, 'rgba(255,255,255,0.08)'],
        hoverBackgroundColor: [color, 'rgba(255,255,255,0.08)'],
        borderWidth: 0,
        // values will be updated externally via updateAllGauges
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      rotation: -Math.PI,
      circumference: Math.PI,
      cutout: '70%',
      animation: {
        animateRotate: true,
        animateScale: false
      },
      plugins: {
        legend: { display: false },
        tooltip: { enabled: false }
      }
    },
    plugins: []
  });
}

/**
 * Updates all gauges with the latest net values. Each gauge uses a
 * predetermined maximum value for normalisation and displays both
 * the percentage of the maximum and the actual human-readable
 * measurement inside. Values exceeding the maximum are capped at
 * 100% on the gauge but the real value is still displayed.
 *
 * @param {number} netCo2   Net CO‚ÇÇ sequestration (kg/yr)
 * @param {number} netWater Net stormwater reduction (L/yr)
 * @param {number} netUhi   Net cooling effect (¬∞C)
 * @param {number} netCost  Net investment (‚Ç¨)
 */
function updateAllGauges(netCo2, netWater, netUhi, netCost){
  // Define max values for normalisation
  const maxCo2 = 600;      // kg/yr, approximate max sequestration
  const maxWater = 25000;  // L/yr, approximate max runoff reduction
  const maxUhi = 0.5;      // ¬∞C, approximate max cooling effect
  const maxCost = 20000;   // ‚Ç¨, approximate max investment

  // Helper to compute percentage and label
  const compute = (value, max, unit) => {
    const pct = Math.min(Math.abs(value) / max * 100, 100);
    // Format the displayed value with units and sign
    let display;
    if(unit === '¬∞C'){
      display = (value >= 0 ? '-' : '+') + Math.abs(value).toFixed(3) + unit;
    } else if(unit === 'kg/yr'){
      display = (value >= 0 ? '+' : '-') + Math.round(Math.abs(value)).toLocaleString() + ' kg';
    } else if(unit === 'L/yr'){
      display = (value >= 0 ? '-' : '+') + Math.round(Math.abs(value)).toLocaleString() + ' L';
    } else if(unit === '‚Ç¨'){
      display = (value >= 0 ? '‚Ç¨' : '-‚Ç¨') + Math.round(Math.abs(value)).toLocaleString();
    } else {
      display = Math.round(value).toString();
    }
    return { pct, display };
  };

  // CO‚ÇÇ gauge
  if(gaugeCo2){
    const { pct, display } = compute(netCo2, maxCo2, 'kg/yr');
    gaugeCo2.data.datasets[0].data[0] = pct;
    gaugeCo2.data.datasets[0].data[1] = 100 - pct;
    gaugeCo2.update();
    const el = document.getElementById('gaugeCo2Value');
    if(el) el.innerText = display;
  }
  // Water gauge
  if(gaugeWater){
    const { pct, display } = compute(netWater, maxWater, 'L/yr');
    gaugeWater.data.datasets[0].data[0] = pct;
    gaugeWater.data.datasets[0].data[1] = 100 - pct;
    gaugeWater.update();
    const el = document.getElementById('gaugeWaterValue');
    if(el) el.innerText = display;
  }
  // Cooling gauge (UHI)
  if(gaugeUhi){
    const { pct, display } = compute(netUhi, maxUhi, '¬∞C');
    gaugeUhi.data.datasets[0].data[0] = pct;
    gaugeUhi.data.datasets[0].data[1] = 100 - pct;
    gaugeUhi.update();
    const el = document.getElementById('gaugeUhiValue');
    if(el) el.innerText = display;
  }
  // Investment gauge
  if(gaugeCost){
    const { pct, display } = compute(netCost, maxCost, '‚Ç¨');
    gaugeCost.data.datasets[0].data[0] = pct;
    gaugeCost.data.datasets[0].data[1] = 100 - pct;
    gaugeCost.update();
    const el = document.getElementById('gaugeCostValue');
    if(el) el.innerText = display;
  }
}
try {
  const ctx = document.getElementById("tradeoffChart").getContext("2d");
  tradeoffChart = new Chart(ctx, {
    type: "radar",
    data: {
      labels: ["Cost", "CO‚ÇÇ", "Cooling", "Biodiversity"],
      datasets: [{
        label: "Scenario Impact",
        data: [0, 0, 0, 0],
        backgroundColor: "rgba(45, 212, 191, 0.2)",
        borderColor: "#2dd4bf",
        pointBackgroundColor: "#fff"
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: { r: { grid: { color: "rgba(255,255,255,0.1)" }, ticks: { display: false } } },
      plugins: { legend: { display: false } }
    }
  });
} catch(e) {
  console.warn("Chart init failed", e);
}

/* ==============================
   MODES
================================ */
let interactionMode = "idle"; // idle | plant | draw | facade
const popup = document.getElementById("ecoPopup");

/* ==============
   TREE UI
============== */
function selectSpecies(key, el){
  selectedSpecies = key;
  document.querySelectorAll(".species-grid")[0].querySelectorAll(".species-opt").forEach(d => d.classList.remove("selected"));
  el.classList.add("selected");

  const btn = document.getElementById("btnPlant");
  const spec = speciesData[key];
  if(interactionMode !== "plant"){
    btn.innerHTML = `<i class="fas fa-plus-circle"></i> Plant ${spec.name} (‚Ç¨${spec.cost})`;
  }
}
function togglePlanting(){
  const btn = document.getElementById("btnPlant");
  const spec = speciesData[selectedSpecies];

  if(interactionMode === "plant"){
    interactionMode = "idle";
    btn.classList.remove("planting");
    btn.innerHTML = `<i class="fas fa-plus-circle"></i> Plant ${spec.name} (‚Ç¨${spec.cost})`;
    viewer.canvas.style.cursor = "default";
    showToast("Planting mode OFF");
    return;
  }

  if(interactionMode === "facade") toggleFacading(true);
  cancelPolygonDraw(true);

  interactionMode = "plant";
  btn.classList.add("planting");
  btn.innerHTML = `<i class="fas fa-hand-holding-seedling"></i> Click map to plant ${spec.name}`;
  viewer.canvas.style.cursor = "crosshair";
  closePopup();
  showToast("Planting mode ON");
}

/* ==============
   FACADE UI
============== */
function selectFacadeType(key, el){
  selectedFacadeType = key;

  const grids = document.querySelectorAll(".species-grid");
  const facadeGrid = grids[1];
  facadeGrid.querySelectorAll(".species-opt").forEach(d => d.classList.remove("selected"));
  el.classList.add("selected");

  const btn = document.getElementById("btnFacade");
  const f = facadeTypes[key];
  if(interactionMode !== "facade"){
    btn.innerHTML = `<i class="fa-solid fa-square-plus"></i> Apply ${f.name} Facade (click a building)`;
  }
}

function toggleFacading(silent=false){
  const btn = document.getElementById("btnFacade");
  const f = facadeTypes[selectedFacadeType];

  if(interactionMode === "facade"){
    interactionMode = "idle";
    btn.classList.remove("facading");
    btn.innerHTML = `<i class="fa-solid fa-square-plus"></i> Apply ${f.name} Facade (click a building)`;
    viewer.canvas.style.cursor = "default";
    if(!silent) showToast("Facade mode OFF");
    return;
  }

  if(interactionMode === "plant") togglePlanting();
  cancelPolygonDraw(true);

  interactionMode = "facade";
  btn.classList.add("facading");
  btn.innerHTML = `<i class="fa-solid fa-square-check"></i> Click a building to add ${f.name} facade`;
  viewer.canvas.style.cursor = "crosshair";
  closePopup();
  if(!silent) showToast("Facade mode ON");
}

/* ==============================
   GREEN FACADE SQUARE PLACEMENT
================================ */
function enuSquareCorners(centerCartesian, sizeM, liftM){
  const half = sizeM / 2;
  const m = Cesium.Transforms.eastNorthUpToFixedFrame(centerCartesian);

  const cornersLocal = [
    new Cesium.Cartesian3(-half, -half, liftM),
    new Cesium.Cartesian3( half, -half, liftM),
    new Cesium.Cartesian3( half,  half, liftM),
    new Cesium.Cartesian3(-half,  half, liftM)
  ];

  return cornersLocal.map(v => {
    const out = new Cesium.Cartesian3();
    return Cesium.Matrix4.multiplyByPoint(m, v, out);
  });
}

/* Patch: prevent duplicates per BAG */
const facadeByBag = new Map();
function registerFacadeForBag(bag, entity){
  if(!bag || !entity) return;

  const old = facadeByBag.get(bag);
  if(old && old !== entity && viewer.entities.contains(old)){
    viewer.entities.remove(old);
  }
  facadeByBag.set(bag, entity);

  updateSim();
}

function addFacadeSquareAt(cartesian, meta){
  const f = facadeTypes[selectedFacadeType] || facadeTypes.ivy;
  const corners = enuSquareCorners(cartesian, 6.0, 0.35);

  const ent = viewer.entities.add({
    polygon: {
      hierarchy: corners,
      perPositionHeight: true,
      material: Cesium.Color.fromCssColorString(f.color).withAlpha(0.85),
      outline: true,
      outlineColor: Cesium.Color.WHITE.withAlpha(0.85)
    },
    label: {
      text: f.name,
      font: "10px Inter",
      pixelOffset: new Cesium.Cartesian2(0, -16),
      distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 700),
      disableDepthTestDistance: Number.POSITIVE_INFINITY,
      fillColor: Cesium.Color.WHITE,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 4
    }
  });

  ent._type = "facade_square";
  ent._data = { ...f };
  ent._meta = meta || { bag: "", bouwjaar: "", areaM2: null };

  if(ent._meta && ent._meta.bag) registerFacadeForBag(ent._meta.bag, ent);

  undoStack.push({ kind: "facade_add", entity: ent });

  updateSim();
  showToast(`${f.name} facade added`);
  return ent;
}

/* ==============================
   TREE REMOVAL IMPACT (kept)
================================ */
function applyTreeRemovalImpact(tree, direction){
  if(!tree || !tree._data) return;

  const d = tree._data;
  const height = d.height || 8;

  const canopy = height * 0.75;
  const lostCO2 = d.co2Stored || (12 * height);
  const lostWater = 450 + canopy * 30;
  const tempInc = canopy * 0.03;
  const moneyLoss = canopy * 8;

  impactLoss.co2 += direction * lostCO2;
  impactLoss.water += direction * lostWater;
  impactLoss.temp += direction * tempInc;
  impactLoss.money += direction * moneyLoss;
}

/* ==============================
   SCENARIO POLYGONS (smooth draw)
================================ */
let scenarioType = "grass";
let scenarioPolygons = [];
let scenarioIdSeq = 1;

const SCENARIO_PARAMS = {
  grass: { label:"Grass",  color:"rgba(34,197,94,0.35)", outline:"#22c55e", ndviBoost:0.08, coolPerHa:0.05, waterPerHa:12000, bioPerHa:0.06, costPerM2:6 },
  shrubs:{ label:"Shrubs", color:"rgba(16,185,129,0.35)", outline:"#10b981", ndviBoost:0.12, coolPerHa:0.08, waterPerHa:16000, bioPerHa:0.09, costPerM2:10 },
  trees: { label:"Trees",  color:"rgba(34,211,238,0.30)", outline:"#22d3ee", ndviBoost:0.18, coolPerHa:0.12, waterPerHa:22000, bioPerHa:0.12, costPerM2:18 },
  mixed: { label:"Mixed",  color:"rgba(245,158,11,0.28)", outline:"#f59e0b", ndviBoost:0.15, coolPerHa:0.10, waterPerHa:19000, bioPerHa:0.11, costPerM2:14 }
  ,
  /*
   * Additional intervention types beyond traditional planting.  These
   * approximate NDVI improvements, cooling effects, stormwater
   * infiltration and biodiversity benefits using available proxy data.
   */
  raingarden: {
    label: "Rain Garden",
    color: "rgba(59,130,246,0.35)",
    outline: "#3b82f6",
    ndviBoost: 0.10,
    coolPerHa: 0.08,
    waterPerHa: 30000,
    bioPerHa: 0.08,
    costPerM2: 20
  },
  greenroof: {
    label: "Green Roof",
    color: "rgba(34,197,94,0.25)",
    outline: "#22c55e",
    ndviBoost: 0.12,
    coolPerHa: 0.15,
    waterPerHa: 18000,
    bioPerHa: 0.09,
    costPerM2: 25
  },
  permeable: {
    label: "Permeable",
    color: "rgba(107,114,128,0.35)",
    outline: "#6b7280",
    ndviBoost: 0.05,
    coolPerHa: 0.04,
    waterPerHa: 26000,
    bioPerHa: 0.02,
    costPerM2: 12
  },
  shading: {
    label: "Shading",
    color: "rgba(250,204,21,0.30)",
    outline: "#facc15",
    ndviBoost: 0.00,
    coolPerHa: 0.20,
    waterPerHa: 5000,
    bioPerHa: 0.00,
    costPerM2: 15
  },
  removeimpervious: {
    label: "Remove Impervious",
    color: "rgba(236,72,153,0.30)",
    outline: "#ec4899",
    ndviBoost: 0.06,
    coolPerHa: 0.06,
    waterPerHa: 24000,
    bioPerHa: 0.05,
    costPerM2: 8
  }
};

function selectScenarioType(type, el){
  scenarioType = type;
  document.querySelectorAll(".sc-type").forEach(x => x.classList.remove("selected"));
  el.classList.add("selected");
}

let drawState = {
  active: false,
  positions: [],
  tempPos: null,
  polygonEntity: null,
  vertexEntities: [],
  usedFreehand: false,
  pencil: { active: false, lastAdd: 0, lastPos: null }
};

function startPolygonDraw(){
  if(interactionMode === "plant") togglePlanting();
  if(interactionMode === "facade") toggleFacading(true);

  interactionMode = "draw";
  drawState.active = true;
  drawState.positions = [];
  drawState.tempPos = null;
  drawState.usedFreehand = false;
  drawState.pencil.active = false;
  drawState.pencil.lastAdd = 0;
  drawState.pencil.lastPos = null;

  if(drawState.polygonEntity) viewer.entities.remove(drawState.polygonEntity);
  drawState.vertexEntities.forEach(v => viewer.entities.remove(v));
  drawState.vertexEntities = [];

  const p = SCENARIO_PARAMS[scenarioType];

  drawState.polygonEntity = viewer.entities.add({
    polygon: {
      hierarchy: new Cesium.CallbackProperty(() => {
        const pts = drawState.positions.slice();
        if(drawState.tempPos) pts.push(drawState.tempPos);
        if(pts.length < 3) return undefined;
        return new Cesium.PolygonHierarchy(pts);
      }, false),
      material: Cesium.Color.fromCssColorString(p.color),
      outline: true,
      outlineColor: Cesium.Color.fromCssColorString(p.outline),
      perPositionHeight: false,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      classificationType: Cesium.ClassificationType.BOTH
    }
  });
  drawState.polygonEntity._type = "draw_preview";

  showToast("Draw: click points. Right-click to finish. SHIFT+drag = smooth freehand.");
  closePopup();
  viewer.canvas.style.cursor = "crosshair";
}

function cancelPolygonDraw(silent=false){
  if(interactionMode !== "draw" && !drawState.active){
    if(!silent) showToast("Nothing to cancel");
    return;
  }
  drawState.active = false;
  if(interactionMode === "draw") interactionMode = "idle";
  viewer.canvas.style.cursor = "default";

  if(drawState.polygonEntity){
    viewer.entities.remove(drawState.polygonEntity);
    drawState.polygonEntity = null;
  }
  drawState.vertexEntities.forEach(v => viewer.entities.remove(v));
  drawState.vertexEntities = [];
  drawState.positions = [];
  drawState.tempPos = null;
  drawState.pencil.active = false;
  drawState.pencil.lastPos = null;
  drawState.usedFreehand = false;

  if(!silent) showToast("Drawing cancelled");
}

/* ---- Smooth helpers (Chaikin + simplification) ---- */
function perpendicularDistance(p, a, b){
  const x = p[0], y = p[1];
  const x1 = a[0], y1 = a[1];
  const x2 = b[0], y2 = b[1];
  const dx = x2 - x1, dy = y2 - y1;
  if(Math.abs(dx) < 1e-12 && Math.abs(dy) < 1e-12){
    const ux = x - x1, uy = y - y1;
    return Math.sqrt(ux*ux + uy*uy);
  }
  const t = ((x - x1)*dx + (y - y1)*dy) / (dx*dx + dy*dy);
  const tt = Math.max(0, Math.min(1, t));
  const px = x1 + tt*dx;
  const py = y1 + tt*dy;
  const ux = x - px, uy = y - py;
  return Math.sqrt(ux*ux + uy*uy);
}

function rdpSimplify(points, eps){
  if(points.length <= 3) return points.slice();
  const stack = [[0, points.length - 1]];
  const keep = new Array(points.length).fill(false);
  keep[0] = keep[points.length - 1] = true;

  while(stack.length){
    const [s, e] = stack.pop();
    let maxD = -1, idx = -1;
    for(let i = s + 1; i < e; i++){
      const d = perpendicularDistance(points[i], points[s], points[e]);
      if(d > maxD){ maxD = d; idx = i; }
    }
    if(maxD > eps && idx !== -1){
      keep[idx] = true;
      stack.push([s, idx], [idx, e]);
    }
  }

  const out = [];
  for(let i=0; i<points.length; i++){
    if(keep[i]) out.push(points[i]);
  }
  return out.length >= 3 ? out : points.slice(0,3);
}

function chaikinSmooth(points, iterations, closed=true){
  let pts = points.slice();
  if(pts.length < 3) return pts;

  for(let it=0; it<iterations; it++){
    const next = [];
    const n = pts.length;
    for(let i=0; i<n; i++){
      const p0 = pts[i];
      const p1 = pts[(i+1) % n];

      if(!closed && i === n-1) break;

      const q = [0.75*p0[0] + 0.25*p1[0], 0.75*p0[1] + 0.25*p1[1]];
      const r = [0.25*p0[0] + 0.75*p1[0], 0.25*p0[1] + 0.75*p1[1]];
      next.push(q, r);
    }

    pts = closed ? next : [pts[0], ...next, pts[n-1]];
    if(pts.length > 800) break;
  }
  return pts;
}

function refinePolygonPositions(cartesians, strong){
  if(!cartesians || cartesians.length < 3) return cartesians || [];

  const cleaned = [];
  for(const p of cartesians){
    if(!cleaned.length){ cleaned.push(p); continue; }
    if(Cesium.Cartesian3.distance(p, cleaned[cleaned.length-1]) > 0.8){
      cleaned.push(p);
    }
  }
  if(cleaned.length < 3) return cartesians.slice(0,3);

  const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);

  let ptsXY = cleaned.map(c3 => {
    const carto = Cesium.Cartographic.fromCartesian(c3);
    const p = proj.project(carto);
    return [p.x, p.y];
  });

  const eps1 = strong ? 2.2 : 1.4;
  ptsXY = rdpSimplify(ptsXY, eps1);

  const smoothIter = strong ? 2 : 1;
  ptsXY = chaikinSmooth(ptsXY, smoothIter, true);

  ptsXY = rdpSimplify(ptsXY, strong ? 1.2 : 0.9);

  if(ptsXY.length < 3) ptsXY = ptsXY.concat([ptsXY[ptsXY.length-1]]).slice(0,3);

  const hVals = cleaned.map(c3 => {
    const carto = Cesium.Cartographic.fromCartesian(c3);
    return Number.isFinite(carto.height) ? carto.height : 0;
  });
  const hAvg = hVals.length ? (hVals.reduce((a,b)=>a+b,0) / hVals.length) : 0;

  const out = ptsXY.map(([x,y]) => {
    const carto = proj.unproject(new Cesium.Cartesian2(x,y));
    return Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, hAvg);
  });

  return out.length >= 3 ? out : cleaned;
}

function finalizeScenarioPolygon(){
  if(drawState.positions.length < 3){
    showToast("Need at least 3 points");
    return;
  }

  let pts = drawState.positions.slice();

  const strong = drawState.usedFreehand || pts.length > 80;
  pts = refinePolygonPositions(pts, strong);

  const p = SCENARIO_PARAMS[scenarioType];

  const poly = viewer.entities.add({
    polygon: {
      hierarchy: new Cesium.PolygonHierarchy(pts),
      material: Cesium.Color.fromCssColorString(p.color),
      outline: true,
      outlineColor: Cesium.Color.fromCssColorString(p.outline),
      perPositionHeight: false,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      classificationType: Cesium.ClassificationType.BOTH
    }
  });

  if(drawState.polygonEntity){
    viewer.entities.remove(drawState.polygonEntity);
    drawState.polygonEntity = null;
  }
  drawState.vertexEntities.forEach(v => viewer.entities.remove(v));
  drawState.vertexEntities = [];

  const areaM2 = polygonAreaM2(pts);
  const centroidCarto = polygonCentroidCartographic(pts);

  const centroidLat = centroidCarto ? Cesium.Math.toDegrees(centroidCarto.latitude) : null;
  const centroidLon = centroidCarto ? Cesium.Math.toDegrees(centroidCarto.longitude) : null;

  let env = { ndvi:"0.15", uhi:"34.5¬∞C", uhiVal:34.5 };
  if(centroidLat !== null && centroidLon !== null){
    env = getPixelData(centroidLat, centroidLon);
  }

  const impacts = scenarioImpacts(scenarioType, areaM2, env, centroidCarto);

  poly._type = "scenario_poly";
  poly._data = impacts;
  poly._scenarioId = scenarioIdSeq;

  undoStack.push({ kind: "scenario_add", entity: poly });

  const rec = {
    id: scenarioIdSeq++,
    entity: poly,
    type: scenarioType,
    areaM2,
    impacts,
    centroidLatLon: (centroidLat !== null) ? {lat: centroidLat, lon: centroidLon} : null
  };
  scenarioPolygons.push(rec);

  drawState.active = false;
  interactionMode = "idle";
  viewer.canvas.style.cursor = "default";

  updateScenarioList();
  updateSim();
  showToast("Scenario applied");
}

function updateScenarioList(){
  const box = document.getElementById("scenarioList");
  box.innerHTML = "";

  if(scenarioPolygons.length === 0){
    box.innerHTML = `<div style="font-size:11px;color:rgba(226,232,240,0.62);margin-top:10px;">No scenario polygons yet.</div>`;
    return;
  }

  scenarioPolygons.forEach(s => {
    const p = SCENARIO_PARAMS[s.type];
    const div = document.createElement("div");
    div.className = "scenario-item";
    div.innerHTML = `
      <div>
        <strong>#${s.id} ${p.label}</strong>
        <small>
          ${formatArea(s.areaM2)}
          ¬∑ NDVI ${s.impacts.ndviBefore.toFixed(2)} ‚Üí ${s.impacts.ndviAfter.toFixed(2)}
          ¬∑ Cooling -${s.impacts.cooling.toFixed(3)}¬∞C
          ¬∑ Stormwater -${Math.round(s.impacts.waterDelta).toLocaleString()} L/yr
          ¬∑ Cost ‚Ç¨${Math.round(s.impacts.cost).toLocaleString()}
        </small>
      </div>
      <button title="Remove" onclick="removeScenario(${s.id}); event.stopPropagation();"><i class="fa-solid fa-trash"></i></button>
    `;
    div.onclick = () => {
      if(s.centroidLatLon){
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(s.centroidLatLon.lon, s.centroidLatLon.lat, 240),
          duration: 1.2
        });
      }
    };
    box.appendChild(div);
  });
}

function removeScenario(id){
  const idx = scenarioPolygons.findIndex(x => x.id === id);
  if(idx === -1) return;

  const s = scenarioPolygons[idx];
  if(s.entity) viewer.entities.remove(s.entity);
  scenarioPolygons.splice(idx, 1);

  updateScenarioList();
  updateSim();
  showToast("Scenario removed");
}

function scenarioImpacts(type, areaM2, env, centroidCarto){
  const prm = SCENARIO_PARAMS[type];
  const areaHa = areaM2 / 10000.0;

  const ndviBefore = clamp(parseFloat(env.ndvi), 0, 1);
  const ndviAfter = clamp(ndviBefore + prm.ndviBoost, 0, 1);

  const cooling = prm.coolPerHa * areaHa;
  const waterDelta = prm.waterPerHa * areaHa;
  const cost = prm.costPerM2 * areaM2;

  const corridorBonus = (centroidCarto && isNearCorridor(centroidCarto, 100)) ? 1 : 0;

  const bioBefore = habitatScore(ndviBefore, areaM2, corridorBonus);
  const bioAfter  = habitatScore(ndviAfter,  areaM2, corridorBonus);

  const bioDelta = Math.max(0, bioAfter - bioBefore) + (prm.bioPerHa * areaHa * 0.15);

  return { kind: "scenario_poly", type, areaM2, ndviBefore, ndviAfter, cooling, waterDelta, bioDelta, cost, corridorBonus };
}

function habitatScore(ndvi, areaM2, corridorBonus){
  const ndviNorm = clamp((ndvi - 0.05) / (0.65 - 0.05), 0, 1);
  const areaNorm = clamp(areaM2 / 20000.0, 0, 1);
  return 0.6*ndviNorm + 0.3*areaNorm + 0.1*corridorBonus;
}

function isNearCorridor(carto, thresholdM){
  if(!carto || !corridorPolylines.length) return false;
  const p = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
  let best = Infinity;

  for(const seg of corridorPolylines){
    for(const q of seg){
      const d = Cesium.Cartesian3.distance(p, q);
      if(d < best) best = d;
    }
  }
  return best <= thresholdM;
}

/* ==============================
   UPDATE SIM
================================ */
function updateSim(){
  let totalCost = 0, totalCO2 = 0, totalUHI = 0, totalBio = 1.20, totalWater = 0;
  let newTreeCount = 0, facadeCount = 0;

  const entities = viewer.entities.values;
  for(const e of entities){
    if(e._type === "tree_new" && e._data){
      newTreeCount++;
      totalCost += e._data.cost;

      const spec = speciesData[e._data.specKey] || speciesData.oak;
      const age = Math.max(1, currentYear - (e._data.plantedYear || 1) + 1);
      const annualCO2 = treeAnnualCO2(spec, age);

      totalCO2 += annualCO2;
      totalUHI += (e._data.uhi || 0) * clamp(age/20, 0.3, 1.0);
      totalBio += (e._data.bio || 0) * clamp(age/20, 0.3, 1.0);
      totalWater += (e._data.water || 0) * clamp(age/20, 0.3, 1.0);
    }
    else if(e._type === "facade_square" && e._data){
      facadeCount++;
      totalCost += e._data.cost;
      totalCO2 += e._data.co2;
      totalUHI += e._data.uhi;
      totalBio += e._data.bio;
      totalWater += e._data.water;
    }
    else if(e._type === "scenario_poly" && e._data){
      totalCost += e._data.cost;
      totalUHI  += e._data.cooling;
      totalBio  += e._data.bioDelta;
      totalWater += e._data.waterDelta;
    }
  }

  sim = { trees: newTreeCount, facades: facadeCount, cost: totalCost, co2: totalCO2, uhi: totalUHI, bio: totalBio, water: totalWater };

  const netCO2 = sim.co2 - impactLoss.co2;
  const netWater = sim.water - impactLoss.water;
  const netUHI = sim.uhi - impactLoss.temp;
  const netCost = sim.cost - impactLoss.money;

  document.getElementById("valTrees").innerText = sim.trees;
  document.getElementById("valFacades").innerText = sim.facades;

  // Values for impact overview are updated via gauges; the old
  // valCO2/valCost/valUHI/valWater elements have been removed.

  document.getElementById("valCutTemp").innerText = "+" + impactLoss.temp.toFixed(3) + "¬∞C";

  if(tradeoffChart){
    const maxCost = 20000, maxCO2 = 600, maxCool = 0.5, maxBio = 2.0;
    tradeoffChart.data.datasets[0].data = [
      Math.min((Math.abs(netCost) / maxCost) * 100, 100),
      Math.min((Math.abs(netCO2) / maxCO2) * 100, 100),
      Math.min((Math.abs(netUHI) / maxCool) * 100, 100),
      Math.min(((sim.bio - 1.2) / (maxBio - 1.2)) * 100, 100)
    ];
    tradeoffChart.update();
  }

  updateComparisonPanel();
}

function updateComparisonPanel(){
  const netCO2 = sim.co2 - impactLoss.co2;
  const netWater = sim.water - impactLoss.water;
  const netUHI = sim.uhi - impactLoss.temp;
  const netCost = sim.cost - impactLoss.money;

  const maxCo2 = 600, maxWater = 25000, maxCool = 0.5, maxCost = 20000;

  const pctCo2 = Math.min(Math.abs(netCO2) / maxCo2 * 100, 100);
  const pctWater = Math.min(Math.abs(netWater) / maxWater * 100, 100);
  const pctCool = Math.min(Math.abs(netUHI) / maxCool * 100, 100);
  const pctCost = Math.min(Math.abs(netCost) / maxCost * 100, 100);

  document.getElementById("cmpCo2Before").style.width = "0%";
  document.getElementById("cmpCo2After").style.width = pctCo2 + "%";
  document.getElementById("cmpCo2Text").innerText = `Baseline 0 ‚Üí ${Math.round(netCO2).toLocaleString()} kg/yr`;
  document.getElementById("cmpCo2Delta").innerText = (netCO2 >= 0)
    ? `Gain of ${Math.round(netCO2).toLocaleString()} kg CO‚ÇÇ/yr`
    : `Loss of ${Math.round(-netCO2).toLocaleString()} kg CO‚ÇÇ/yr`;

  document.getElementById("cmpUhiBefore").style.width = "0%";
  document.getElementById("cmpUhiAfter").style.width = pctCool + "%";
  const coolingDisplay = (netUHI >= 0 ? "-" : "+") + Math.abs(netUHI).toFixed(3) + "¬∞C";
  document.getElementById("cmpUhiText").innerText = `Baseline 0 ‚Üí ${coolingDisplay}`;
  document.getElementById("cmpUhiDelta").innerText = (netUHI >= 0)
    ? `Cooling of ${Math.abs(netUHI).toFixed(3)}¬∞C`
    : `Net warming of ${Math.abs(netUHI).toFixed(3)}¬∞C`;

  document.getElementById("cmpWaterBefore").style.width = "0%";
  document.getElementById("cmpWaterAfter").style.width = pctWater + "%";
  const waterDisplay = (netWater >= 0 ? "-" : "+") + Math.abs(Math.round(netWater)).toLocaleString() + " L/yr";
  document.getElementById("cmpWaterText").innerText = `Baseline 0 ‚Üí ${waterDisplay}`;
  document.getElementById("cmpWaterDelta").innerText = (netWater >= 0)
    ? `Reduced runoff by ${Math.round(netWater).toLocaleString()} L/yr`
    : `Extra ${Math.round(-netWater).toLocaleString()} L/yr runoff`;

  document.getElementById("cmpCostBefore").style.width = "0%";
  document.getElementById("cmpCostAfter").style.width = pctCost + "%";
  document.getElementById("cmpCostText").innerText = `Baseline ‚Ç¨0 ‚Üí ‚Ç¨${Math.round(netCost).toLocaleString()}`;
  document.getElementById("cmpCostDelta").innerText = (netCost >= 0)
    ? `Investment of ‚Ç¨${Math.round(netCost).toLocaleString()}`
    : `Asset loss of ‚Ç¨${Math.round(-netCost).toLocaleString()}`;

  // Update impact overview gauges with current net values
  updateAllGauges(netCO2, netWater, netUHI, netCost);

  // Also update the biodiversity gauge based on the change in habitat proxy.
  // The base biodiversity value is 1.20 (no interventions).  Any
  // interventions that increase habitat suitability add to sim.bio.  We
  // normalise the delta (sim.bio - 1.20) against an approximate maximum
  // delta of 1.0 to compute a percentage for the gauge.  Values below
  // zero (i.e., net biodiversity loss) are displayed as negative values.
  const netBio = sim.bio - 1.20;
  const maxBio = 1.0;
  const pctBio = Math.min(Math.abs(netBio) / maxBio * 100, 100);
  if (gaugeBio) {
    gaugeBio.data.datasets[0].data[0] = pctBio;
    gaugeBio.data.datasets[0].data[1] = 100 - pctBio;
    gaugeBio.update();
    const valEl = document.getElementById('gaugeBioValue');
    if (valEl) valEl.innerText = netBio.toFixed(2);
  }
}

function toggleCompare(){
  const body = document.getElementById("compareBody");
  body.style.display = (body.style.display === "none") ? "block" : "none";
}

/* ==============================
   GROWTH + SUN + SHADOWS
================================ */
function updateGrowth(year){
  currentYear = parseInt(year);
  document.getElementById("lblYear").innerText = "Year " + currentYear;

  for(const e of viewer.entities.values){
    if(e._type === "tree_new" && e.point){
      const baseSize = 5;
      e.point.pixelSize = new Cesium.ConstantProperty(baseSize * (0.6 + (currentYear/30)*0.6));
    }
  }
  updateSim();
}

function updateSun(val){
  const time = parseFloat(val);
  const hours = Math.floor(time);
  const mins = Math.floor((time - hours) * 60);

  document.getElementById("lblTime").innerText =
    `${String(hours).padStart(2,"0")}:${String(mins).padStart(2,"0")}`;

  const date = new Date();
  date.setMonth(5);
  date.setDate(21);
  date.setHours(hours);
  date.setMinutes(mins);
  date.setSeconds(0);

  viewer.clock.currentTime = Cesium.JulianDate.fromDate(date);
  viewer.scene.requestRender();
}

function toggleShadowsFromSlider(val){
  const on = String(val) === "1";
  document.getElementById("lblShadows").innerText = on ? "ON" : "OFF";

  viewer.shadowMap.enabled = on;
  viewer.shadows = on;
  viewer.scene.globe.enableLighting = on;

  if(lod22Tileset){
    lod22Tileset.shadows = on ? Cesium.ShadowMode.ENABLED : Cesium.ShadowMode.DISABLED;
  }
  viewer.scene.requestRender();
}

/* ==============================
   PDF REPORT + CHART
================================ */
function scenarioSummaryLines(){
  const lines = [];
  let totalArea = 0;
  scenarioPolygons.forEach(s => totalArea += s.areaM2);

  lines.push(`Scenario polygons: ${scenarioPolygons.length}`);
  if(scenarioPolygons.length > 0){
    lines.push(`Total scenario area: ${formatArea(totalArea)}`);
    scenarioPolygons.slice(0,8).forEach(s => {
      const p = SCENARIO_PARAMS[s.type];
      lines.push(`#${s.id} ${p.label} ¬∑ ${formatArea(s.areaM2)} ¬∑ NDVI ${s.impacts.ndviBefore.toFixed(2)}‚Üí${s.impacts.ndviAfter.toFixed(2)} ¬∑ Cool -${s.impacts.cooling.toFixed(3)}¬∞C ¬∑ Water -${Math.round(s.impacts.waterDelta)} L/yr ¬∑ ‚Ç¨${Math.round(s.impacts.cost)}`);
    });
    if(scenarioPolygons.length > 8) lines.push(`... +${scenarioPolygons.length - 8} more`);
  }
  return lines;
}

async function downloadReport(){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit: "mm", format: "a4" });

  let imgData = "";
  try{
    viewer.scene.requestRender();
    await new Promise(r => setTimeout(r, 250));
    imgData = viewer.canvas.toDataURL("image/png", 0.95);
  }catch(e){
    console.warn("Snapshot failed:", e);
  }

  let y = 10;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(14);
  doc.text("TWEKKELERVELD ECOLOGY DIGITAL TWIN ‚Äî REPORT", 10, y);
  y += 4;

  if(imgData){
    doc.addImage(imgData, "PNG", 10, y, 190, 90);
    y += 98;
  }else{
    y += 10;
  }

  const netCO2 = sim.co2 - impactLoss.co2;
  const netWater = sim.water - impactLoss.water;
  const netUHI = sim.uhi - impactLoss.temp;
  const netCost = sim.cost - impactLoss.money;

  const reportCooling = (netUHI >= 0 ? "-" : "+") + Math.abs(netUHI).toFixed(3);
  const reportWater  = (netWater >= 0 ? "-" : "+") + Math.abs(Math.round(netWater)).toLocaleString();

  doc.setFont("courier", "normal");
  doc.setFontSize(10);

  const lines = [
    `Date: ${new Date().toLocaleString()}`,
    `Simulated Timeframe: Year ${currentYear}`,
    "",
    "SCENARIO SUMMARY:",
    "-----------------",
    `New Trees Planted:      ${sim.trees}`,
    `Green Facades Added:    ${sim.facades}`,
    `Scenario Investment:    ‚Ç¨${Math.round(netCost).toLocaleString()}`,
    "",
    `CO‚ÇÇ Sequestration:      +${Math.round(netCO2).toLocaleString()} kg/year`,
    `Stormwater (runoff Œî):  ${reportWater} L/year (negative = less runoff)`,
    `Temperature (UHI Œî):    ${reportCooling} ¬∞C (negative = cooling)`,
    `Tree Removal Temp Cost: +${impactLoss.temp.toFixed(3)} ¬∞C`,
    "",
    "SCENARIO POLYGONS:",
    "-----------------",
    ...scenarioSummaryLines(),
    "",
    "Notes:",
    "- Map snapshot shows current layers + user edits (trees, polygons, facade squares).",
    "- CO‚ÇÇ for new trees uses a growth curve (annual sequestration peaks mid-age).",
    "- Biodiversity proxy uses NDVI + area + corridor proximity."
  ];

  const wrapped = doc.splitTextToSize(lines.join("\n"), 190);
  doc.text(wrapped, 10, y);

  doc.save("Eco_Simulation_Report.pdf");
}

function downloadCharts(){
  const link = document.createElement("a");
  link.download = "Tradeoff_Chart.png";
  link.href = document.getElementById("tradeoffChart").toDataURL();
  link.click();
}

/* ==============================
   EXPORT SCENARIO GEOJSON
================================ */
function exportScenarioGeoJSON(){
  const features = [];

  scenarioPolygons.forEach(s => {
    if(!s.entity || !s.entity.polygon) return;

    const t = viewer.clock.currentTime || Cesium.JulianDate.now();
    const positions = safePolygonPositions(s.entity.polygon, t);

    const coords = positions.map(c => {
      const carto = Cesium.Cartographic.fromCartesian(c);
      return [Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude)];
    });
    if(coords.length > 0) coords.push(coords[0]);

    features.push({
      type: "Feature",
      properties: {
        scenario_id: s.id,
        type: s.type,
        area_m2: s.areaM2,
        bio_delta: s.impacts.bioDelta,
        cooling_c: s.impacts.cooling,
        water_delta_l_yr: s.impacts.waterDelta,
        cost_eur: s.impacts.cost
      },
      geometry: { type: "Polygon", coordinates: [coords] }
    });
  });

  const gj = { type:"FeatureCollection", features };
  const blob = new Blob([JSON.stringify(gj, null, 2)], { type: "application/geo+json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "scenario_polygons.geojson";
  a.click();

  URL.revokeObjectURL(url);
  showToast("Scenario GeoJSON exported");
}

/* ==============================
   MCDA (priorities with more variance)
================================ */
let mcdaMarkers = [];
let recommendations = [];

function clearMCDA(){
  mcdaMarkers.forEach(m => viewer.entities.remove(m));
  mcdaMarkers = [];
  recommendations = [];

  const listEl = document.getElementById("recList");
  listEl.innerHTML = `<div class="rec-item"><div class="rec-title">No priorities yet</div><div class="rec-meta">Run the wizard to generate ranked buildings.</div></div>`;
  showToast('Priority markers cleared');
}

function normalizeYearOlderIsHigher(yearStr){
  const y = parseInt(String(yearStr || "").replace(/[^\d]/g, ""), 10);
  if(!Number.isFinite(y) || y < 1600 || y > NOW_YEAR) return 0.35;
  const age = NOW_YEAR - y;
  return clamp(age / 120, 0, 1);
}
function normalizeArea(areaM2){
  const a = Number(areaM2);
  if(!Number.isFinite(a) || a <= 0) return 0.25;
  return clamp(a / 500, 0, 1);
}

function runMCDA(){
  if(!lod1Ds){
    showToast('Building attributes not loaded yet');
    return;
  }

  const obj = document.getElementById('mcdaObjective').value;
  const corr = document.getElementById('mcdaCorridor').value;
  const budget = document.getElementById('mcdaBudget').value;
  const topN = clamp(parseInt(document.getElementById('mcdaTopN').value || '5'), 1, 15);

  let wU = 0.46, wN = 0.28, wC = 0.10, wA = 0.08, wR = 0.08;

  if(obj === 'cooling'){      wU = 0.55; wN = 0.20; wC = 0.10; wA = 0.05; wR = 0.10; }
  if(obj === 'biodiversity'){ wU = 0.32; wN = 0.42; wC = 0.14; wA = 0.06; wR = 0.06; }
  if(obj === 'stormwater'){   wU = 0.38; wN = 0.26; wC = 0.12; wA = 0.06; wR = 0.18; }
  if(obj === 'balanced'){     wU = 0.46; wN = 0.28; wC = 0.10; wA = 0.08; wR = 0.08; }

  if(corr === 'high'){ wC += 0.06; wU -= 0.03; wN -= 0.03; }

  const prefer = (budget === 'low') ? 'shrubs' : (budget === 'medium' ? 'mixed' : 'trees');

  const candidates = [];
  lod1Ds.entities.values.forEach(e => {
    if(e._type !== 'lod1_building' || !e._centroid) return;

    const env = e._env || getPixelData(e._centroid.lat, e._centroid.lon);
    const nd = parseFloat(env.ndvi);
    const uh = env.uhiVal || 0;

    const nearCorr = isNearCorridor(Cesium.Cartographic.fromDegrees(e._centroid.lon, e._centroid.lat), 120) ? 1 : 0;

    const uhiTerm = clamp((uh - 30) / 10, 0, 1);
    const ndviTerm = clamp((0.55 - nd) / 0.55, 0, 1);

    const ageTerm = normalizeYearOlderIsHigher(e._bouwjaar);
    const areaTerm = normalizeArea(e._areaM2);

    const score = (wU*uhiTerm) + (wN*ndviTerm) + (wC*nearCorr) + (wA*ageTerm) + (wR*areaTerm);

    if(score < 0.24) return;

    candidates.push({
      entity: e,
      lat: e._centroid.lat,
      lon: e._centroid.lon,
      env,
      nearCorr,
      score,
      suggestType: prefer
    });
  });

  candidates.sort((a,b) => b.score - a.score);

  const chosen = [];
  const minDistM = 90;

  for(const c of candidates){
    if(chosen.length >= topN) break;
    const cp = Cesium.Cartesian3.fromDegrees(c.lon, c.lat, 0);
    let ok = true;
    for(const s of chosen){
      const sp = Cesium.Cartesian3.fromDegrees(s.lon, s.lat, 0);
      if(Cesium.Cartesian3.distance(cp, sp) < minDistM){ ok = false; break; }
    }
    if(ok) chosen.push(c);
  }

  if(chosen.length < topN){
    for(const c of candidates){
      if(chosen.length >= topN) break;
      if(chosen.includes(c)) continue;
      chosen.push(c);
    }
  }

  recommendations = chosen;

  mcdaMarkers.forEach(m => viewer.entities.remove(m));
  mcdaMarkers = [];

  const t0 = Cesium.JulianDate.now();
  recommendations.forEach((r, idx) => {
    const marker = viewer.entities.add({
      position: new Cesium.ConstantPositionProperty(Cesium.Cartesian3.fromDegrees(r.lon, r.lat, 4)),
      point: {
        pixelSize: new Cesium.CallbackProperty((time) => {
          const dt = Math.max(0, Cesium.JulianDate.secondsDifference(time, t0));
          return 12 + 7*Math.abs(Math.sin(dt*2.1 + idx*0.9));
        }, false),
        color: Cesium.Color.fromCssColorString('#2dd4bf').withAlpha(0.9),
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 2,
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      },
      label: {
        text: `Priority ${idx+1}`,
        font: '11px Inter',
        pixelOffset: new Cesium.Cartesian2(0, -18),
        fillColor: Cesium.Color.WHITE,
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 4,
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 1200),
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      }
    });
    marker._type = 'mcda_marker';
    marker._idx = idx;
    marker._lod1 = r.entity;
    mcdaMarkers.push(marker);
  });

  const listEl = document.getElementById('recList');
  listEl.innerHTML = '';

  if(recommendations.length === 0){
    listEl.innerHTML = `<div class="rec-item"><div class="rec-title">No priorities detected</div><div class="rec-meta">Area already well vegetated.</div></div>`;
    showToast('No priorities found');
    return;
  }

  recommendations.forEach((rec, idx) => {
    const div = document.createElement('div');
    div.className = 'rec-item';
    div.innerHTML = `
      <div class="rec-title">Priority ${idx+1} ¬∑ Suggested: ${SCENARIO_PARAMS[rec.suggestType].label}</div>
      <div class="rec-meta">UHI: ${rec.env.uhi} ¬∑ NDVI: ${rec.env.ndvi} ¬∑ Corridor: ${rec.nearCorr ? 'near' : 'far'}</div>
      <div class="rec-meta">Score: ${(rec.score*100).toFixed(1)}/100</div>
      <div class="rec-meta" style="margin-top:6px;color:rgba(226,232,240,0.80);">Click to zoom</div>
    `;
    div.onclick = () => {
      viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(rec.lon, rec.lat, 250), duration: 1.2 });
      showToast(`Zoomed to Priority ${idx+1}`);
    };
    listEl.appendChild(div);
  });

  closeMCDA();
  showToast('Priorities updated');
}

/* ==============================
   UNDO (tree + facade + scenario)
================================ */
function undoRemoval(){
  while(undoStack.length > 0){
    const peek = undoStack[undoStack.length - 1];
    if(peek.entity && viewer.entities.contains(peek.entity)) break;
    if(peek.kind === "tree_hide" && peek.entity) break;
    undoStack.pop();
  }

  if(undoStack.length === 0){
    showToast("Nothing to undo");
    return;
  }

  const last = undoStack.pop();

  if(last.kind === "tree_hide" && last.entity){
    last.entity.show = true;
    last.entity._removed = false;
    last.entity._removing = false;
    applyTreeRemovalImpact(last.entity, -1);
    updateSim();
    showToast("Existing tree restored");
    closePopup();
    return;
  }

  if(last.kind === "plant"){
    if(last.entity && viewer.entities.contains(last.entity)){
      viewer.entities.remove(last.entity);
      updateSim();
      showToast("Last tree planting undone");
      closePopup();
      return;
    }
  }

  if(last.kind === "facade_add"){
    if(last.entity && viewer.entities.contains(last.entity)){
      viewer.entities.remove(last.entity);
      updateSim();
      showToast("Last facade undone");
      closePopup();
      return;
    }
  }

  if(last.kind === "scenario_add"){
    if(last.entity && viewer.entities.contains(last.entity)){
      viewer.entities.remove(last.entity);
      updateScenarioList();
      updateSim();
      showToast("Last scenario undone");
      closePopup();
      return;
    }
  }
}

/* ==============================
   POPUP + PICK HELPERS
================================ */
let isPinned = false;

function closePopup(){
  popup.style.display = "none";
  isPinned = false;
}

function row(lbl, val){
  return `<div class="pop-row"><span class="pop-label">${lbl}</span><span class="pop-val">${val}</span></div>`;
}

// Helper to generate a table of ALL properties
function generatePropertiesTable(properties, time) {
  if (!properties) return row("Info", "No data");
  
  // Get all property names
  const keys = properties.propertyNames;
  if (!keys || keys.length === 0) return row("Info", "No data");

  let html = '<table class="pop-table"><tbody>';
  keys.forEach(key => {
    // Skip internal Cesium props
    if (key.startsWith('_')) return;
    
    let val = safeGet(properties[key], time);
    if (val !== undefined && val !== null && val !== "") {
      // Basic formatting
      if (typeof val === 'number') val = Math.round(val * 100) / 100;
      html += `<tr><td class="k">${key}</td><td class="v">${val}</td></tr>`;
    }
  });
  html += '</tbody></table>';
  return html;
}

/* robust tileset surface pick */
async function pickTilesetSurfacePosition(windowPosition){
  if(viewer.scene.pickPositionSupported){
    const c = viewer.scene.pickPosition(windowPosition);
    if(c) return c;
  }

  const ray = viewer.camera.getPickRay(windowPosition);

  if(typeof viewer.scene.pickFromRayMostDetailed === "function"){
    try{
      const hit = await viewer.scene.pickFromRayMostDetailed(ray, [viewer.scene.globe]);
      if(hit && hit.position) return hit.position;
    }catch(_){}
  }

  if(typeof viewer.scene.pickFromRay === "function"){
    try{
      const hit2 = viewer.scene.pickFromRay(ray, [viewer.scene.globe]);
      if(hit2 && hit2.position) return hit2.position;
    }catch(_){}
  }

  return viewer.scene.globe.pick(ray, viewer.scene);
}

function pickGroundPosition(windowPosition){
  const ray = viewer.camera.getPickRay(windowPosition);
  const c = viewer.scene.globe.pick(ray, viewer.scene);
  if(c) return c;
  if(viewer.scene.pickPositionSupported) return viewer.scene.pickPosition(windowPosition);
  return null;
}

/* Patch: more reliable LOD2.2 pick detection */
function isTileFeature(p){
  if(!p) return false;

  if(typeof p.getProperty === "function" || typeof p.getPropertyIds === "function") return true;

  if(p.primitive && lod22Tileset && p.primitive === lod22Tileset) return true;

  if(p.primitive && lod22Tileset && p.primitive instanceof Cesium.Cesium3DTileset && p.primitive === lod22Tileset) return true;

  return false;
}

/* ==============================
   LOD2.2 -> HIDDEN LOD1 INFO (BAG + year + area ONLY)
================================ */
let _lod22ClickSeq = 0;

function buildHouseInfoFromBackend(lod1){
  const bag = lod1 ? (lod1._bag || "‚Äî") : "‚Äî";
  const by  = lod1 ? (lod1._bouwjaar || "‚Äî") : "‚Äî";
  const ar  = lod1 && Number.isFinite(Number(lod1._areaM2)) ? formatArea(Number(lod1._areaM2)) : "‚Äî";
  return row("BAG ID", bag) + row("Construction year", by) + row("Area", ar);
}

function showBuildingPopup(screenPos, lod1EntityOrNull){
  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;

  // Hide growth panel when clicking non‚Äëtree objects
  updateGrowthInfo(null);

  document.getElementById("popType").innerText = "Building";
  document.getElementById("popContent").innerHTML = buildHouseInfoFromBackend(lod1EntityOrNull);
}

function showLod22Popup(screenPos, lon, lat){
  const mySeq = ++_lod22ClickSeq;

  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;

  // Hide growth panel when clicking non‚Äëtree objects
  updateGrowthInfo(null);

  document.getElementById("popType").innerText = "Building";
  document.getElementById("popContent").innerHTML =
    row("BAG ID", "Loading‚Ä¶") + row("Construction year", "Loading‚Ä¶") + row("Area", "Loading‚Ä¶");

  lod1Ready.then(() => {
    if(mySeq !== _lod22ClickSeq) return;
    const lod1 = findLod1BuildingByLonLat(lon, lat);
    document.getElementById("popContent").innerHTML = buildHouseInfoFromBackend(lod1);
  });
}

/* ==============================
   TREE POPUP (HANDLES OPEN vs MUNI)
================================ */
function showTreePopup(screenPos, treeEntity){
  // Update assistant suggestions when a tree entity is selected
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('tree');
  }catch(e){}
  // Update assistant suggestions when a building is selected
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('building');
  }catch(e){}
  // Update assistant suggestions when selecting a building via LOD2.2
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('building');
  }catch(e){}
  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;
  const t = viewer.clock.currentTime || Cesium.JulianDate.now();

  // Handle Open or Municipal tree: display limited fields and update growth panel
  if(treeEntity._type === "tree_open" || treeEntity._type === "tree_muni"){
    // Extract species, height, crown, AGB, size class and CO‚ÇÇ
    const sp    = safePropString(treeEntity, TREE_KEYS.species, t) || "Tree";
    const hVal  = safePropNumber(treeEntity, TREE_KEYS.height, t);
    const crVal = safePropNumber(treeEntity, TREE_EXTRA_KEYS.crown, t);
    const agbVal= safePropNumber(treeEntity, TREE_EXTRA_KEYS.agb, t);
    const szVal = safePropString(treeEntity, TREE_EXTRA_KEYS.sizeClass, t);
    const co2Val= safePropNumber(treeEntity, TREE_KEYS.co2, t);

    const heightText = (hVal !== null && hVal !== undefined) ? (Number(hVal).toFixed(1) + " m") : "‚Äî";
    const crownText  = (crVal !== null && crVal !== undefined) ? (Number(crVal).toFixed(1) + " m¬≤") : "‚Äî";
    const agbText    = (agbVal !== null && agbVal !== undefined) ? (Math.round(agbVal).toLocaleString() + " kg") : "‚Äî";
    const sizeText   = (szVal && String(szVal).trim() !== "") ? szVal : "‚Äî";
    const co2Text    = (co2Val !== null && co2Val !== undefined) ? (Math.round(co2Val).toLocaleString() + " kg") : "‚Äî";

    document.getElementById("popType").innerText =
      (treeEntity._type === "tree_muni") ? "Tree (Municipality)" : "Tree (Open Data)";
    document.getElementById("popContent").innerHTML =
      row("Species", sp) +
      row("Height", heightText) +
      row("Crown", crownText) +
      row("AGB", agbText) +
      row("Size class", sizeText) +
      row("CO‚ÇÇ stored", co2Text);
    // Show growth projection only for municipal trees
    updateGrowthInfo(treeEntity._type === "tree_muni" ? treeEntity : null);
    return;
  }

  // Hide growth panel for other entity types
  updateGrowthInfo(null);

  // 3. NEWLY PLANTED TREE
  if(treeEntity._type === "tree_new"){
    const d = treeEntity._data || {};
    const spec = speciesData[d.specKey] || speciesData.oak;
    const age = Math.max(1, currentYear - (d.plantedYear || 1) + 1);
    const annual = treeAnnualCO2(spec, age);

    document.getElementById("popType").innerText = "New Tree";
    document.getElementById("popContent").innerHTML =
      row("Species", spec.name) +
      row("Planted (scenario year)", String(d.plantedYear || currentYear)) +
      row("Estimated annual CO‚ÇÇ", Math.round(annual).toLocaleString() + " kg/yr");
    return;
  }
}

/* Added: scenario polygon popup on click */
function showScenarioPopup(screenPos, polyEntity){
  // Update assistant suggestions when a scenario polygon is selected
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('scenario');
  }catch(e){}
  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;

  // Hide growth panel when clicking scenarios
  updateGrowthInfo(null);

  const d = polyEntity? (polyEntity._data || null) : null;
  if(!d){
    document.getElementById("popType").innerText = "Scenario";
    document.getElementById("popContent").innerHTML = row("Info","‚Äî");
    return;
  }

  const label = SCENARIO_PARAMS[d.type]?.label || d.type || "Scenario";
  const corridorTxt = d.corridorBonus ? "near corridor" : "not near corridor";

  document.getElementById("popType").innerText = "Scenario Polygon";
  document.getElementById("popContent").innerHTML =
    row("Type", label) +
    row("Area", formatArea(d.areaM2)) +
    row("NDVI", `${d.ndviBefore.toFixed(2)} ‚Üí ${d.ndviAfter.toFixed(2)}`) +
    row("Cooling", `-${d.cooling.toFixed(3)}¬∞C`) +
    row("Stormwater", `-${Math.round(d.waterDelta).toLocaleString()} L/yr`) +
    row("Cost", `‚Ç¨${Math.round(d.cost).toLocaleString()}`) +
    row("Connectivity", corridorTxt);
}

// Display a popup for a corridor entity showing its length and well‚Äëbeing score
function showCorridorPopup(screenPos, corridorEntity){
  // Update assistant suggestions when selecting a corridor
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('corridor');
  }catch(e){}
  // Position and show the popup
  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;
  // Hide growth panel when clicking corridors
  updateGrowthInfo(null);
  // Read stored properties
  const length = corridorEntity && corridorEntity._lengthMeters ? corridorEntity._lengthMeters : 0;
  const score  = corridorEntity && corridorEntity._wellBeingScore ? corridorEntity._wellBeingScore : 0;
  document.getElementById("popType").innerText = "Well‚Äëbeing Corridor";
  // Craft an explanatory sentence based on the well‚Äëbeing score.  Shorter, well‚Äëconnected corridors score higher and support both wildlife and human movement.
  let expl;
  if(score >= 70){
    expl = "High score: this corridor is short and well‚Äëconnected, making it easy for wildlife and pedestrians to move and enhancing well‚Äëbeing.";
  } else if(score >= 40){
    expl = "Moderate score: consider improving connectivity or reducing its length by adding green links to boost ecological and human benefits.";
  } else {
    expl = "Low score: this corridor is long or poorly connected. Creating new green spaces or linking existing ones can improve accessibility and ecological flow.";
  }
  document.getElementById("popContent").innerHTML =
    row("Length", Math.round(length).toLocaleString() + " m") +
    row("Well‚Äëbeing score", Math.round(score).toLocaleString() + " / 100") +
    `<div style="font-size:10px; margin-top:6px; color:rgba(226,232,240,0.80);">${expl}</div>`;
}

/* ==============================
   INPUT HANDLERS
================================ */
const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

handler.setInputAction(m => {
  if(popup.style.display === "block" && !isPinned){
    popup.style.left = (m.endPosition.x + 15) + "px";
    popup.style.top  = (m.endPosition.y + 15) + "px";
  }

  if(drawState.active && interactionMode === "draw"){
    const cartesian = pickGroundPosition(m.endPosition);
    if(cartesian){
      drawState.tempPos = cartesian;

      if(drawState.pencil.active){
        const now = performance.now();
        const last = drawState.pencil.lastPos || drawState.positions[drawState.positions.length-1] || null;
        const dist = last ? Cesium.Cartesian3.distance(cartesian, last) : 999;

        if(dist > 1.8 && (now - drawState.pencil.lastAdd > 28)){
          drawState.positions.push(cartesian);
          drawState.pencil.lastAdd = now;
          drawState.pencil.lastPos = cartesian;
          drawState.usedFreehand = true;
        }
      }
    }
  }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

handler.setInputAction(() => {
  if(interactionMode === 'draw' && drawState.active && window.__shiftDown){
    drawState.pencil.active = true;
    drawState.pencil.lastAdd = 0;
    drawState.pencil.lastPos = drawState.positions[drawState.positions.length-1] || null;
    drawState.usedFreehand = true;
  }
}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

handler.setInputAction(() => {
  if(interactionMode === 'draw' && drawState.active){
    drawState.pencil.active = false;
    drawState.pencil.lastPos = null;
  }
}, Cesium.ScreenSpaceEventType.LEFT_UP);

/* LEFT CLICK */
handler.setInputAction(async (click) => {
  const pos2D = click.position;

  // DRAW mode: add points
  if(interactionMode === "draw" && drawState.active && !drawState.pencil.active){
    const cart = pickGroundPosition(pos2D);
    if(cart){
      drawState.positions.push(cart);
      showToast(`Point ${drawState.positions.length} added`);
    }
    return;
  }

  // PLANT mode
  if(interactionMode === "plant"){
    const cart = pickGroundPosition(pos2D);
    if(cart){
      const spec = speciesData[selectedSpecies];

      const tree = viewer.entities.add({
        position: new Cesium.ConstantPositionProperty(cart),
        point: {
          pixelSize: 5,
          color: Cesium.Color.fromCssColorString(spec.color),
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 2,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        },
        label: {
          text: "New " + spec.name,
          font: "10px Inter",
          pixelOffset: new Cesium.Cartesian2(0, -12),
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 500),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
      });
      tree._type = "tree_new";
      tree._data = {
        specKey: selectedSpecies,
        name: spec.name,
        cost: spec.cost,
        uhi: spec.uhi,
        bio: spec.bio,
        water: spec.water,
        plantedYear: currentYear
      };

      undoStack.push({ kind: "plant", entity: tree });

      const annual = treeAnnualCO2(spec, 1);
      updateSim();
      showToast(`${spec.name} planted (Year1 ‚âà ${Math.round(annual)} kg CO‚ÇÇ/yr)`);
    }
    return;
  }

  const picks = viewer.scene.drillPick(pos2D, 16) || [];

  // click trees (Both Open and Muni are handled here)
  const entPick = picks.find(p => p && p.id && (
    p.id._type === "tree_open" || 
    p.id._type === "tree_muni" || 
    p.id._type === "tree_new"
  ));
  if(entPick && entPick.id){
    showTreePopup(pos2D, entPick.id);
    return;
  }

  // click scenario polygon
  const scPick = picks.find(p => p && p.id && p.id._type === "scenario_poly");
  if(scPick && scPick.id){
    showScenarioPopup(pos2D, scPick.id);
    return;
  }

  // click MCDA marker -> show BAG + year + area
  const mcdaPick = picks.find(p => p && p.id && p.id._type === 'mcda_marker');
  if(mcdaPick && mcdaPick.id && mcdaPick.id._lod1){
    showBuildingPopup(pos2D, mcdaPick.id._lod1);
    return;
  }

  // click corridor -> show well‚Äëbeing corridor popup
  const corPick = picks.find(p => p && p.id && p.id._type === 'corridor');
  if(corPick && corPick.id){
    showCorridorPopup(pos2D, corPick.id);
    return;
  }

  // FACADE mode: click on LOD 2.2 building (robust + BAG dedupe)
  if(interactionMode === "facade"){
    const tileFeature = lod22Tileset ? picks.find(p => isTileFeature(p)) : null;
    if(!tileFeature){
      showToast("Click a building (LOD 2.2)");
      return;
    }

    const cart = await pickTilesetSurfacePosition(pos2D);
    if(!cart){
      showToast("Could not place facade here");
      return;
    }

    const c = Cesium.Cartographic.fromCartesian(cart);
    const lon = Cesium.Math.toDegrees(c.longitude);
    const lat = Cesium.Math.toDegrees(c.latitude);

    showLod22Popup(pos2D, lon, lat);

    const facadeEnt = addFacadeSquareAt(cart, { bag: "", bouwjaar: "", areaM2: null });

    lod1Ready.then(() => {
      const lod1 = findLod1BuildingByLonLat(lon, lat);

      const bag = lod1 ? (lod1._bag || "") : "";
      const bouwjaar = lod1 ? (lod1._bouwjaar || "") : "";
      const areaM2 = lod1 ? (lod1._areaM2 || null) : null;

      if(facadeEnt && facadeEnt._type === "facade_square"){
        facadeEnt._meta = { bag, bouwjaar, areaM2 };

        if(bag) registerFacadeForBag(bag, facadeEnt);
      }
    });

    return;
  }

  // normal click: LOD2.2 -> show BAG + year + area
  const tileFeature = lod22Tileset ? picks.find(p => isTileFeature(p)) : null;
  if(tileFeature){
    const cart = await pickTilesetSurfacePosition(pos2D);
    if(cart){
      const c = Cesium.Cartographic.fromCartesian(cart);
      const lon = Cesium.Math.toDegrees(c.longitude);
      const lat = Cesium.Math.toDegrees(c.latitude);
      showLod22Popup(pos2D, lon, lat);
      return;
    }
  }

  // fallback surface scan
  const cart = pickGroundPosition(pos2D);
  if(cart){
    popup.style.left = (pos2D.x + 15) + "px";
    popup.style.top  = (pos2D.y + 15) + "px";
    popup.style.display = "block";
    isPinned = false;

    const cc = Cesium.Cartographic.fromCartesian(cart);
    const env = getPixelData(Cesium.Math.toDegrees(cc.latitude), Cesium.Math.toDegrees(cc.longitude));

    document.getElementById("popType").innerText = "Surface Scan";
    document.getElementById("popContent").innerHTML =
      row("Surface Temp (UHI)", env.uhi) +
      row("NDVI", env.ndvi);
  }else{
    closePopup();
  }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);

/* RIGHT CLICK: finish polygon in draw mode */
handler.setInputAction(() => {
  if(interactionMode === "draw" && drawState.active){
    finalizeScenarioPolygon();
    return;
  }
}, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

viewer.camera.moveStart.addEventListener(() => closePopup());

window.__shiftDown = false;
window.addEventListener("keydown", (e) => {
  if(e.key === 'Shift') window.__shiftDown = true;
  if(e.key === "Escape"){
    cancelPolygonDraw(true);
    if(interactionMode === "plant") togglePlanting();
    if(interactionMode === "facade") toggleFacading(true);
    showToast("Interaction cancelled");
  }
});
window.addEventListener("keyup", (e) => {
  if(e.key === 'Shift') window.__shiftDown = false;
});

/* ==============================
   UTILITIES
================================ */
function showToast(msg){
  const t = document.getElementById("toast");
  t.innerText = msg;
  t.style.opacity = 1;
  t.style.top = "100px";
  setTimeout(() => {
    t.style.opacity = 0;
    t.style.top = "90px";
  }, 1800);
}

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function polygonCentroidCartographic(positions){
  try{
    if(!positions || positions.length < 3) return null;
    let lon = 0, lat = 0;
    positions.forEach(p => {
      const c = Cesium.Cartographic.fromCartesian(p);
      lon += c.longitude;
      lat += c.latitude;
    });
    lon /= positions.length;
    lat /= positions.length;
    return new Cesium.Cartographic(lon, lat);
  }catch(_){ return null; }
}

function polygonCentroidCartesian(positions){
  const c = polygonCentroidCartographic(positions);
  if(!c) return null;
  return Cesium.Cartesian3.fromRadians(c.longitude, c.latitude, 0);
}

function polygonAreaM2(positions){
  try{
    if(!positions || positions.length < 3) return 0;
    const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);
    const pts = positions.map(p => proj.project(Cesium.Cartographic.fromCartesian(p)));

    let area = 0;
    for(let i=0; i<pts.length; i++){
      const j = (i+1) % pts.length;
      area += (pts[i].x * pts[j].y) - (pts[j].x * pts[i].y);
    }
    return Math.abs(area) / 2.0;
  }catch(_){ return 0; }
}

function formatArea(m2){
  if(!Number.isFinite(Number(m2))) return "‚Äî";
  m2 = Number(m2);
  if(m2 >= 10000) return (m2/10000).toFixed(2) + " ha";
  return Math.round(m2).toLocaleString() + " m¬≤";
}

/* ==============================
   INIT
================================ */
function initDefaults(){
  document.getElementById("sw-trees_open").classList.add("active");
  document.getElementById("sw-trees_muni").classList.add("active");
  document.getElementById("sw-greenery").classList.add("active");
  document.getElementById("sw-buildings3d").classList.add("active");

  document.getElementById("sw-corridors").classList.remove("active");
  document.getElementById("sw-heatmap").classList.remove("active");

  updateLegend();
  updateScenarioList();
  updateSim();
  updateSun(document.getElementById("sliderTime").value);
  toggleShadowsFromSlider(document.getElementById("shadowToggle").value);

  const spec = speciesData[selectedSpecies];
  document.getElementById("btnPlant").innerHTML = `<i class="fas fa-plus-circle"></i> Plant ${spec.name} (‚Ç¨${spec.cost})`;

  const f = facadeTypes[selectedFacadeType];
  document.getElementById("btnFacade").innerHTML = `<i class="fa-solid fa-square-plus"></i> Apply ${f.name} Facade (click a building)`;

  // Initialise impact overview gauges once DOM elements are ready
  gaugeCo2 = createGauge('gaugeCo2', getComputedStyle(document.documentElement).getPropertyValue('--blue') || '#60a5fa', 'CO‚ÇÇ');
  gaugeWater = createGauge('gaugeWater', getComputedStyle(document.documentElement).getPropertyValue('--gold') || '#fbbf24', 'Water');
  gaugeUhi = createGauge('gaugeUhi', getComputedStyle(document.documentElement).getPropertyValue('--danger') || '#fb7185', 'Cooling');
  gaugeCost = createGauge('gaugeCost', getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#2dd4bf', 'Investment');

  // Initialise biodiversity gauge using the purple accent colour.  This gauge
  // reflects the net change in the habitat suitability proxy (biodiversity).
  gaugeBio = createGauge('gaugeBio', getComputedStyle(document.documentElement).getPropertyValue('--purple') || '#c084fc', 'Biodiversity');

  // Kick off with initial zero values on the gauges
  updateAllGauges(0, 0, 0, 0);
}
initDefaults();

/* ==============================
   Wikipedia + Budget Planner helpers
   - Wikipedia summaries are fetched client‚Äëside (CORS supported).
   - Budget planner proposes portfolios based on trade‚Äëoffs.
================================ */

const __wikiCache = new Map();
async function fetchWikiSummary(title){
  const key = String(title || "").trim();
  if(!key) return null;
  if(__wikiCache.has(key)) return __wikiCache.get(key);
  const url = "https://en.wikipedia.org/api/rest_v1/page/summary/" + encodeURIComponent(key);
  try{
    const resp = await fetch(url, { mode: "cors" });
    if(!resp.ok) throw new Error("wiki summary failed");
    const data = await resp.json();
    const out = {
      title: data.title || key,
      extract: data.extract || "",
      page: (data.content_urls && data.content_urls.desktop && data.content_urls.desktop.page) ? data.content_urls.desktop.page : ""
    };
    __wikiCache.set(key, out);
    return out;
  }catch(e){
    __wikiCache.set(key, null);
    return null;
  }
}

async function wikiOpenSearch(query){
  const q = String(query || "").trim();
  if(!q) return null;
  // Try multiple languages (Dutch, German, English) to broaden lookup for unknown terms
  const langs = ['nl','de','en'];
  for(const lang of langs){
    const url = `https://${lang}.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(q)}&limit=1&namespace=0&format=json&origin=*`;
    try{
      const resp = await fetch(url);
      const data = await resp.json();
      const title = (data && data[1] && data[1][0]) ? data[1][0] : null;
      if(title) return title;
    }catch(e){
      // ignore and try next language
    }
  }
  return null;
}

// Attach wiki snippets to Layer Info modal
async function appendWikiToLayerInfo(layerKey, bodyEl){
  if(!bodyEl) return;

  const map = {
    trees_open: ["Urban forestry", "Tree inventory"],
    trees_muni: ["Urban forestry"],
    greenery: ["Urban green space"],
    corridors: ["Wildlife corridor", "Ecological connectivity"],
    heatmap: ["Urban heat island"],
    buildings3d: ["3D city model"]
  };
  const titles = map[layerKey] || [];
  if(!titles.length) return;

  const s = await fetchWikiSummary(titles[0]);
  if(!s || !s.extract) return;

  const excerpt = s.extract.length > 520 ? (s.extract.slice(0, 520) + "‚Ä¶") : s.extract;

  bodyEl.insertAdjacentHTML("beforeend", `
    <div style="margin-top:14px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.08);">
      <div style="font-weight:900;color:rgba(45,212,191,0.95);text-transform:uppercase;letter-spacing:1px;font-size:10px;margin-bottom:6px;">
        Wikipedia context
      </div>
      <div style="color:rgba(226,232,240,0.84);font-size:12px;line-height:1.6;">
        ${excerpt}
      </div>
      ${s.page ? `<div style="margin-top:8px;"><a href="${s.page}" target="_blank" rel="noopener">Open Wikipedia: ${s.title}</a></div>` : ``}
    </div>
  `);
}

// ------- Budget planner -------

function __objectiveWeights(key){
  const k = String(key || "balanced").toLowerCase();
  if(k === "cooling")      return { co2:0.15, cool:0.45, bio:0.20, water:0.20 };
  if(k === "carbon")       return { co2:0.55, cool:0.20, bio:0.10, water:0.15 };
  if(k === "biodiversity") return { co2:0.10, cool:0.20, bio:0.55, water:0.15 };
  if(k === "stormwater")   return { co2:0.10, cool:0.20, bio:0.20, water:0.50 };
  return { co2:0.25, cool:0.25, bio:0.25, water:0.25 }; // balanced
}

function __normalize(v, max){ return max <= 0 ? 0 : clamp(v / max, 0, 1); }

function __makeInterventionCatalog(){
  const ageForTree = Math.max(5, Math.min(12, currentYear || 5));
  const items = [];

  // Trees (repeatable)
  for(const [k, spec] of Object.entries(speciesData || {})){
    const co2 = treeAnnualCO2(spec, ageForTree);
    items.push({
      id: "tree:" + k,
      label: `${spec.name} tree`,
      cost: spec.cost,
      co2, cool: spec.uhi || 0, bio: spec.bio || 0, water: spec.water || 0,
      notes: "Long‚Äëterm benefits; needs planting space"
    });
  }

  // Facades (repeatable but usually 0..few)
  for(const [k, f] of Object.entries(facadeTypes || {})){
    items.push({
      id: "facade:" + k,
      label: `${f.name} facade`,
      cost: f.cost,
      co2: f.co2 || 0, cool: f.uhi || 0, bio: f.bio || 0, water: f.water || 0,
      notes: "Strong cooling/biodiversity on walls; higher upfront cost"
    });
  }

  // Scenario polygons (10 m¬≤ blocks; repeatable)
  const blockM2 = 10;
  for(const [k, p] of Object.entries(SCENARIO_PARAMS || {})){
    items.push({
      id: "poly:" + k,
      label: `${p.label} planting (‚âà${blockM2} m¬≤)`,
      cost: blockM2 * (p.costPerM2 || 0),
      co2: 0,
      cool: (p.coolPerHa || 0) / 10000 * blockM2,
      bio: (p.bioPerHa || 0) / 10000 * blockM2,
      water: (p.waterPerHa || 0) / 10000 * blockM2,
      notes: "Needs available space; good for stormwater + habitat"
    });
  }

  return items.filter(x => Number.isFinite(x.cost) && x.cost > 0);
}

function planForBudget(budgetEur, objectiveKey){
  const budget = Math.max(0, Number(budgetEur) || 0);
  const W = __objectiveWeights(objectiveKey);
  const items = __makeInterventionCatalog();

  // Maxima for normalisation (rough, from item catalog)
  const maxCo2 = Math.max(...items.map(i => i.co2 || 0), 1);
  const maxCool = Math.max(...items.map(i => i.cool || 0), 1e-6);
  const maxBio = Math.max(...items.map(i => i.bio || 0), 1e-6);
  const maxWater = Math.max(...items.map(i => i.water || 0), 1);

  function scoreItem(i){
    const s =
      W.co2   * __normalize(i.co2 || 0, maxCo2) +
      W.cool  * __normalize(i.cool || 0, maxCool) +
      W.bio   * __normalize(i.bio || 0, maxBio) +
      W.water * __normalize(i.water || 0, maxWater);
    return s;
  }

  // Greedy by "score per euro", with a small penalty for very expensive single items
  const scored = items.map(i => {
    const s = scoreItem(i);
    const per = s / Math.max(i.cost, 1);
    const penalty = i.cost > 3000 ? 0.85 : 1.0;
    return { ...i, _score: s, _per: per * penalty };
  }).sort((a,b) => b._per - a._per);

  let remaining = budget;
  const picks = [];
  const cap = 250; // safety loop
  let steps = 0;

  while(steps++ < cap){
    const next = scored.find(i => i.cost <= remaining);
    if(!next) break;
    picks.push(next);
    remaining -= next.cost;
    if(remaining < Math.min(...scored.map(i => i.cost))) break;
  }

  const totals = picks.reduce((acc, i) => {
    acc.cost += i.cost;
    acc.co2 += i.co2 || 0;
    acc.cool += i.cool || 0;
    acc.bio += i.bio || 0;
    acc.water += i.water || 0;
    return acc;
  }, { cost:0, co2:0, cool:0, bio:0, water:0 });

  // Summarise counts
  const counts = {};
  picks.forEach(p => counts[p.id] = (counts[p.id] || 0) + 1);

  return { budget, remaining, objectiveKey, counts, totals };
}

function formatPlanText(plan){
  const lines = [];
  lines.push(`Budget: ‚Ç¨${Math.round(plan.budget).toLocaleString()} ¬∑ Objective: ${plan.objectiveKey}`);
  const entries = Object.entries(plan.counts);
  if(entries.length === 0){
    lines.push("No actions fit this budget (try increasing budget or choose cheaper actions).");
    return lines.join("\n");
  }

  lines.push("Suggested portfolio:");
  entries.forEach(([id, n]) => {
    if(id.startsWith("tree:")){
      const k = id.split(":")[1];
      const s = speciesData[k];
      lines.push(`- ${n}√ó ${s.name} tree (‚Ç¨${s.cost} each)`);
    }else if(id.startsWith("facade:")){
      const k = id.split(":")[1];
      const f = facadeTypes[k];
      lines.push(`- ${n}√ó ${f.name} facade (‚Ç¨${Math.round(f.cost).toLocaleString()} each)`);
    }else if(id.startsWith("poly:")){
      const k = id.split(":")[1];
      const p = SCENARIO_PARAMS[k];
      lines.push(`- ${n}√ó ${p.label} polygon blocks (‚âà10 m¬≤ each, ‚Ç¨${p.costPerM2}/m¬≤)`);
    }
  });

  lines.push("");
  lines.push("Trade‚Äëoffs (model‚Äëbased):");
  lines.push(`‚Ä¢ CO‚ÇÇ: +${Math.round(plan.totals.co2).toLocaleString()} kg/yr`);
  lines.push(`‚Ä¢ Cooling: -${Math.abs(plan.totals.cool).toFixed(3)} ¬∞C`);
  lines.push(`‚Ä¢ Biodiversity proxy: +${plan.totals.bio.toFixed(3)}`);
  lines.push(`‚Ä¢ Stormwater: -${Math.round(plan.totals.water).toLocaleString()} L/yr`);
  lines.push(`Remaining (buffer): ‚Ç¨${Math.round(plan.remaining).toLocaleString()}`);

  lines.push("");
  lines.push("How to apply in the twin:");
  lines.push("1) Use 'Plant Selected Tree' to place the trees.");
  lines.push("2) If facades are included: turn on facade mode and click buildings.");
  lines.push("3) For polygons: use 'Start Draw' and draw the suggested vegetation type.");

  return lines.join("\n");
}

function runBudgetPlanner(){
  const b = document.getElementById("budgetInput");
  const o = document.getElementById("budgetObjective");
  const out = document.getElementById("budgetResults");
  const budget = b ? Number(b.value || 0) : 0;
  const obj = o ? o.value : "balanced";
  const plan = planForBudget(budget, obj);

  if(out){
    out.textContent = formatPlanText(plan);
    out.style.whiteSpace = "pre-line";
  }
  showToast("Budget plan ready");
}
function clearBudgetPlanner(){
  const out = document.getElementById("budgetResults");
  if(out) out.textContent = "";
}


/* ==============================
   ECOLOGY ASSISTANT
  ============================== */
(function(){
  const defaultChips = [
    { label: 'Explain NDVI', command: 'explain ndvi' },
    { label: 'Explain UHI', command: 'explain uhi' },
    { label: 'Run MCDA', command: 'run mcda' },
    { label: 'Start Draw', command: 'start drawing trees' },
    { label: 'Toggle Heatmap', command: 'turn on heatmap' },
    { label: 'Download Report', command: 'download report' },
    // custom chips for tree statistics and predictions
    { label: 'Tree Summary', command: 'tree summary' },
    { label: 'Future Prediction', command: 'future prediction' }
  ];

  /* --------------------------------------------------------------------
     Ecological dictionary and predictive suggestion data
     Provides definitions, related concepts and suggestion prompts for
     key ecological terms used in the digital twin.  These entries
     enable instant definitions and contextual assistance when users
     type or ask about ecology keywords.
  -------------------------------------------------------------------- */
  const ecoDictionary = {
    'ndvi': {
      definition: 'NDVI (Normalised Difference Vegetation Index) compares near‚Äëinfrared and red reflectance to assess vegetation health. Values range from -1 to +1, with higher values indicating healthier or denser vegetation.',
      related: ['vegetation health','remote sensing','photosynthesis'],
      suggestions: ['How does NDVI relate to cooling impact?','Explain UHI','How does NDVI relate to green corridors?','NDVI vs LAI']
    },
    'uhi': {
      definition: 'Urban Heat Island (UHI) refers to pockets of higher temperature within cities caused by heat‚Äëabsorbing materials, reduced vegetation and anthropogenic heat. UHI maps visualise relative surface temperatures.',
      related: ['heat stress','temperature','cooling strategies'],
      suggestions: ['How to reduce UHI?','Impact of green roofs on UHI','Why is this area hot?','How does UHI affect human comfort?']
    },
    'biodiversity': {
      definition: 'Biodiversity describes the variety of life in an ecosystem, encompassing species richness, genetic diversity and ecosystem variety. High biodiversity contributes to ecological resilience and health.',
      related: ['ecosystem services','species richness','habitats'],
      suggestions: ['How to improve biodiversity?','Effect of well‚Äëbeing corridors on biodiversity','Biodiversity in urban environments','What are biodiversity benefits?']
    },
    'green corridor': {
      definition: 'Well‚Äëbeing corridors (sometimes called green corridors) are continuous strips of natural vegetation connecting isolated green spaces. They enable wildlife movement, ecological connectivity and provide walkable routes for people, helping to preserve biodiversity and improve human well-being.',
      related: ['ecological connectivity','wildlife movement','habitat fragmentation','well-being'],
      suggestions: ['Benefits of well‚Äëbeing corridors?','How to design corridors','Impact of corridors on species and people','How do corridors enhance biodiversity benefit?']
    },
    'scenario polygon': {
      definition: 'A scenario polygon is a user‚Äëdrawn shape representing planned vegetation interventions such as grass, shrubs, trees or mixed planting. Each type affects NDVI, cooling, stormwater infiltration and biodiversity.',
      related: ['urban planning','vegetation types','ecology scenarios'],
      suggestions: ['How to draw scenario polygons?','Impact of shrubs vs trees','Draw mixed vegetation area']
    },
    'mcda': {
      definition: 'Multi‚ÄëCriteria Decision Analysis (MCDA) is a decision‚Äësupport technique that ranks options based on multiple weighted criteria. Here it prioritises buildings using UHI, NDVI, corridor proximity, age and footprint.',
      related: ['decision support','ranking','priority'],
      suggestions: ['Run MCDA','Explain MCDA parameters','How to adjust MCDA weights?']
    },
    'ecosystem services': {
      definition: 'Ecosystem services are the benefits that natural ecosystems provide, including provisioning (food, water), regulating (climate regulation, flood control), supporting (nutrient cycling, soil formation) and cultural (recreation).',
      related: ['natural capital','ecosystem benefits','ecosystem value'],
      suggestions: ['List ecosystem services provided by urban trees','How do green roofs contribute to ecosystem services?','What are regulating services?','How do ecosystem services relate to human comfort?']
    },
    'stormwater': {
      definition: 'Stormwater refers to runoff generated from precipitation events. In urban areas, impervious surfaces create excessive runoff leading to flooding and pollution. Vegetation and green infrastructure mitigate stormwater.',
      related: ['runoff','infiltration','flooding'],
      suggestions: ['How do trees reduce stormwater?','Stormwater management strategies','What is infiltration rate?','What is water management?']
    },
    'heat island': {
      definition: 'Heat islands are urban areas that experience higher temperatures than surrounding rural areas due to human activities, reduced vegetation and heat‚Äëabsorbing surfaces. They are addressed through cooling strategies and increased greenery.',
      related: ['UHI','temperature','cooling strategies'],
      suggestions: ['Effects of heat islands?','How to mitigate heat islands?','Difference between UHI and heat island?']
    },
    'growth projection': {
      definition: 'Growth projection in ecology estimates future changes in plant attributes such as trunk diameter, above‚Äëground biomass and annual CO‚ÇÇ uptake based on models and past measurements.',
      related: ['tree growth','biomass','carbon sequestration'],
      suggestions: ['How to interpret growth projections?','Tree DBH increment estimations','Impact of growth on CO‚ÇÇ sequestration']
    },
    'sequestration': {
      definition: 'Sequestration is the process by which plants and soils capture and store carbon dioxide from the atmosphere. Effective sequestration reduces atmospheric CO‚ÇÇ and mitigates climate change.',
      related: ['carbon cycle','photosynthesis','climate change'],
      suggestions: ['How much CO‚ÇÇ do trees sequester?','Difference between short‚Äëterm and long‚Äëterm sequestration?','Methods to increase sequestration?']
    },
    // Newly added ecological terms supporting expanded ecology knowledge.
    'green roof': {
      definition: 'A green roof is a vegetative layer grown on a rooftop. According to the US Environmental Protection Agency, green roofs provide shade, remove heat from the air, and reduce temperatures of the roof surface and surrounding air.',
      related: ['urban cooling','stormwater','biodiversity'],
      suggestions: ['Benefits of green roofs?','Costs of green roofs?','Green roofs vs facades']
    },
    'permeable surfaces': {
      definition: 'Permeable surfaces ‚Äî such as pervious pavements, interlocking pavers or other porous materials ‚Äî allow rain and snowmelt to seep into underlying soils. These surfaces help reduce runoff and filter pollutants.',
      related: ['stormwater','urban drainage','infiltration'],
      suggestions: ['How to increase permeable surfaces?','Benefits of permeable pavement','Difference between permeable and impervious surfaces']
    },
    'tree canopy': {
      definition: 'Tree canopy refers to the part of a city or landscape shaded by trees. The leaves and branches that cover the ground form the tree canopy, providing shade and habitat and influencing urban microclimates.',
      related: ['urban forestry','cooling impact','biodiversity'],
      suggestions: ['Why is tree canopy important?','How to expand tree canopy?','Tree canopy vs NDVI']
    },
    'native species': {
      definition: 'Native species are plant or animal species that occur naturally in a specified geographic area. They have historically existed there and are adapted to local soil and climate conditions.',
      related: ['invasive species','biodiversity','ecosystem health'],
      suggestions: ['Native vs invasive species','Benefits of native species','Examples of native species']
    },
    'invasive species': {
      definition: 'Invasive species are non‚Äënative species introduced by humans that cause harm to native plants, wildlife or ecosystems. They can disrupt ecological balance and result in environmental or economic damage.',
      related: ['native species','ecosystem health','management'],
      suggestions: ['Examples of invasive species','How to control invasive species?','Impacts of invasive species']
    },
    'nature‚Äëbased solutions': {
      definition: 'Nature‚Äëbased solutions (NBS) are cost‚Äëeffective solutions inspired and supported by nature that provide environmental, social and economic benefits. They bring more diverse nature and natural processes into cities and landscapes and help build resilience.',
      related: ['urban resilience','ecosystem services','green infrastructure'],
      suggestions: ['Examples of nature‚Äëbased solutions','How do NBS improve resilience?','Nature‚Äëbased solutions vs grey infrastructure']
    },
    'urban resilience': {
      definition: 'Urban resilience describes the ability of an urban system and its inhabitants to absorb, adapt to and recover from climate‚Äërelated shocks and stresses while safeguarding human well‚Äëbeing.',
      related: ['climate adaptation','nature‚Äëbased solutions','disaster risk reduction'],
      suggestions: ['How to improve urban resilience?','Examples of urban resilience strategies','Urban resilience vs climate adaptation']
    },
    'meadow': {
      definition: 'A meadow is an open habitat or field vegetated by grasses, herbs and other non‚Äëwoody plants. Meadows may include sparse trees or shrubs but remain open and provide habitat for wildlife and pollinators.',
      related: ['habitats','biodiversity','pollinators'],
      suggestions: ['Difference between meadow and lawn','Benefits of meadows','How to create a meadow']
    },
    'wetland': {
      definition: 'Wetlands are areas where water covers the soil or is present near the surface of the ground. Water saturation shapes the soil and determines the plant and animal communities present, supporting both aquatic and terrestrial species.',
      related: ['water management','biodiversity','ecosystem services'],
      suggestions: ['Importance of wetlands','Wetlands vs ponds','Wetlands conservation']
    },
    'urban forest': {
      definition: 'An urban forest encompasses all trees and shrubs within an urban area, including street trees, trees in yards and protected areas, and the associated vegetation and soils.',
      related: ['tree canopy','urban forestry','ecosystem services'],
      suggestions: ['Benefits of urban forests','How to expand urban forests?','Urban forestry practices']
    },
    'eu biodiversity strategy': {
      definition: 'The EU Biodiversity Strategy for 2030 aims to restore Europe‚Äôs biodiversity by 2030 to benefit people, the climate and the economy. It sets goals for protecting and restoring ecosystems and ensuring ecosystem resilience.',
      related: ['green deal','nature restoration law','eu policy'],
      suggestions: ['What are the targets of the EU Biodiversity Strategy?','Impact on municipalities?','Relationship with the Green Deal']
    },
    'green deal': {
      definition: 'The European Green Deal is a roadmap to make the EU economy sustainable by turning climate and environmental challenges into opportunities. It aims to cut greenhouse‚Äëgas emissions by at least 50% (moving towards 55%) by 2030 and make Europe climate‚Äëneutral by 2050.',
      related: ['eu policy','climate neutrality','biodiversity strategy'],
      suggestions: ['What is the Green Deal?','How does the Green Deal affect urban planning?','Relation to the Biodiversity Strategy']
    },
    'nature restoration law': {
      definition: 'The Nature Restoration Law (Nature Restoration Regulation) sets binding targets to restore at least 20% of the EU‚Äôs land and sea areas by 2030 and all ecosystems in need of restoration by 2050.',
      related: ['eu policy','biodiversity strategy','restoration'],
      suggestions: ['What does the Nature Restoration Law require?','Who is affected by the law?','Implementation timeline']
    },
    'climate adaptation plan': {
      definition: 'Climate adaptation plans ‚Äî such as those under the EU Adaptation Strategy ‚Äî outline measures to make adaptation smarter, faster and more systemic. They aim to reduce climate risks, secure water resources and integrate resilience and nature‚Äëbased solutions.',
      related: ['urban resilience','nature‚Äëbased solutions','eu policy'],
      suggestions: ['What is the EU Adaptation Strategy?','How do adaptation plans support climate resilience?','Adaptation vs mitigation']
    },
    'cooling impact': {
      definition: 'Cooling impact refers to the reduction in ambient temperature provided by vegetation, green roofs and other ecological interventions. Shading from trees and evapotranspiration help cool urban areas and reduce the Urban Heat Island effect.',
      related: ['uhi','tree canopy','green roof'],
      suggestions: ['Which interventions provide the greatest cooling?','How to measure cooling impact?','Relation between NDVI and cooling impact']
    },
    'biodiversity benefit': {
      definition: 'Biodiversity benefit denotes the improvement of species richness, habitat connectivity and ecological resilience resulting from vegetation interventions and habitat creation.',
      related: ['biodiversity','green corridor','ecosystem services'],
      suggestions: ['How to maximise biodiversity benefits?','Examples of biodiversity‚Äëfriendly projects','Biodiversity vs carbon sequestration']
    },
    'water management': {
      definition: 'Water management involves strategies to control stormwater, infiltration and water quality. Permeable surfaces, wetlands and vegetation help manage water by reducing runoff and filtering pollutants.',
      related: ['stormwater','permeable surfaces','wetlands'],
      suggestions: ['Stormwater management techniques','Why is water management important?','Green vs grey infrastructure for water management']
    },
    'human comfort': {
      definition: 'Human comfort describes how ecological interventions improve human well‚Äëbeing. Shade, cooling, recreational spaces and aesthetic values from green infrastructure contribute to comfort and livability.',
      related: ['urban resilience','public health','ecosystem services'],
      suggestions: ['How does greenery improve human comfort?','Why is human comfort considered in ecology planning?','Examples of nature‚Äëbased solutions for human comfort']
    }
    ,
    /*
      Layer‚Äëspecific definitions to answer questions about the available
      map layers.  These entries reference the information provided in
      the layer info panels so that the assistant can explain what
      each layer represents when a user asks about it.  Additional
      related concepts and suggestion prompts are provided to guide
      further exploration.
    */
    'tree inventory': {
      definition: 'The Tree Inventory layer displays publicly available street tree data. Each point represents a documented tree with attributes like species, height, crown area, above‚Äëground biomass, size class and CO‚ÇÇ stored. Click a tree to view these details.',
      related: ['trees','species','CO‚ÇÇ storage','municipal trees'],
      suggestions: ['What information does the tree inventory include?','How do I view tree attributes?','Difference between Tree Inventory and Tree Points?']
    },
    'tree points': {
      definition: 'Tree Points (municipal) show the official municipal tree registry with detailed biological and growth information including species, height, crown area, diameter at breast height (DBH), size class, above‚Äëground biomass, CO‚ÇÇ stored and growth projections such as future DBH and sequestration rates.',
      related: ['trees','municipal registry','growth projections'],
      suggestions: ['How to access growth projections?','Tree points vs tree inventory','What is DBH?']
    },
    'green spaces': {
      definition: 'Green Spaces are polygons delineating parks, lawns, sports fields and other vegetated areas. They provide habitat and recreation space and are used in corridor connectivity analysis and scenario planning.',
      related: ['greenspace','parks','habitat','corridors'],
      suggestions: ['Why are green spaces important?','How do green spaces connect corridors?','Difference between green spaces and tree points?']
    },
    'buildings': {
      definition: 'The Buildings layer displays detailed Level of Detail¬†2.2 (LOD2.2) building models with realistic roof and wall geometry. Hidden attributes include building ID, construction year and footprint area. Selecting a building reveals these details.',
      related: ['3D models','urban context','building age'],
      suggestions: ['How to view building attributes?','Why use LOD2.2?','What does the construction year tell us?']
    },
    'well‚Äëbeing corridors': {
      definition: 'Well‚Äëbeing corridors are lines connecting green spaces that indicate ecological pathways and provide walkable routes for people. Dynamic arrows flow along the lines to visualise movement (e.g. wildlife or pedestrians), illustrating habitat connectivity, planning routes and supporting human well‚Äëbeing.',
      related: ['corridors','ecological connectivity','movement flows','well-being'],
      suggestions: ['What is the purpose of well‚Äëbeing corridors?','How to improve corridor connectivity?','Why are dynamic arrows used?','How do corridors enhance well-being?']
    },
    'heatmap': {
      definition: 'The Heatmap layer overlays a raster that visualises Urban Heat Island (UHI) intensity based on surface temperature proxies. Cooler and warmer areas are colour‚Äëcoded, and combining the heatmap with NDVI highlights heat‚Äëstressed locations.',
      related: ['UHI','temperature','NDVI'],
      suggestions: ['How to interpret the heatmap?','What do the colours mean?','Why combine heatmap with NDVI?']
    }
  };

  // Generic suggestions for forward‚Äëlooking and idea prompts
  const generalSuggestions = [
    'Future plan: plant mixed vegetation for biodiversity',
    'Idea: create well‚Äëbeing corridors to connect parks',
    'Future plan: install green facades on priority buildings',
    'Idea: prioritise interventions with MCDA',
    'Future plan: reduce UHI through shading and vegetation'
    ,
    // Additional general suggestions for user follow‚Äëup actions
    'Show examples',
    'Apply on map',
    'See costs',
    'Explain more'
  ];

  // Alias mapping between Dutch/German terms and canonical dictionary keys.
  // This allows the assistant to recognise multilingual ecology concepts and synonyms.
  const aliasMap = {
    'vegetatie‚Äëindex': 'ndvi',
    'vegetatie index': 'ndvi',
    'vegetationsindex': 'ndvi',
    'stedelijk hitte‚Äëeiland': 'uhi',
    'stedelijk hitte eiland': 'uhi',
    'w√§rmeinsel': 'uhi',
    'biodiversiteit': 'biodiversity',
    'biodiversit√§t': 'biodiversity',
    'groene corridor': 'well‚Äëbeing corridor',
    '√∂kologischer korridor': 'well‚Äëbeing corridor',
    'groen dak': 'green roof',
    'groene daken': 'green roof',
    'gr√ºndach': 'green roof',
    'gr√ºnd√§cher': 'green roof',
    'waterdoorlatend': 'permeable surfaces',
    'waterdoorlatende': 'permeable surfaces',
    'wasserdurchl√§ssig': 'permeable surfaces',
    'boomkroon': 'tree canopy',
    'baumkrone': 'tree canopy',
    'inheemse soorten': 'native species',
    'heimische arten': 'native species',
    'ecosysteemdiensten': 'ecosystem services',
    '√∂kosystemleistungen': 'ecosystem services',
    'regenwater': 'stormwater',
    'regenwasser': 'stormwater',
    'natuur‚Äëgebaseerde oplossingen': 'nature‚Äëbased solutions',
    'naturbasierte l√∂sungen': 'nature‚Äëbased solutions',
    'stedelijke veerkracht': 'urban resilience',
    'urbane resilienz': 'urban resilience',
    'grasland': 'meadow',
    'wiese': 'meadow',
    'wetlands': 'wetland',
    'moeras': 'wetland',
    'sumpfgebiet': 'wetland',
    'stadsbos': 'urban forest',
    'stadtwald': 'urban forest',
    'biodiversiteitsstrategie': 'eu biodiversity strategy',
    'biodiversit√§tsstrategie': 'eu biodiversity strategy',
    'groene deal': 'green deal',
    'gr√ºner deal': 'green deal',
    'herstelwet': 'nature restoration law',
    'renaturierungsgesetz': 'nature restoration law',
    'adaptatieplan': 'climate adaptation plan',
    'anpassungsplan': 'climate adaptation plan',
    'koelingsimpact': 'cooling impact',
    'k√ºhlwirkung': 'cooling impact',
    'biodiversiteitsvoordeel': 'biodiversity benefit',
    'biodiversit√§tsvorteil': 'biodiversity benefit',
    'waterbeheer': 'water management',
    'wassermanagement': 'water management',
    'menselijk comfort': 'human comfort',
    'menschlicher komfort': 'human comfort'
    ,
    // Additional aliases for layer‚Äërelated queries
    'boom inventaris': 'tree inventory',
    'boom inventarisatie': 'tree inventory',
    'bomen inventaris': 'tree inventory',
    'tree inventory': 'tree inventory',
    'boom punten': 'tree points',
    'bomen punten': 'tree points',
    'tree points': 'tree points',
    'groene ruimtes': 'green spaces',
    'groene ruimten': 'green spaces',
    'green spaces': 'green spaces',
    'gebouwen': 'buildings',
    'geb√§ude': 'buildings',
    'buildings': 'buildings',
    'corridors': 'well‚Äëbeing corridors',
    'groene corridors': 'well‚Äëbeing corridors',
    'corridoren': 'well‚Äëbeing corridors',
    'green corridors': 'well‚Äëbeing corridors',
    'heatmap': 'heatmap',
    'hittekaart': 'heatmap',
    'hitte kaart': 'heatmap'
  };

  /**
   * Given a lower‚Äëcased query string, return a dictionary response if the query
   * directly references a known ecological term.  Recognises forms like
   * ‚Äúdefine ndvi‚Äù, ‚Äúwhat is uhi‚Äù, ‚Äúexplain biodiversity‚Äù or just ‚Äúndvi‚Äù.
   * Returns null if no match is found.
   */
  function getDictionaryResponse(text){
    const t = String(text || '').trim().toLowerCase();
    if(!t) return null;
    // Remove leading query verbs from multiple languages (e.g., define, beschrijf, what is, was ist, explain, erkl√§ren).
    let q = t.replace(/^(define|definieer|beschrijf|beschrijven|what is|wat is|was ist|erkl√§re|erklaere|erkl√§ren|erklaeren|explain|erkl\u00e4re|erkl\u00e4ren)\s+/i, '').trim();
    // Remove trailing punctuation from query
    q = q.replace(/[?!.]+$/,'');
    // Apply alias mapping to recognise multilingual synonyms
    const canonical = aliasMap[q] || q;
    if(ecoDictionary.hasOwnProperty(canonical)){
      const entry = ecoDictionary[canonical];
      let resp = '';
      if(canonical !== q){
        resp += `I may be interpreting this as ${canonical}. `;
      }
      resp += entry.definition;
      if(entry.related && entry.related.length){
        resp += ' Related concepts: ' + entry.related.join(', ') + '.';
      }
      if(entry.suggestions && entry.suggestions.length){
        resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
      }
      return resp;
    }
    // Fallback: check for dictionary key matches when user includes forms like "define uhi" or ends with term
    for(const key in ecoDictionary){
      if(!ecoDictionary.hasOwnProperty(key)) continue;
      const k = key.toLowerCase();
      if(t === k || t === ('define ' + k) || t === ('what is ' + k) || t === ('explain ' + k) || t.endsWith(' ' + k)){
        const entry = ecoDictionary[key];
        let resp = entry.definition;
        if(entry.related && entry.related.length){
          resp += ' Related concepts: ' + entry.related.join(', ') + '.';
        }
        if(entry.suggestions && entry.suggestions.length){
          resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
        }
        return resp;
      }
    }
    return null;
  }

  /**
   * Update predictive suggestions dropdown based on the current input value.
   * Searches dictionary terms and generic suggestions for matches and renders
   * clickable suggestion items.  If no input or matches exist, hides the list.
   */
  function updateSuggestions(value){
    const suggEl = document.getElementById('assistantSuggestions');
    if(!suggEl) return;
    const v = (value || '').trim().toLowerCase();
    if(!v){
      suggEl.innerHTML = '';
      suggEl.style.display = 'none';
      return;
    }
    const results = [];
    // dictionary term matches
    for(const key in ecoDictionary){
      if(!ecoDictionary.hasOwnProperty(key)) continue;
      if(key.startsWith(v) || key.includes(v)){
        results.push({type:'dict', text: key});
      }
    }
    // generic suggestion matches
    generalSuggestions.forEach(s => {
      const sl = s.toLowerCase();
      if(sl.includes(v)){
        results.push({type:'gen', text: s});
      }
    });
    // Limit to 5 suggestions
    const limited = results.slice(0, 5);
    if(limited.length === 0){
      suggEl.innerHTML = '';
      suggEl.style.display = 'none';
      return;
    }
    suggEl.innerHTML = '';
    limited.forEach(item => {
      const div = document.createElement('div');
      div.className = 'suggestion-item';
      div.textContent = item.text;
      div.addEventListener('click', () => {
        const inputEl = document.getElementById('assistantInput');
        if(inputEl){
          inputEl.value = item.text;
        }
        // hide suggestions
        suggEl.innerHTML = '';
        suggEl.style.display = 'none';
        processInput(item.text);
      });
      suggEl.appendChild(div);
    });
    suggEl.style.display = 'block';
  }

  /**
   * Compute high‚Äëlevel statistics about the municipal tree dataset.
   * Returns an object with total count, total CO‚ÇÇ stored, total projected
   * annual sequestration (mid‚Äërange), average height, and a map of species
   * counts. If the dataset is not yet loaded, returns null.
   */
  function getMunicipalStats(){
    if(!layers || !layers.trees_muni || !layers.trees_muni.entities) return null;
    const ds = layers.trees_muni;
    const time = (viewer && viewer.clock && viewer.clock.currentTime) || Cesium.JulianDate.now();
    let count = 0;
    let totalCo2 = 0;
    let totalCo2Future = 0;
    let totalHeight = 0;
    const speciesCount = {};
    for(const e of ds.entities.values){
      count++;
      const co2 = safePropNumber(e, TREE_KEYS.co2, time) || 0;
      totalCo2 += co2;
      // mid‚Äërange projection for future sequestration (kg/yr)
      const co2Next = safePropNumber(e, TREE_EXTRA_KEYS.co2NextMed, time) || 0;
      totalCo2Future += co2Next;
      const h = safePropNumber(e, TREE_KEYS.height, time);
      if(h !== null && h !== undefined) totalHeight += h;
      const sp = (safePropString(e, TREE_KEYS.species, time) || '').trim();
      if(sp){
        speciesCount[sp] = (speciesCount[sp] || 0) + 1;
      }
    }
    const avgHeight = count > 0 ? (totalHeight / count) : 0;
    return { count, totalCo2, totalCo2Future, speciesCount, avgHeight };
  }
  function addMessage(sender, text){
    const messagesEl = document.getElementById('assistantMessages');
    if(!messagesEl) return;
    const div = document.createElement('div');
    div.className = 'assistant-message ' + (sender === 'user' ? 'user' : 'bot');
    div.textContent = text;
    messagesEl.appendChild(div);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  function updateChips(chips){
    const chipsEl = document.getElementById('assistantChips');
    if(!chipsEl) return;
    chipsEl.innerHTML = '';
    chips.forEach(ch => {
      const chip = document.createElement('div');
      chip.className = 'assistant-chip';
      chip.textContent = ch.label;
      chip.addEventListener('click', () => {
        addMessage('user', ch.label);
        processInput(ch.command || ch.label);
      });
      chipsEl.appendChild(chip);
    });
  }
  function assistantUpdateChips(type){
    if(type === 'tree'){
      updateChips([
        { label: 'Show Growth Projection', command: 'growth projection' },
        { label: 'Why is this area hot?', command: 'why is this area hot' },
        { label: 'Explain NDVI', command: 'explain ndvi' }
      ]);
      return;
    }
    if(type === 'building'){
      updateChips([
        { label: 'Why is this building a priority?', command: 'why is this building a priority' },
        { label: 'Explain MCDA', command: 'explain mcda' },
        { label: 'Explain UHI', command: 'explain uhi' }
      ]);
      return;
    }
    if(type === 'scenario'){
      updateChips([
        { label: 'Explain Scenario Polygon', command: 'explain scenario polygon' },
        { label: 'Explain NDVI', command: 'explain ndvi' },
        { label: 'Explain UHI', command: 'explain uhi' }
      ]);
      return;
    }
    updateChips(defaultChips);
  }
  window.assistantUpdateChips = assistantUpdateChips;
  function processInput(input){
    const msg = input || '';
    const text = msg.trim().toLowerCase();
    if(!text) return;
    // --- Multilingual action commands ---
    // Show/toggle the heatmap when users request "toon hittekaart" (NL) or "zeige hitzekarte" (DE)
    if((text.includes('toon') && (text.includes('hittekaart') || text.includes('hitte kaart'))) ||
       (text.includes('zeige') && (text.includes('hitzekarte') || text.includes('hitze karte')))){
      toggleLayer('heatmap');
      const sw = document.getElementById('sw-heatmap');
      const isOn = sw && sw.classList.contains('active');
      addMessage('bot', 'Heatmap ' + (isOn ? 'enabled' : 'disabled') + '.');
      assistantUpdateChips();
      return;
    }
    // Activate green roof drawing when users ask for green roofs ("groene daken", "gr√ºne d√§cher")
    if(((text.includes('toon') || text.includes('zeige')) &&
        ((text.includes('groene') || text.includes('gr√ºne') || text.includes('grune')) &&
         (text.includes('dak') || text.includes('d√§cher') || text.includes('dacher') || text.includes('daken'))))){
      const el = document.getElementById('sc-greenroof');
      if(el) selectScenarioType('greenroof', el);
      startPolygonDraw();
      addMessage('bot', 'Green roof drawing mode activated. Click on the map to draw your green roof polygon; right‚Äëclick to finish.');
      assistantUpdateChips('scenario');
      return;
    }
    // Run MCDA when users ask to prioritise buildings ("prioriteer gebouwen", "priorisieren geb√§ude")
    if(((text.includes('prioriteer') || text.includes('prioritiseer') || text.includes('priorisieren') || text.includes('priorisiere')) &&
        (text.includes('gebouw') || text.includes('gebouwen') || text.includes('geb√§ude') || text.includes('gebaeude')))){
      addMessage('bot', 'Running decision support...');
      try{
        openMCDA();
        runMCDA();
      }catch(e){}
      assistantUpdateChips('building');
      return;
    }
    // Start scenario drawing when users say "szenario zeichnen" (DE) or "scenario tekenen" (NL)
    if(((text.includes('szenario') || text.includes('scenario')) &&
        (text.includes('zeichnen') || text.includes('zeichne') || text.includes('teken') || text.includes('tekenen')))){
      // Determine scenario type based on keywords; default to trees
      let scenario = 'trees';
      if(text.includes('gras') || text.includes('grass')) scenario = 'grass';
      if(text.includes('struik') || text.includes('struiken') || text.includes('shrub')) scenario = 'shrubs';
      if(text.includes('gemengd') || text.includes('mixed')) scenario = 'mixed';
      if(text.includes('raingarden') || text.includes('regentuin')) scenario = 'raingarden';
      if(text.includes('permeabel') || text.includes('permeable')) scenario = 'permeable';
      if(text.includes('shading') || text.includes('schaduw')) scenario = 'shading';
      if(text.includes('green roof') || text.includes('groen dak') || text.includes('gr√ºne d√§cher')) scenario = 'greenroof';
      const el = document.getElementById('sc-' + scenario);
      if(el) selectScenarioType(scenario, el);
      startPolygonDraw();
      addMessage('bot', 'Drawing mode activated. Click on the map to draw your polygon; right‚Äëclick to finish.');
      assistantUpdateChips('scenario');
      return;
    }
    // Definitions via ecological dictionary
    const dictResp = getDictionaryResponse(text);
    if(dictResp){
      addMessage('bot', dictResp);

      // Enrich with a short Wikipedia snippet when possible
      (async () => {
        const wikiMap = {
          'ndvi': 'Normalized difference vegetation index',
          'uhi': 'Urban heat island',
          'mcda': 'Multi-criteria decision analysis',
          'green corridor': 'Wildlife corridor',
          'well‚Äëbeing corridor': 'Wildlife corridor',
          'ecosystem services': 'Ecosystem services',
          'stormwater': 'Stormwater',
          'biodiversity': 'Biodiversity',
          // Additional mappings for expanded dictionary
          'green roof': 'Green roof',
          'permeable surfaces': 'Permeable paving',
          'tree canopy': 'Tree canopy',
          'native species': 'Native species',
          'invasive species': 'Invasive species',
          'nature‚Äëbased solutions': 'Nature-based solutions',
          'urban resilience': 'Climate resilience',
          'meadow': 'Meadow',
          'wetland': 'Wetland',
          'urban forest': 'Urban forest',
          'eu biodiversity strategy': 'European Union Biodiversity Strategy for 2030',
          'green deal': 'European Green Deal',
          'nature restoration law': 'Nature Restoration Law',
          'climate adaptation plan': 'Climate change adaptation',
          'cooling impact': 'Urban heat island mitigation',
          'biodiversity benefit': 'Biodiversity',
          'water management': 'Water resource management',
          'human comfort': 'Thermal comfort'
        };
        for(const k in wikiMap){
          if(text.includes(k)){
            const s = await fetchWikiSummary(wikiMap[k]);
            if(s && s.extract){
              const excerpt = s.extract.length > 280 ? (s.extract.slice(0, 280) + '‚Ä¶') : s.extract;
              addMessage('bot', `Wikipedia (${s.title}): ${excerpt}${s.page ? '\n' + s.page : ''}`);
            }
            break;
          }
        }
      })().catch(()=>{});

      assistantUpdateChips();
      return;
    }
    // Budget / financial trade‚Äëoff queries (e.g., "I have 1000 euro to spend")
    const budgetMatch = text.match(/(\d{2,7})\s*(‚Ç¨|eur|euro)/i) || (text.includes('budget') ? text.match(/\b(\d{2,7})\b/) : null);
    if(budgetMatch){
      const budget = Number(budgetMatch[1]);
      if(Number.isFinite(budget) && budget > 0){
        const objGuess =
          (text.includes('cool') || text.includes('heat')) ? 'cooling' :
          (text.includes('co2') || text.includes('carbon')) ? 'carbon' :
          (text.includes('storm') || text.includes('water') || text.includes('flood')) ? 'stormwater' :
          (text.includes('bio') || text.includes('habitat') || text.includes('species')) ? 'biodiversity' :
          'balanced';

        const plan = planForBudget(budget, objGuess);
        addMessage('bot', formatPlanText(plan));
        addMessage('bot', "Want alternatives? Try: 'cooling plan for ‚Ç¨1000' or 'biodiversity plan for ‚Ç¨1000'.");
        assistantUpdateChips();
        return;
      }
    }

    // Idea / future planning suggestions
    if(text.includes('plan') || text.includes('idea') || text.includes('future')){
      addMessage('bot', 'Here are some ideas for future ecological planning: plant mixed vegetation for biodiversity, create green corridors to connect parks, install green facades on priority buildings, run MCDA to prioritise interventions and increase shading to reduce UHI.');
      assistantUpdateChips();
      return;
    }
    // Custom queries: municipal tree summary and future prediction
    if((text.includes('tree') && text.includes('summary')) || (text.includes('municipal') && (text.includes('summary') || text.includes('stats')))){
      const stats = getMunicipalStats();
      if(!stats){
        addMessage('bot', 'Municipal tree data is still loading.');
      } else {
        const speciesEntries = Object.entries(stats.speciesCount);
        // Sort species by count descending and pick top 3 for succinctness
        speciesEntries.sort((a, b) => b[1] - a[1]);
        const topSpecies = speciesEntries.slice(0, 3).map(([s, c]) => `${s} (${c})`).join(', ');
        const message = `There are ${stats.count.toLocaleString()} municipal trees storing approximately ${Math.round(stats.totalCo2).toLocaleString()} kg of CO‚ÇÇ. The most common species include ${topSpecies}. The average height is about ${stats.avgHeight.toFixed(1)} m.`;
        addMessage('bot', message);
      }
      assistantUpdateChips();
      return;
    }
    if(text.includes('future') && text.includes('prediction')){
      const stats = getMunicipalStats();
      if(!stats){
        addMessage('bot', 'Municipal tree data is still loading, so I can‚Äôt compute future projections yet.');
      } else {
        const yearly = Math.round(stats.totalCo2Future).toLocaleString();
        addMessage('bot', `Based on the growth projections, municipal trees could sequester roughly ${yearly} kg of CO‚ÇÇ per year (mid‚Äërange estimate) as they mature. Continued growth and planting will enhance cooling and biodiversity benefits.`);
      }
      assistantUpdateChips();
      return;
    }
    // Multilingual greetings and farewells.
    // Recognise common Dutch/German greetings like ‚Äúhallo‚Äù, ‚Äúhoi‚Äù, ‚Äúgoedemorgen‚Äù and
    // ‚Äúguten Morgen‚Äù and treat them as English salutations.  This makes the
    // assistant approachable for users greeting in their native language while
    // still replying in English.  Similarly, farewell expressions like
    // ‚Äútsch√ºss‚Äù, ‚Äúdoei‚Äù or ‚Äúauf wiedersehen‚Äù are handled below.
    if(/^(hi|hello|hey|hallo|hoi|guten\s*(morgen|tag|abend)|goed(e|en)?\s*(morgen|middag|avond)|servus|moin)/.test(text)){
      addMessage('bot', 'Hello! How can I assist you with your ecological twin?');
      assistantUpdateChips();
      return;
    }
    if(/\b(bye|goodbye|see\s*you|tsch√ºss|tschuss|auf\s*wiedersehen|doei|tot\s*ziens|dag)\b/.test(text)){
      addMessage('bot', 'Goodbye! Have a great day.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('heatmap') && (text.includes('turn on') || text.includes('turn off') || text.includes('toggle') || text.includes('switch'))){
      toggleLayer('heatmap');
      const sw = document.getElementById('sw-heatmap');
      const isOn = sw && sw.classList.contains('active');
      addMessage('bot', 'Heatmap ' + (isOn ? 'enabled' : 'disabled') + '.');
      assistantUpdateChips();
      return;
    }
    if((text.includes('run') && text.includes('mcda')) || (text.includes('decision') && text.includes('support')) || text.includes('prioritis') || text.includes('prioritize')){
      addMessage('bot', 'Running decision support...');
      try{
        openMCDA();
        runMCDA();
      }catch(e){}
      assistantUpdateChips('building');
      return;
    }
    if(text.includes('start') && (text.includes('draw') || text.includes('drawing'))){
      let scenario = 'trees';
      if(text.includes('grass')) scenario = 'grass';
      if(text.includes('shrub')) scenario = 'shrubs';
      if(text.includes('mixed')) scenario = 'mixed';
      const el = document.getElementById('sc-' + scenario);
      if(el) selectScenarioType(scenario, el);
      startPolygonDraw();
      addMessage('bot', 'Drawing mode activated. Click on the map to draw your polygon; right‚Äëclick to finish.');
      assistantUpdateChips('scenario');
      return;
    }
    if(text.includes('plant') && (text.includes('oak') || text.includes('tree'))){
      const grids = document.querySelectorAll('#rightPanel .species-grid');
      const treeGrid = grids[0];
      let elOak = null;
      if(treeGrid){
        treeGrid.querySelectorAll('.species-opt').forEach(opt => {
          if(opt.textContent.toLowerCase().includes('oak')) elOak = opt;
        });
      }
      if(elOak) selectSpecies('oak', elOak);
      togglePlanting();
      addMessage('bot', 'Planting mode activated. Click on the map to place the oak tree.');
      assistantUpdateChips('tree');
      return;
    }
    if((text.includes('apply') && text.includes('ivy')) || (text.includes('ivy') && text.includes('facade'))){
      const grids = document.querySelectorAll('#rightPanel .species-grid');
      const facadeGrid = grids[1];
      let elIvy = null;
      if(facadeGrid){
        facadeGrid.querySelectorAll('.species-opt').forEach(opt => {
          if(opt.textContent.toLowerCase().includes('ivy')) elIvy = opt;
        });
      }
      if(elIvy) selectFacadeType('ivy', elIvy);
      toggleFacading();
      addMessage('bot', 'Facade mode activated. Click on a building to apply the ivy facade.');
      assistantUpdateChips('building');
      return;
    }
    if(text.includes('download') && text.includes('report')){
      addMessage('bot', 'Generating and downloading the PDF report...');
      try{ downloadReport(); }catch(e){}
      assistantUpdateChips();
      return;
    }
    if(text.includes('download') && text.includes('chart')){
      addMessage('bot', 'Downloading the chart...');
      try{ downloadCharts(); }catch(e){}
      assistantUpdateChips();
      return;
    }
    if(text.includes('ndvi')){
      addMessage('bot', 'NDVI (Normalised Difference Vegetation Index) compares near‚Äëinfrared and red reflectance to assess vegetation health. Values range from -1 to +1; healthy vegetation produces higher NDVI values, while low or negative values indicate barren or built surfaces or water.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('uhi') || text.includes('urban heat island') || text.includes('heat island')){
      addMessage('bot', 'Urban Heat Islands are pockets of higher temperature within cities caused by heat‚Äëabsorbing materials, reduced vegetation and anthropogenic heat. The UHI heatmap visualises relative surface temperatures; combining it with NDVI highlights hot, stressed areas.');
      assistantUpdateChips();
      return;
    }
    if((text.includes('green') && text.includes('corridor')) || text.includes('corridors')){
      addMessage('bot', 'Green corridors are lines connecting green spaces that indicate ecological connectivity and facilitate wildlife movement. These corridors are visualised in the green corridors layer and considered in the MCDA prioritisation.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('scenario') || text.includes('polygon') || text.includes('grass') || text.includes('shrub') || text.includes('mixed')){
      addMessage('bot', 'Scenario polygons let you draw grass, shrub, tree or mixed vegetation areas. Each type has defined effects on NDVI, cooling per hectare, stormwater infiltration and biodiversity proxy, as specified in the SCENARIO_PARAMS object.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('mcda') || text.includes('decision support')){
      addMessage('bot', 'MCDA (Multi‚ÄëCriteria Decision Analysis) ranks buildings based on criteria like UHI, NDVI, corridor proximity, age and footprint area. Adjust the objectives and parameters in the wizard to prioritise interventions.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('why') && text.includes('priority')){
      addMessage('bot', 'Buildings are prioritised when they exhibit high UHI, low NDVI, are near green corridors, are older and have larger footprints. These factors combine into a score used by the MCDA ranking.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('why') && text.includes('hot')){
      addMessage('bot', 'This area is likely hot due to heat‚Äëabsorbing surfaces and low vegetation cover. High UHI values combined with low NDVI highlight such stressed areas.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('growth') || text.includes('projection')){
      addMessage('bot', 'Growth projections are available for municipal trees. Select a tree to see estimates of trunk diameter, above‚Äëground biomass and annual CO‚ÇÇ uptake over future years.');
      assistantUpdateChips();
      return;
    }
    addMessage('bot', 'Let me look that up‚Ä¶ (Wikipedia)');

    (async () => {
      const title = await wikiOpenSearch(msg);
      if(!title){
        addMessage('bot', 'Sorry ‚Äî I couldn\'t find a relevant Wikipedia page.');
        assistantUpdateChips();
        return;
      }
      const s = await fetchWikiSummary(title);
      if(!s || !s.extract){
        addMessage('bot', `I found "${title}", but couldn\'t fetch a summary.`);
        assistantUpdateChips();
        return;
      }
      const excerpt = s.extract.length > 520 ? (s.extract.slice(0, 520) + '‚Ä¶') : s.extract;
      addMessage('bot', `Wikipedia (${s.title}): ${excerpt}${s.page ? '\n' + s.page : ''}`);
      assistantUpdateChips();
    })().catch(() => {
      addMessage('bot', 'Sorry, I couldn\'t find an answer.');
      assistantUpdateChips();
    });
  }
  document.addEventListener('DOMContentLoaded', () => {
    const sendBtn = document.getElementById('assistantSend');
    const inputEl = document.getElementById('assistantInput');
    // Toggle and close buttons for assistant
    const toggleBtn = document.getElementById('assistantToggle');
    const container = document.getElementById('assistantContainer');
    const closeBtn = document.getElementById('assistantClose');
    // Wire up send button and input
    if(sendBtn && inputEl){
      sendBtn.addEventListener('click', () => {
        const val = inputEl.value;
        if(val){
          addMessage('user', val);
          processInput(val);
          inputEl.value = '';
        }
      });
      inputEl.addEventListener('keypress', (e) => {
        if(e.key === 'Enter'){
          const val = inputEl.value;
          if(val){
            addMessage('user', val);
            processInput(val);
            inputEl.value = '';
          }
        }
      });
      // Update predictive suggestions as the user types
      inputEl.addEventListener('input', () => {
        updateSuggestions(inputEl.value);
      });
    }
    // Assistant toggle behaviour
    if(toggleBtn && container){
      toggleBtn.addEventListener('click', () => {
        container.classList.toggle('hide');
        // hide suggestions when toggling the assistant
        const sEl = document.getElementById('assistantSuggestions');
        if(sEl){
          sEl.innerHTML = '';
          sEl.style.display = 'none';
        }
      });
    }
    // Close button hides the assistant but leaves the toggle visible
    if(closeBtn && container){
      closeBtn.addEventListener('click', () => {
        container.classList.add('hide');
        // hide suggestions when closing the assistant
        const sEl = document.getElementById('assistantSuggestions');
        if(sEl){
          sEl.innerHTML = '';
          sEl.style.display = 'none';
        }
      });
    }
    // Show suggestions when page loads
    assistantUpdateChips();
  });
})();
</script>

<!-- Weather update script: fetch real‚Äëtime weather and update the widget -->
<script>
// Coordinates for Enschede, Netherlands
const WEATHER_LAT = 52.221;
const WEATHER_LON = 6.893;
async function updateWeather(){
  try {
    // Fetch combined current weather, daily extremes and humidity
    const wResp = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${WEATHER_LAT}&longitude=${WEATHER_LON}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,snowfall_sum&hourly=relative_humidity_2m&forecast_hours=1&timezone=Europe/Amsterdam`);
    const wData = await wResp.json();
    const tempEl = document.getElementById('weatherTemp');
    const eventEl = document.getElementById('weatherEvent');
    const barEl = document.getElementById('weatherBarFill');
    if(!wData || !tempEl || !eventEl || !barEl) return;
    // Update current temperature
    if(wData.current_weather && typeof wData.current_weather.temperature === 'number'){
      tempEl.innerText = wData.current_weather.temperature.toFixed(1) + '¬∞C';
    }
    // Save current humidity if available (take the first hour)
    if(wData.hourly && Array.isArray(wData.hourly.relative_humidity_2m) && wData.hourly.relative_humidity_2m.length > 0){
      window.currentHumidity = wData.hourly.relative_humidity_2m[0];
    } else {
      window.currentHumidity = null;
    }
    // Determine next snow or heat event within 7 days using daily values
    let nextDays = null;
    let type = '';
    if(wData.daily && Array.isArray(wData.daily.time)){
      const today = new Date();
      today.setHours(0,0,0,0);
      for(let idx = 0; idx < wData.daily.time.length; idx++){
        const dt = new Date(wData.daily.time[idx]);
        const diffDays = Math.round((dt.getTime() - today.getTime()) / (1000*60*60*24));
        if(diffDays < 0) continue;
        const snow = wData.daily.snowfall_sum && wData.daily.snowfall_sum[idx] ? wData.daily.snowfall_sum[idx] : 0;
        const tmax = wData.daily.temperature_2m_max && typeof wData.daily.temperature_2m_max[idx] === 'number' ? wData.daily.temperature_2m_max[idx] : null;
        if(snow > 0){
          nextDays = diffDays;
          type = 'Snowfall';
          break;
        } else if(tmax !== null && tmax >= 30){
          nextDays = diffDays;
          type = 'Heat';
          break;
        }
      }
    }
    if(nextDays !== null && nextDays <= 7){
      const frac = nextDays / 7;
      barEl.style.width = Math.max(0, Math.min(1, frac)) * 100 + '%';
      eventEl.innerText = (type === 'Snowfall' ? 'Next snowfall in ' : 'Next heat in ') + nextDays + ' day' + (nextDays === 1 ? '' : 's');
    } else {
      // No extreme event within 7 days
      barEl.style.width = '0%';
      eventEl.innerText = 'No extreme weather in 7 days';
    }
    // Fetch current air quality values (European AQI and pollutants)
    try{
      const aqResp = await fetch(`https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${WEATHER_LAT}&longitude=${WEATHER_LON}&current=european_aqi,pm2_5,pm10,ozone,nitrogen_dioxide&timezone=Europe/Amsterdam`);
      const aqData = await aqResp.json();
      if(aqData && aqData.current && typeof aqData.current.european_aqi === 'number'){
        window.currentAQI = aqData.current.european_aqi;
      } else {
        window.currentAQI = null;
      }
    }catch(aqErr){
      console.warn('Air quality fetch failed', aqErr);
      window.currentAQI = null;
    }
  }catch(err){
    console.warn('Weather fetch failed', err);
  }
}
// Display detailed weather information in a pop-up
function showWeatherDetails(){
  const modal = document.getElementById('weatherModal');
  const content = document.getElementById('weatherDetailContent');
  if(!modal || !content) return;
  // Build rows for temperature, humidity and air quality
  const temp = document.getElementById('weatherTemp') ? document.getElementById('weatherTemp').innerText : '--¬∞C';
  const humidity = (typeof window.currentHumidity === 'number') ? Math.round(window.currentHumidity) + '%' : '‚Äî';
  const aqi = (typeof window.currentAQI === 'number') ? Math.round(window.currentAQI) : '‚Äî';
  // European AQI ranges: 0-20 good, 20-40 fair, 40-60 moderate, 60-80 poor, 80-100 very poor„Äê411077823428057‚Ä†L400-L404„Äë.
  let aqiDesc = '';
  if(typeof window.currentAQI === 'number'){
    const val = window.currentAQI;
    if(val < 20) aqiDesc = 'Good air quality';
    else if(val < 40) aqiDesc = 'Fair air quality';
    else if(val < 60) aqiDesc = 'Moderate air quality';
    else if(val < 80) aqiDesc = 'Poor air quality';
    else if(val <= 100) aqiDesc = 'Very poor air quality';
    else aqiDesc = 'Extremely poor air quality';
  }
  let html = '';
  html += `<div class="pop-row"><span class="pop-label">Temperature</span><span class="pop-val">${temp}</span></div>`;
  html += `<div class="pop-row"><span class="pop-label">Humidity</span><span class="pop-val">${humidity}</span></div>`;
  html += `<div class="pop-row"><span class="pop-label">AQI</span><span class="pop-val">${aqi}</span></div>`;
  html += `<div style="font-size:10px; margin-top:6px; color:rgba(226,232,240,0.75);">${aqiDesc ? aqiDesc + '. ' : ''}Lower values indicate better air quality. Planting more trees and reducing emissions can improve local air quality.</div>`;
  content.innerHTML = html;
  modal.style.display = 'block';
}
function closeWeatherModal(){
  const modal = document.getElementById('weatherModal');
  if(modal) modal.style.display = 'none';
}
// Start weather updates once the page has loaded
window.addEventListener('load', () => {
  updateWeather();
  setInterval(updateWeather, 3600 * 1000);
});
</script>
</body>
</html>
