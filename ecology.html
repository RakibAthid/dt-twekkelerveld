<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#0f172a">
<title>Twekkelerveld Ecology Digital Twin</title>

<!-- Cloudflare/R2 config (optional). If missing, the app falls back to local files. -->
<script src="config.js"></script>

<!-- CesiumJS -->
<script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
<link href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css" rel="stylesheet"/>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- jsPDF for PDF report -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<!-- Fonts & Icons -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
  /* UI styling */
  :root {
    --bg-dark: #020617;
    --panel-bg: rgba(2, 6, 23, 0.85);
    --panel-bg-2: rgba(15, 23, 42, 0.75);
    --border: rgba(148, 163, 184, 0.18);
    --border-strong: rgba(45, 212, 191, 0.35);
    --primary: #2dd4bf;
    --primary-hover: #14b8a6;
    --text-main: #f8fafc;
    --text-sub: rgba(226, 232, 240, 0.72);
    --danger: #fb7185;
    --gold: #fbbf24;
    --blue: #60a5fa;
    --purple: #c084fc;
  }

  body, html, #cesiumContainer {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: 'Inter', sans-serif;
    background: var(--bg-dark);
    overflow: hidden;
  }

  #cesiumContainer { 
    position: absolute; 
    top: 0; 
    left: 0; 
    z-index: 0; 
  }

  #uiLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    z-index: 100;
  }

  .top-bar {
    pointer-events: auto;
    align-self: center;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    padding: 10px 16px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    gap: 12px;
    box-shadow: 0 10px 28px rgba(0,0,0,0.35);
    backdrop-filter: blur(14px);
    z-index: 101;
  }

  .app-title {
    font-weight: 800;
    font-size: 13px;
    color: var(--text-main);
    letter-spacing: 0.2px;
  }

  .btn-overview {
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--border);
    color: var(--text-main);
    padding: 6px 12px;
    border-radius: 999px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: 0.18s;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .btn-overview:hover { background: rgba(45, 212, 191, 0.85); color: #0b1220; border-color: rgba(45, 212, 191, 0.45); }

  /* Weather widget styles */
  .weather-widget {
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--border);
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 12px;
    color: var(--text-main);
  }
  .weather-bar {
    width: 60px;
    height: 4px;
    background: rgba(255,255,255,0.15);
    border-radius: 5px;
    position: relative;
    overflow: hidden;
  }
  .weather-bar-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 0%;
    background: var(--primary);
  }

  /* STATIC PANELS - Scrollable but Fixed */
  .panel {
    pointer-events: auto;
    width: clamp(240px, 24vw, 340px);
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 14px 34px rgba(0,0,0,0.45);
    backdrop-filter: blur(16px);
    z-index: 102;
    /* Static scrolling behavior */
    max-height: calc(100vh - 220px);
    overflow-y: auto;
  }

  /* Settings button and modal styles for ecology */
  #ecoSettingsBtn {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 105;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--border);
    color: var(--text-main);
    padding: 6px 12px;
    border-radius: 999px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: 0.18s;
    display: flex;
    align-items: center;
    gap: 6px;
    backdrop-filter: blur(14px);
  }
  #ecoSettingsBtn:hover {
    background: rgba(45, 212, 191, 0.85);
    color: #0b1220;
    border-color: rgba(45, 212, 191, 0.45);
  }
  #eco-settings-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.55);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 99999;
  }
  #eco-settings-overlay.active { display: flex; }
  #eco-settings-modal {
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 20px;
    width: min(440px, 90%);
    max-height: 90vh;
    overflow-y: auto;
    color: var(--text-main);
    box-shadow: 0 14px 34px rgba(0,0,0,0.45);
    backdrop-filter: blur(16px);
  }
  #eco-settings-modal h2 {
    margin-top: 0;
    margin-bottom: 12px;
    font-size: 18px;
    font-weight: 700;
  }
  #eco-settings-modal h3 {
    margin-top: 16px;
    margin-bottom: 8px;
    font-size: 14px;
    color: var(--primary);
  }
  #eco-settings-modal .field {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-bottom: 8px;
  }
  #eco-settings-modal .field label {
    font-size: 12px;
    color: var(--text-sub);
  }
  #eco-settings-modal .field input {
    background: rgba(255,255,255,0.06);
    border: 1px solid var(--border);
    color: var(--text-main);
    border-radius: 8px;
    padding: 6px;
    font-size: 12px;
  }
  #eco-settings-modal details {
    margin-top: 8px;
    border-top: 1px solid rgba(255,255,255,0.1);
    padding-top: 8px;
  }
  #eco-settings-modal summary {
    cursor: pointer;
    font-size: 12px;
    color: var(--primary);
    font-weight: 600;
  }
  #eco-settings-modal .button-row {
    display: flex;
    gap: 10px;
    margin-top: 16px;
  }
  #eco-settings-modal .save-btn {
    flex: 1;
    background: var(--primary);
    color: #0b1220;
    border: none;
    padding: 8px 14px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
  }
  #eco-settings-modal .cancel-btn {
    flex: 1;
    background: rgba(255,255,255,0.12);
    color: var(--text-main);
    border: none;
    padding: 8px 14px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
  }
  #eco-settings-modal .save-btn:hover {
    background: var(--primary-hover);
  }
  #eco-settings-modal .cancel-btn:hover {
    background: rgba(255,255,255,0.18);
  }

  #leftPanel { 
    position: absolute; 
    top: 72px; 
    left: 14px; 
    z-index: 103;
  }

  #rightPanel {
    position: absolute; 
    top: 72px; 
    right: 14px;
    z-index: 103;
  }

  .panel-top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom: 2px;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(255,255,255,0.07);
  }
  .panel-title{
    display:flex;
    align-items:center;
    gap:8px;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: rgba(45, 212, 191, 0.95);
    font-weight: 800;
  }

  #bottomPanel {
    pointer-events: auto;
    align-self: center;
    width: min(560px, calc(100vw - 40px));
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 14px 20px;
    backdrop-filter: blur(12px);
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    margin-bottom: 20px;
    z-index: 101;
  }

  h3 {
    margin: 0;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    color: rgba(45, 212, 191, 0.95);
    font-weight: 800;
    border-bottom: 1px solid rgba(255,255,255,0.07);
    padding-bottom: 8px;
    margin-bottom: 4px;
  }

  .layer-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 10px;
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06);
    transition: 0.18s;
    cursor: pointer;
    gap: 10px;
  }
  .layer-item:hover {
    border-color: var(--border-strong);
    background: rgba(255,255,255,0.05);
  }

  .layer-label {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-main);
    display: flex;
    align-items: center;
    gap: 8px;
    user-select: none;
  }
  .layer-actions{ display:flex; align-items:center; gap:8px; flex-shrink: 0; }

  .info-btn{
    pointer-events:auto;
    border:none;
    background: rgba(255,255,255,0.04);
    color: rgba(226,232,240,0.65);
    width: 28px;
    height: 28px;
    border-radius: 10px;
    cursor: pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    transition: .18s;
    border: 1px solid rgba(148,163,184,0.18);
  }
  .info-btn:hover{
    color: white;
    border-color: rgba(45,212,191,0.45);
    box-shadow: 0 0 0 3px rgba(45,212,191,0.08);
  }

  .switch {
    width: 34px;
    height: 18px;
    background: rgba(148,163,184,0.22);
    border-radius: 999px;
    position: relative;
    transition: 0.25s;
    border: 1px solid rgba(148,163,184,0.18);
  }
  .switch::after {
    content:'';
    position:absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    background: rgba(226,232,240,0.85);
    border-radius: 50%;
    transition: 0.25s;
  }
  .switch.active {
    background: rgba(45, 212, 191, 0.85);
    border-color: rgba(45, 212, 191, 0.35);
  }
  .switch.active::after {
    transform: translateX(16px);
    background: #0b1220;
  }

  .slider-container {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 12px;
    color: var(--text-sub);
  }
  input[type=range] { flex: 1; accent-color: var(--primary); cursor: pointer; }
  .slider-val {
    font-weight: 800;
    color: var(--text-main);
    min-width: 82px;
    text-align: right;
  }

  .stats-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }
  .stat-box {
    background: rgba(0,0,0,0.30);
    border-radius: 12px;
    padding: 10px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.06);
  }
  .stat-num { font-size: 16px; font-weight: 800; color: var(--text-main); }
  .stat-name { font-size: 9px; text-transform: uppercase; color: var(--text-sub); margin-top: 2px; letter-spacing: 0.5px; }

  .species-grid { display: flex; gap: 6px; margin-bottom: 10px; }
  .species-opt {
    flex: 1;
    background: rgba(0,0,0,0.30);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 12px;
    padding: 7px 6px;
    text-align: center;
    cursor: pointer;
    transition: 0.18s;
    opacity: 0.68;
    user-select: none;
  }
  .species-opt:hover { opacity: 1; border-color: rgba(45,212,191,0.55); }
  .species-opt.selected {
    opacity: 1;
    background: rgba(45, 212, 191, 0.12);
    border-color: rgba(45,212,191,0.75);
    box-shadow: 0 0 0 3px rgba(45,212,191,0.08);
  }
  .spec-icon { font-size: 18px; margin-bottom: 4px; display: block; }
  .spec-name { font-size: 10px; font-weight: 700; color: var(--text-main); display: block; }
  .spec-cost { font-size: 9px; color: var(--gold); }

  #btnPlant, #btnFacade {
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 12px;
    background: rgba(45, 212, 191, 0.90);
    color: #0b1220;
    font-weight: 900;
    font-size: 12px;
    cursor: pointer;
    box-shadow: 0 10px 22px rgba(0,0,0,0.25);
    transition: 0.18s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  #btnPlant:hover, #btnFacade:hover { transform: translateY(-1px); filter: brightness(1.03); }

  #btnPlant.planting {
    background: #f59e0b;
    animation: pulse 1.5s infinite;
    color: #451a03;
  }
  #btnFacade.facading {
    background: #22c55e;
    animation: pulseGreen 1.5s infinite;
    color: #052e16;
  }

  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4); }
    70% { box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
    100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
  }
  @keyframes pulseGreen {
    0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.35); }
    70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
    100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
  }

  .small-btn {
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(148,163,184,0.28);
    color: rgba(226,232,240,0.80);
    padding: 8px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 11px;
    width: 100%;
    margin-top: 10px;
    transition: .18s;
  }
  .small-btn:hover {
    background: rgba(255,255,255,0.04);
    border-color: rgba(45,212,191,0.45);
    color: white;
  }

  /* =======================================
     Gauge Overview Styles
     Creates a grid of four semicircular gauges to display
     scenario impact metrics (COâ‚‚ sequestration, stormwater
     runoff reduction, cooling effect and investment). Each
     gauge uses a Chart.js doughnut chart with a custom plugin
     to render the numeric value and caption in the centre.
  ======================================= */
  .gauge-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    margin-bottom: 10px;
  }
  .gauge-box {
    position: relative;
    background: rgba(0,0,0,0.30);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 16px;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 120px;
  }
  .gauge-box canvas {
    width: 100% !important;
    height: 100% !important;
  }

  .gauge-box .gauge-value {
    position: absolute;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
    font-weight: 700;
    color: var(--text-main);
    pointer-events: none;
  }
  .gauge-box .gauge-caption {
    position: absolute;
    top: 70%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 9px;
    font-weight: 600;
    text-transform: uppercase;
    color: var(--text-sub);
    pointer-events: none;
  }

  /* Increase right panel width for gauge layout */
  #rightPanel {
    width: clamp(260px, 28vw, 380px);
  }

  #ecoPopup {
    position: absolute;
    width: 290px;
    max-width: 320px;
    background: rgba(2, 6, 23, 0.95);
    border: 1px solid rgba(45,212,191,0.45);
    border-radius: 14px;
    padding: 14px;
    color: white;
    display: none;
    z-index: 200;
    pointer-events: auto;
    box-shadow: 0 14px 40px rgba(0,0,0,0.75);
    backdrop-filter: blur(12px);
  }
  .pop-row {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    margin-bottom: 6px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    padding-bottom: 3px;
    gap: 12px;
  }
  .pop-label { color: rgba(226,232,240,0.62); }
  .pop-val { font-weight: 700; color: #f8fafc; text-align:right; }

  /* Table style for dynamic popups */
  .pop-table { width: 100%; border-collapse: collapse; font-size: 11px; }
  .pop-table td { padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.06); vertical-align: top; }
  .pop-table tr:last-child td { border-bottom: none; }
  .pop-table .k { color: rgba(226,232,240,0.6); width: 40%; }
  .pop-table .v { color: #fff; font-weight: 600; text-align: right; }

  #overviewModal, #layerInfoModal, #mcdaModal {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.80);
    backdrop-filter: blur(8px);
    z-index: 999;
    display: none;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
  }

  .modal-content {
    background: #0b1220;
    width: 780px;
    max-height: 85vh;
    overflow-y: auto;
    border-radius: 18px;
    border: 1px solid rgba(148,163,184,0.20);
    box-shadow: 0 24px 70px rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
  }
  .modal-content.small { width: 680px; }

  .modal-header {
    padding: 20px;
    border-bottom: 1px solid rgba(255,255,255,0.08);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(90deg, rgba(45, 212, 191, 0.10), transparent);
  }

  .modal-body { padding: 24px; color: rgba(226,232,240,0.80); font-size: 13px; line-height: 1.6; }
  .close-btn { background: none; border: none; color: rgba(226,232,240,0.55); font-size: 28px; cursor: pointer; }
  .close-btn:hover { color: white; }

  #toast {
    position: absolute;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(45, 212, 191, 0.92);
    color: #052e2a;
    padding: 8px 14px;
    border-radius: 999px;
    font-weight: 900;
    font-size: 12px;
    opacity: 0;
    transition: 0.25s;
    z-index: 300;
    pointer-events: none;
    box-shadow: 0 10px 24px rgba(0,0,0,0.35);
  }

  .compare-panel {
    margin-top: 10px;
    padding: 10px;
    background: rgba(0,0,0,0.32);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.28);
  }

  /* --------------------------------------------------------------------
     Panel collapse controls
     Small buttons allow the left and right panels to be hidden.  When
     collapsed the panel itself is hidden and a slim toggle appears at
     the edge of the viewport so it can be restored.  These styles
     govern the look of the collapse buttons and the toggle tabs.
  -------------------------------------------------------------------- */
  .collapse-btn {
    background: none;
    border: none;
    color: var(--text-sub);
    cursor: pointer;
    font-size: 14px;
    padding: 2px;
    transition: color 0.18s;
    pointer-events: auto;
  }
  .collapse-btn:hover {
    color: var(--primary);
  }
  #leftPanelToggle, #rightPanelToggle {
    position: absolute;
    top: 200px;
    z-index: 104;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    padding: 8px 6px;
    display: none;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    backdrop-filter: blur(12px);
    cursor: pointer;
    /* Ensure the toggle tabs can be clicked even though their parent has pointerâ€‘events: none */
    pointer-events: auto;
  }
  #leftPanelToggle {
    left: 0;
    border-radius: 0 12px 12px 0;
  }
  #rightPanelToggle {
    right: 0;
    border-radius: 12px 0 0 12px;
  }
  #leftPanelToggle i, #rightPanelToggle i {
    color: var(--primary);
    font-size: 14px;
  }
  .compare-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: rgba(226,232,240,0.62);
    margin-bottom: 6px;
  }
  .compare-row { margin-bottom: 8px; }
  .compare-label {
    font-size: 11px;
    color: var(--text-main);
    display: flex;
    justify-content: space-between;
    gap: 12px;
  }
  .compare-bars {
    margin-top: 4px;
    height: 6px;
    background: rgba(2,6,23,0.70);
    border-radius: 999px;
    overflow: hidden;
    position: relative;
    border: 1px solid rgba(255,255,255,0.06);
  }
  .compare-bar-before, .compare-bar-after { position: absolute; top: 0; bottom: 0; left: 0; }
  .compare-bar-before { background: rgba(148,163,184,0.50); }
  .compare-bar-after { background: rgba(45,212,191,0.90); opacity: 0.95; }
  .compare-delta { font-size: 10px; color: rgba(226,232,240,0.62); margin-top: 3px; }

  .rec-list { margin-top: 8px; display: flex; flex-direction: column; gap: 8px; }
  .rec-item {
    padding: 10px;
    background: rgba(15,23,42,0.55);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.22);
    font-size: 11px;
    cursor: pointer;
    transition: 0.18s;
  }
  .rec-item:hover { border-color: rgba(45,212,191,0.45); box-shadow: 0 0 0 3px rgba(45,212,191,0.08); }
  .rec-title { font-weight: 900; color: var(--text-main); margin-bottom: 2px; }
  .rec-meta { color: rgba(226,232,240,0.62); font-size: 10px; }

  .scenario-box{
    padding: 10px;
    background: rgba(0,0,0,0.25);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.22);
  }
  .scenario-types{
    display:flex;
    flex-wrap: wrap;
    gap:8px;
    margin-top:8px;
  }
  .sc-type{
    flex:1;
    border: 1px solid rgba(148,163,184,0.22);
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    padding: 8px 6px;
    font-size: 10px;
    color: rgba(226,232,240,0.65);
    cursor:pointer;
    text-align:center;
    user-select:none;
    transition: .18s;
  }
  .sc-type:hover{ border-color: rgba(45,212,191,0.45); color: white; }
  .sc-type.selected{
    border-color: rgba(45,212,191,0.75);
    color: white;
    background: rgba(45,212,191,0.10);
    box-shadow: 0 0 0 3px rgba(45,212,191,0.08);
  }
  .scenario-list{ display:flex; flex-direction:column; gap:8px; margin-top:10px; }
  .scenario-item{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:10px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(148,163,184,0.22);
    border-radius: 14px;
    font-size: 11px;
    color: var(--text-main);
  }
  .scenario-item small{ color: rgba(226,232,240,0.62); display:block; margin-top:2px; }
  .scenario-item button{
    border:none;
    background: rgba(251,113,133,0.12);
    color: rgba(254,202,202,0.95);
    border: 1px solid rgba(251,113,133,0.28);
    width: 34px; height: 34px;
    border-radius: 12px;
    cursor:pointer;
    transition:.18s;
  }
  .scenario-item button:hover{
    background: rgba(251,113,133,0.18);
    border-color: rgba(251,113,133,0.45);
  }

  #legendBox{
    margin-top: 12px;
    padding:10px;
    background: rgba(0,0,0,0.25);
    border-radius: 14px;
    border: 1px solid rgba(148,163,184,0.22);
  }
  #legendTitle{
    font-size:10px;
    color: rgba(226,232,240,0.62);
    text-transform:uppercase;
    margin-bottom:6px;
    letter-spacing:.7px;
  }
  .leg-row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    font-size:11px;
    color: rgba(226,232,240,0.78);
    padding:6px 0;
    border-bottom: 1px solid rgba(255,255,255,0.04);
  }
  .leg-row:last-child{ border-bottom:none; }
  .leg-chip{ display:flex; align-items:center; gap:8px; }
  .chip{
    width: 12px; height: 12px;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.20);
    flex-shrink:0;
  }
  .chip.line{ width: 18px; height: 3px; border-radius: 3px; border:none; }

  .mcda-grid{ display:grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 10px; }
  .mcda-card{ border: 1px solid rgba(148,163,184,0.22); border-radius: 14px; padding: 12px; background: rgba(255,255,255,0.03); }
  .mcda-card label{ display:block; font-size: 11px; color: rgba(226,232,240,0.80); margin-bottom: 6px; text-transform: uppercase; letter-spacing: .6px; }
  .mcda-card select, .mcda-card input{
    width: 100%;
    padding: 10px;
    border-radius: 12px;
    border: 1px solid rgba(148,163,184,0.22);
    background: rgba(2,6,23,0.55);
    color: rgba(226,232,240,0.92);
    outline: none;
    font-family: Inter, sans-serif;
    font-size: 12px;
  }
  .mcda-actions{ display:flex; gap: 10px; margin-top: 16px; }
  .mcda-actions button{
    flex:1;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(45,212,191,0.30);
    background: rgba(45,212,191,0.10);
    color: rgba(226,232,240,0.92);
    font-weight: 900;
    cursor: pointer;
    transition: .18s;
  }
  .mcda-actions button:hover{ border-color: rgba(45,212,191,0.60); background: rgba(45,212,191,0.14); }

  .hint-pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px dashed rgba(148,163,184,0.35);
    background: rgba(2,6,23,0.28);
    color: rgba(226,232,240,0.75);
    font-size: 11px;
    margin-top: 10px;
  }

  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: rgba(2,6,23,0.8); }
  ::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.35); border-radius: 6px; }
  ::-webkit-scrollbar-thumb:hover { background: rgba(45,212,191,0.60); }

  /* =======================================
     Assistant Chat Styles
     Provides a simple chat interface for the ecology assistant.
  ======================================= */
  #assistantContainer {
    position: absolute;
    right: 20px;
    bottom: 20px;
    width: 320px;
    max-height: 50vh;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    pointer-events: auto;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index: 500;
  }
  #assistantMessages {
    flex: 1;
    padding: 12px;
    overflow-y: auto;
  }
  .assistant-message {
    margin-bottom: 8px;
    font-size: 12px;
    line-height: 1.4;
  }
  .assistant-message.user {
    text-align: right;
    color: #bae6fd;
  }
  .assistant-message.bot {
    text-align: left;
    color: var(--text-main);
  }
  #assistantChips {
    padding: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  .assistant-chip {
    font-size: 10px;
    padding: 4px 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(148,163,184,0.25);
    border-radius: 999px;
    cursor: pointer;
    user-select: none;
    transition: 0.18s;
  }
  .assistant-chip:hover {
    border-color: var(--primary);
    background: rgba(45,212,191,0.20);
    color: white;
  }
  #assistantInputArea {
    display: flex;
    padding: 8px;
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  #assistantInput {
    flex: 1;
    padding: 6px 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(148,163,184,0.28);
    border-radius: 12px;
    color: var(--text-main);
    font-size: 12px;
    outline: none;
  }
  #assistantSend {
    margin-left: 6px;
    background: var(--primary);
    border: none;
    color: #0b1220;
    font-weight: 700;
    padding: 6px 10px;
    border-radius: 12px;
    cursor: pointer;
    transition: 0.18s;
  }
  #assistantSend:hover {
    background: var(--primary-hover);
  }

  /* === Custom additions for improved AI Assistant === */
  /* Make the assistant panel less transparent for better readability */
  #assistantContainer {
    background: rgba(15, 23, 42, 0.95);
  }
  /* Header bar within the assistant, showing title and a close button */
  #assistantHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(2, 6, 23, 0.85);
  }
  #assistantHeader .assistant-title {
    font-size: 13px;
    font-weight: 800;
    color: var(--text-main);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  #assistantHeader .assistant-title i {
    font-size: 14px;
  }
  #assistantClose {
    background: none;
    border: none;
    color: var(--text-sub);
    font-size: 18px;
    cursor: pointer;
    transition: 0.18s;
  }
  #assistantClose:hover {
    color: var(--primary);
  }

  /* Weather info icon to explain data sources and units */
  .weather-info-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin-left: 6px;
    font-size: 12px;
    color: rgba(226,232,240,0.8);
    cursor: help;
  }

  /* Small explanation text under charts */
  .chart-explanation {
    font-size: 10px;
    color: rgba(226,232,240,0.75);
    margin-top: 4px;
  }
  /* Floating toggle button for the assistant (collapsible like a messenger icon) */
  .assistant-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 52px;
    height: 52px;
    border-radius: 50%;
    background: var(--primary);
    /*
     * Use white for the assistant toggle icon/text so the suggestion
     * robot letter is clearly visible on the coloured button.  The
     * previous dark colour caused the glyph to blend with the button,
     * appearing almost transparent.
     */
    color: #ffffff;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
    cursor: pointer;
    z-index: 600;
  }
  .assistant-toggle:hover {
    background: var(--primary-hover);
  }
  /* Hide class to toggle visibility */
  .hide {
    display: none !important;
  }

  /* Suggestions dropdown for predictive ecological terms */
  #assistantSuggestions {
    padding: 8px;
    border-top: 1px solid rgba(255,255,255,0.06);
    max-height: 120px;
    overflow-y: auto;
    background: rgba(2, 6, 23, 0.85);
    display: none;
  }
  #assistantSuggestions .suggestion-item {
    padding: 6px 8px;
    font-size: 12px;
    border-radius: 8px;
    cursor: pointer;
    color: var(--text-main);
    transition: 0.18s;
  }
  #assistantSuggestions .suggestion-item:hover {
    background: rgba(45,212,191,0.20);
    color: var(--primary);
  }

  /* =======================================
     Readability fixes (NDVI / MCDA / modals)
     Ensures text is bright enough on dark panels.
  ======================================= */
  .assistant-message{ white-space: pre-line; }

  .modal-content, .modal-content * { color: rgba(248,250,252,0.90); }
  .modal-body { color: rgba(248,250,252,0.88); }
  .modal-body a { color: var(--primary); text-decoration: underline; }
  .modal-body code { color: #fff; background: rgba(255,255,255,0.06); padding:2px 6px; border-radius:8px; }

  #mcdaModal .mcda-card label { color: rgba(248,250,252,0.92); }
  #mcdaModal .mcda-card select, #mcdaModal .mcda-card input { color: rgba(248,250,252,0.95); }
  #mcdaModal .mcda-card select option { color: #0b1220; } /* keeps options readable in most browsers */

  #layerInfoBody, #layerInfoBody * { color: rgba(248,250,252,0.90); }

  /* MCDA enhancements */
  .mcda-sliders {
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .mcda-sliders .slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: var(--text-main);
  }
  .mcda-sliders .slider-row input[type=range] {
    flex: 1;
  }
  .mcda-sliders .slider-row input[type=number] {
    width: 80px;
    padding: 4px 6px;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--border);
    color: var(--text-main);
    border-radius: 4px;
  }
  .mcda-sliders .slider-row .value {
    width: 32px;
    text-align: right;
    font-size: 12px;
    color: var(--primary);
  }
  .mcda-note p {
    margin: 2px 0;
  }
</style>
</head>
<body>

<div id="cesiumContainer"></div>

<!-- hidden canvases used for raster probing -->
<canvas id="canvasNDVI" style="display:none;"></canvas>
<canvas id="canvasUHI" style="display:none;"></canvas>

  <!-- Ecology settings button and modal -->
  <div id="ecoSettingsBtn"><i class="fa-solid fa-gear"></i><span style="margin-left:6px;">Settings</span></div>
  <div id="eco-settings-overlay">
    <div id="eco-settings-modal">
      <h2>Ecology &amp; MCDA Settings</h2>
      <form id="eco-settings-form">
        <h3>MCDA Weights</h3>
        <div class="field"><label for="eco_weight_u">Urban heat mitigation weight (w<sub>U</sub>)</label><input type="number" step="0.01" id="eco_weight_u"></div>
        <div class="field"><label for="eco_weight_n">Vegetation deficit weight (w<sub>N</sub>)</label><input type="number" step="0.01" id="eco_weight_n"></div>
        <div class="field"><label for="eco_weight_c">Corridor proximity weight (w<sub>C</sub>)</label><input type="number" step="0.01" id="eco_weight_c"></div>
        <div class="field"><label for="eco_weight_a">Building age weight (w<sub>A</sub>)</label><input type="number" step="0.01" id="eco_weight_a"></div>
        <div class="field"><label for="eco_weight_r">Building area weight (w<sub>R</sub>)</label><input type="number" step="0.01" id="eco_weight_r"></div>
        <h3>CBA Parameters</h3>
        <div class="field"><label for="eco_discount">Discount rate (%)</label><input type="number" step="0.1" id="eco_discount"></div>
        <div class="field"><label for="eco_horizon">Horizon (years)</label><input type="number" step="1" id="eco_horizon"></div>
        <h3>Feasible Space Limits</h3>
        <div class="field"><label for="eco_max_roof">Max roof eligible (%)</label><input type="number" step="1" id="eco_max_roof"></div>
        <div class="field"><label for="eco_max_tree">Max tree area (mÂ²)</label><input type="number" step="1" id="eco_max_tree"></div>
        <h3>Unit Costs (â‚¬)</h3>
        <div class="field"><label for="eco_cost_tree">Tree planting cost (â‚¬/tree)</label><input type="number" step="1" id="eco_cost_tree"></div>
        <div class="field"><label for="eco_cost_roof">Green roof cost (â‚¬/mÂ²)</label><input type="number" step="1" id="eco_cost_roof"></div>
        <div class="field"><label for="eco_cost_infil">Infiltration strip cost (â‚¬/mÂ²)</label><input type="number" step="1" id="eco_cost_infil"></div>
      </form>
      <details>
        <summary>Show equations &amp; assumptions</summary>
        <div style="margin-top:8px; font-size:12px; line-height:1.5; color:var(--text-sub)">
          <p><strong>MCDA score:</strong> Score = w<sub>U</sub> Â· UHI + w<sub>N</sub> Â· Vegetation deficit + w<sub>C</sub> Â· Corridor proximity + w<sub>A</sub> Â· Age + w<sub>R</sub> Â· Area</p>
          <p><strong>NPV:</strong> âˆ‘<sub>t=1</sub><sup>T</sup> (Annual benefits)/(1â€¯+â€¯r)<sup>t</sup> âˆ’ Capex</p>
          <p><strong>BCR:</strong> Present value of benefits Ã· Capex</p>
          <p><strong>Budgets:</strong> Feasible space and budget caps limit the maximum area or funds allocated to interventions.</p>
        </div>
      </details>
      <details>
        <summary>Stakeholders &amp; user stories</summary>
        <div style="margin-top:8px; font-size:12px; line-height:1.5; color:var(--text-sub)">
          <p><strong>Stakeholders:</strong> residents, local businesses, schools, NGOs, municipality, utilities.</p>
          <p><strong>Users:</strong> municipal planners, sustainability officers, housing association asset managers, consultants/researchers.</p>
          <p><strong>User story 1:</strong> A municipal planner adjusts weights and budgets to compare greening scenarios under a â‚¬X budget.</p>
          <p><strong>User story 2:</strong> A housing corporation prioritises buildings for facade greening and green roofs based on MCDA weights.</p>
          <p><strong>User story 3:</strong> A community group explores tree planting options and tradeâ€‘offs using customised weights.</p>
        </div>
      </details>
      <div class="button-row">
        <button type="button" id="eco-settings-apply" class="save-btn">Apply</button>
        <button type="button" id="eco-settings-cancel" class="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>


<div id="uiLayer">

  <div class="top-bar">
    <i class="fas fa-leaf" style="color:var(--primary)"></i>
    <span class="app-title">Ecology Digital Twin <span style="font-weight:500; opacity:0.65;">| Twekkelerveld</span></span>
    <div style="width:1px; height:15px; background:rgba(255,255,255,0.16);"></div>
    <button class="btn-overview" onclick="openOverview()">
      <i class="fas fa-info-circle"></i> Ecological Overview
    </button>

    <!-- Reset view button to return to the study area when users get lost -->
    <button class="btn-overview" onclick="resetToStudyArea()" title="Zoom to study area">
      <i class="fa-solid fa-crosshairs"></i> Reset View
    </button>

    <!-- Weather widget shows current temperature and countdown to the next snowfall or heat event -->
    <div id="weatherWidget" class="weather-widget" onclick="showWeatherDetails()" style="cursor:pointer;">
      <span id="weatherTemp">--Â°C</span>
      <div class="weather-bar">
        <div id="weatherBarFill" class="weather-bar-fill"></div>
      </div>
      <span id="weatherEvent" style="font-size:10px; opacity:0.8;">Loadingâ€¦</span>
    </div>

    <!-- Info icon explaining where numbers come from and what they mean -->
    <i class="fa-solid fa-circle-info weather-info-icon" id="weatherInfoIcon"
       onclick="showWeatherDetails()"
       title="Data source: Openâ€‘Meteo weather and air quality API.\nAQI (European Air Quality Index) is calculated based on concentrations of up to five pollutants â€” PMâ‚â‚€, PMâ‚‚.â‚…, NOâ‚‚, Oâ‚ƒ and SOâ‚‚ â€” and reflects the pollutant with the poorest concentration.\nUnits: temperature in Â°C, humidity in %, AQI is a dimensionless index."></i>
  </div>

  <div class="panel" id="leftPanel">
    <!-- Collapse button for left panel -->
    <button class="collapse-btn" onclick="toggleLeftPanel()" title="Collapse left panel" style="align-self:flex-end;"><i class="fa-solid fa-chevron-left"></i></button>
    <h3>Layers</h3>

    <!-- Layer 1: Open Data (Renamed file) -->
    <div class="layer-item" onclick="toggleLayer('trees_open')">
      <div class="layer-label"><i class="fas fa-tree" style="color:#2dd4bf"></i> Tree Inventory (Open)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('trees_open', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-trees_open"></div>
      </div>
    </div>

    <!-- Layer 2: Municipality Data (New) -->
    <div class="layer-item" onclick="toggleLayer('trees_muni')">
      <div class="layer-label"><i class="fas fa-tree" style="color:#60a5fa"></i> Tree Points (Muni)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('trees_muni', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-trees_muni"></div>
      </div>
    </div>

    <div class="layer-item" onclick="toggleLayer('greenery')">
      <div class="layer-label"><i class="fas fa-vector-square" style="color:#99f6e4"></i> Green Spaces</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('greenery', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-greenery"></div>
      </div>
    </div>

    <div class="layer-item" onclick="toggleLayer('buildings3d')">
      <div class="layer-label"><i class="fas fa-building" style="color:#e5e7eb"></i> Buildings (LOD 2.2)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('buildings3d', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch active" id="sw-buildings3d"></div>
      </div>
    </div>

    <div style="width:100%; height:1px; background:rgba(255,255,255,0.10); margin:10px 0;"></div>
    <h3>Advanced Metrics</h3>

    <div class="layer-item" onclick="toggleLayer('corridors')">
      <div class="layer-label"><i class="fas fa-route" style="color:#fbbf24"></i> Wellâ€‘being Corridors</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('corridors', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch" id="sw-corridors"></div>
      </div>
    </div>

    <!-- Heat-Stress Priority Layer removed (functionality intentionally disabled) -->

    <div class="layer-item" onclick="toggleLayer('heatmap')">
      <div class="layer-label"><i class="fas fa-fire" style="color:#ef4444"></i> Heatmap (UHI)</div>
      <div class="layer-actions">
        <button class="info-btn" onclick="openLayerInfo('heatmap', event)"><i class="fa-solid fa-circle-info"></i></button>
        <div class="switch" id="sw-heatmap"></div>
      </div>
    </div>

    <div id="legendBox">
      <div id="legendTitle">Legend</div>
      <div id="legendBody"></div>
    </div>
  </div>

  <!-- Right Panel: Static, no collapse button -->
  <div class="panel" id="rightPanel">
    <div class="panel-top">
      <div class="panel-title">
        <i class="fa-solid fa-sliders" style="color:var(--primary)"></i>
        <span>Urban Forest Simulator</span>
      </div>
      <!-- Collapse button for right panel -->
      <button class="collapse-btn" onclick="toggleRightPanel()" title="Collapse right panel"><i class="fa-solid fa-chevron-right"></i></button>
    </div>

    <div class="panel-content" id="rightPanelContent">
      <div class="stats-row">
        <div class="stat-box">
          <div class="stat-num" id="valTrees" style="color:var(--gold)">0</div>
          <div class="stat-name">New Trees</div>
        </div>
        <div class="stat-box">
          <div class="stat-num" id="valFacades" style="color:#22c55e">0</div>
          <div class="stat-name">Green Facades</div>
        </div>
      </div>

      <h3>Performance Trade-offs</h3>
        <div style="height:150px; position:relative;">
          <canvas id="tradeoffChart"></canvas>
          <!-- Explanation beneath the radar chart clarifying normalisation -->
          <div class="chart-explanation">Scores are normalised between 0 and 100. Higher values indicate greater positive impact.</div>
        </div>
      <button class="small-btn" onclick="downloadCharts()">
        <i class="fas fa-download"></i> Download Chart
      </button>


      <h3>Financial Tradeoffs</h3>
      <div class="scenario-box" style="margin-top:-4px;">
        <div style="font-size:11px;color:rgba(226,232,240,0.80);">
          Enter a budget and objective â†’ get a plan with clear tradeâ€‘offs. (This is advisory; you still place trees/facades/polygons on the map.)
        </div>
        <div class="mcda-grid" style="grid-template-columns: 1fr 1fr; margin-top:10px;">
          <div class="mcda-card">
            <label>Budget (â‚¬)</label>
            <input id="budgetInput" type="number" min="0" step="50" value="1000" />
          </div>
          <div class="mcda-card">
            <label>Objective</label>
            <select id="budgetObjective">
              <option value="balanced" selected>Balanced</option>
              <option value="cooling">Cooling (reduce heat)</option>
              <option value="carbon">COâ‚‚</option>
              <option value="biodiversity">Biodiversity</option>
              <option value="stormwater">Stormwater</option>
            </select>
          </div>
        </div>
        <div class="mcda-actions" style="margin-top:12px;">
          <button onclick="runBudgetPlanner()"><i class="fa-solid fa-scale-balanced"></i> Suggest Plan</button>
          <button onclick="clearBudgetPlanner()"><i class="fa-solid fa-eraser"></i> Clear</button>
        </div>
        <div id="budgetResults" style="margin-top:10px;font-size:11px;color:rgba(226,232,240,0.82); line-height:1.55;"></div>
      </div>


      <h3>Select Tree Species</h3>
      <div class="species-grid">
        <div class="species-opt selected" onclick="selectSpecies('oak', this)">
          <span class="spec-icon" style="color:#fbbf24">ðŸŒ³</span>
          <span class="spec-name">Oak</span>
          <span class="spec-cost">â‚¬250</span>
        </div>
        <div class="species-opt" onclick="selectSpecies('birch', this)">
          <span class="spec-icon" style="color:#fb923c">ðŸŒ¿</span>
          <span class="spec-name">Birch</span>
          <span class="spec-cost">â‚¬100</span>
        </div>
        <div class="species-opt" onclick="selectSpecies('pine', this)">
          <span class="spec-icon" style="color:#bef264">ðŸŒ²</span>
          <span class="spec-name">Pine</span>
          <span class="spec-cost">â‚¬150</span>
        </div>
      </div>

      <button id="btnPlant" onclick="togglePlanting()">
        <i class="fas fa-plus-circle"></i> Plant Selected Tree
      </button>

      <h3 style="margin-top:10px;">Select Green Facade Type</h3>
      <div class="species-grid">
        <div class="species-opt selected" onclick="selectFacadeType('ivy', this)">
          <span class="spec-icon" style="color:#22c55e">ðŸª´</span>
          <span class="spec-name">Ivy</span>
          <span class="spec-cost">â‚¬3.5k</span>
        </div>
        <div class="species-opt" onclick="selectFacadeType('livingwall', this)">
          <span class="spec-icon" style="color:#16a34a">ðŸ§±</span>
          <span class="spec-name">Living Wall</span>
          <span class="spec-cost">â‚¬6k</span>
        </div>
        <div class="species-opt" onclick="selectFacadeType('trellis', this)">
          <span class="spec-icon" style="color:#84cc16">ðŸŒ¿</span>
          <span class="spec-name">Trellis</span>
          <span class="spec-cost">â‚¬2k</span>
        </div>
      </div>

      <button id="btnFacade" onclick="toggleFacading()">
        <i class="fa-solid fa-square-plus"></i> Apply Green Facade (click a building)
      </button>

      <button onclick="downloadReport()" class="small-btn" style="border-style:dashed;">
        <i class="fas fa-file-alt"></i> Download PDF Report (with Map Snapshot)
      </button>

      <button onclick="exportScenarioGeoJSON()" class="small-btn">
        <i class="fa-solid fa-file-code"></i> Export Scenario GeoJSON
      </button>

      <!-- Impact Overview Gauges -->
      <h3>Impact Overview</h3>
      <div id="gaugeGrid" class="gauge-grid">
        <!-- COâ‚‚ Sequestration Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeCo2"></canvas>
          <div class="gauge-value" id="gaugeCo2Value">0</div>
          <div class="gauge-caption">COâ‚‚</div>
        </div>
        <!-- Stormwater Runoff Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeWater"></canvas>
          <div class="gauge-value" id="gaugeWaterValue">0</div>
          <div class="gauge-caption">Water</div>
        </div>
        <!-- Cooling Effect Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeUhi"></canvas>
          <div class="gauge-value" id="gaugeUhiValue">0</div>
          <div class="gauge-caption">Cooling</div>
        </div>
        <!-- Investment Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeCost"></canvas>
          <div class="gauge-value" id="gaugeCostValue">0</div>
          <div class="gauge-caption">Investment</div>
        </div>

        <!-- Biodiversity Gauge -->
        <div class="gauge-box">
          <canvas id="gaugeBio"></canvas>
          <div class="gauge-value" id="gaugeBioValue">0</div>
          <div class="gauge-caption">Biodiversity</div>
        </div>
      </div>

      <!-- Secondary metric (temporary tree removal cost) remains below gauges -->
      <div class="pop-row">
        <span class="pop-label">Tree Removal Temp Cost</span>
        <span class="pop-val" id="valCutTemp" style="color:#f87171">+0.000Â°C</span>
      </div>

      <!-- Growth Projection: shows low/medium/high projections for selected municipal trees -->
      <h3 id="growthHeader" style="margin-top:10px; display:none;">Growth Projection <i class="fa-solid fa-circle-info" style="margin-left:6px; font-size:13px; cursor:pointer;" onclick="openLayerInfo('growthProjection', event)"></i></h3>
      <div id="growthPanel" style="display:none;">
        <div class="pop-row">
          <span class="pop-label">DBH Increment</span>
          <span class="pop-val" id="valDbhGrowth">â€”</span>
        </div>
        <div class="pop-row">
          <span class="pop-label">AGB Next (kg)</span>
          <span class="pop-val" id="valAgbGrowth">â€”</span>
        </div>
        <div class="pop-row">
          <span class="pop-label">COâ‚‚ Next (kg/yr)</span>
          <span class="pop-val" id="valCo2Growth">â€”</span>
        </div>
      </div>

      <div class="compare-panel" id="comparePanel">
        <div class="compare-header">
          <span>Scenario Comparison</span>
          <button class="small-btn" style="width:auto;padding:6px 10px;font-size:10px;margin-top:0;" onclick="toggleCompare()">
            Toggle
          </button>
        </div>
        <div id="compareBody">
          <div class="compare-row">
            <div class="compare-label">
              <span>COâ‚‚ Sequestration</span>
              <span id="cmpCo2Text">Baseline 0 â†’ 0</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpCo2Before"></div>
              <div class="compare-bar-after" id="cmpCo2After"></div>
            </div>
            <div class="compare-delta" id="cmpCo2Delta"></div>
          </div>

          <div class="compare-row">
            <div class="compare-label">
              <span>Cooling (UHI)</span>
              <span id="cmpUhiText">Baseline 0 â†’ 0Â°C</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpUhiBefore"></div>
              <div class="compare-bar-after" id="cmpUhiAfter"></div>
            </div>
            <div class="compare-delta" id="cmpUhiDelta"></div>
          </div>

          <div class="compare-row">
            <div class="compare-label">
              <span>Stormwater</span>
              <span id="cmpWaterText">Baseline 0 â†’ 0 L/yr</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpWaterBefore"></div>
              <div class="compare-bar-after" id="cmpWaterAfter"></div>
            </div>
            <div class="compare-delta" id="cmpWaterDelta"></div>
          </div>

          <div class="compare-row">
            <div class="compare-label">
              <span>Investment</span>
              <span id="cmpCostText">Baseline â‚¬0 â†’ â‚¬0</span>
            </div>
            <div class="compare-bars">
              <div class="compare-bar-before" id="cmpCostBefore"></div>
              <div class="compare-bar-after" id="cmpCostAfter"></div>
            </div>
            <div class="compare-delta" id="cmpCostDelta"></div>
          </div>
        </div>
      </div>

      <h3>Intervention Prioritization (MCDA)</h3>
      <button class="small-btn" onclick="openMCDA()">
        <i class="fas fa-compass"></i> Decision Support Wizard
      </button>
      <div id="recList" class="rec-list">
        <div class="rec-item">
          <div class="rec-title">No priorities yet</div>
          <div class="rec-meta">Uses building attributes (hidden) + UHI + NDVI + corridor proximity. Run the wizard.</div>
        </div>
      </div>

      <h3>Draw Greenery Scenario</h3>
      <div class="scenario-box">
        <div style="font-size:11px;color:rgba(226,232,240,0.80);">
          Draw a polygon anywhere â†’ choose greenery type â†’ updates biodiversity proxy + cooling + stormwater.
        </div>

        <div class="scenario-types">
          <div class="sc-type selected" id="sc-grass" onclick="selectScenarioType('grass', this)">ðŸŒ± Grass</div>
          <div class="sc-type" id="sc-shrubs" onclick="selectScenarioType('shrubs', this)">ðŸŒ¿ Shrubs</div>
          <div class="sc-type" id="sc-trees" onclick="selectScenarioType('trees', this)">ðŸŒ³ Trees</div>
          <div class="sc-type" id="sc-mixed" onclick="selectScenarioType('mixed', this)">ðŸŒ¾ Mixed</div>
          <!-- Additional intervention types -->
          <div class="sc-type" id="sc-raingarden" onclick="selectScenarioType('raingarden', this)">ðŸ’§ Rain&nbsp;Garden</div>
          <div class="sc-type" id="sc-greenroof" onclick="selectScenarioType('greenroof', this)">ðŸ  Green&nbsp;Roof</div>
          <div class="sc-type" id="sc-permeable" onclick="selectScenarioType('permeable', this)">ðŸ›£ï¸ Permeable</div>
          <div class="sc-type" id="sc-shading" onclick="selectScenarioType('shading', this)">ðŸ–ï¸ Shading</div>
          <div class="sc-type" id="sc-removeimpervious" onclick="selectScenarioType('removeimpervious', this)">ðŸš§ Remove&nbsp;Impervious</div>
        </div>

        <div class="hint-pill"><i class="fa-solid fa-pencil"></i> Tip: In draw mode, hold <b>SHIFT</b> and drag = smooth freehand </div>

        <button class="small-btn" onclick="startPolygonDraw()">
          <i class="fa-solid fa-pencil"></i> Start Draw
        </button>
        <button class="small-btn" onclick="cancelPolygonDraw()">
          <i class="fa-solid fa-xmark"></i> Cancel Drawing
        </button>

        <div class="scenario-list" id="scenarioList"></div>
      </div>

      <button id="btnUndo" class="small-btn" onclick="undoRemoval()">
        <i class="fas fa-undo"></i> Undo Last Action
      </button>
    </div>
  </div>

  <div id="bottomPanel">
    <h3><i class="fas fa-clock"></i> Temporal & Physics Simulation</h3>

    <div class="slider-container">
      <i class="fas fa-seedling" style="width:15px; text-align:center;"></i>
      <!-- Growth Projection label with info button -->
      <span>Growth Projection</span>
      <!-- Info button opens the growth projection definition modal -->
      <button class="info-btn" onclick="openLayerInfo('growthProjection', event)" title="How is growth projection calculated?" style="margin-left:6px; width:26px; height:26px;">
        <i class="fa-solid fa-circle-info"></i>
      </button>
      <input type="range" min="1" max="30" value="1" id="sliderYear" oninput="updateGrowth(this.value)">
      <span class="slider-val" id="lblYear">Year 1</span>
    </div>

    <div class="slider-container">
      <i class="fas fa-sun" style="width:15px; text-align:center; color:#fbbf24;"></i>
      <span>Shadow Time</span>
      <input type="range" min="0" max="23" step="0.5" value="12" id="sliderTime" oninput="updateSun(this.value)">
      <span class="slider-val" id="lblTime">12:00</span>
    </div>

    <div class="slider-container">
      <i class="fa-solid fa-cloud-sun" style="width:15px; text-align:center; color:#fbbf24;"></i>
      <span>Shadows</span>
      <input type="range" min="0" max="1" step="1" value="1" id="shadowToggle" oninput="toggleShadowsFromSlider(this.value)">
      <span class="slider-val" id="lblShadows">ON</span>
    </div>
      <!-- Hint below the sliders explaining how the shadow tool works -->
      <div class="hint-pill" style="margin-top:6px;">
        <i class="fa-solid fa-lightbulb"></i> Turn on shadows and adjust the shadow time slider to see shaded areas. This feature provides visual guidance only and is not a validated analysis.
      </div>
  </div>

  <!--
    Toggle tabs for collapsing panels.  These elements remain hidden until a
    panel is collapsed.  When a panel is hidden, its corresponding toggle
    appears on the edge of the viewport; clicking it will restore the
    panel.  Left panel toggle shows a rightâ€‘facing chevron; right panel
    toggle shows a leftâ€‘facing chevron.
  -->
  <div id="leftPanelToggle" onclick="toggleLeftPanel()"><i class="fa-solid fa-chevron-right"></i></div>
  <div id="rightPanelToggle" onclick="toggleRightPanel()"><i class="fa-solid fa-chevron-left"></i></div>
</div>

<!-- Assistant Chat Container: provides a naturalâ€‘language interface for the ecology twin -->
  <!-- Updated assistant container with header and collapsible functionality -->
  <div id="assistantContainer" class="hide">
    <div id="assistantHeader">
      <span class="assistant-title"><i class="fa-solid fa-robot"></i> AI Assistant</span>
      <button id="assistantClose">Ã—</button>
    </div>
    <!-- Disclaimer clarifying the AIâ€™s scope and limitations -->
    <div id="assistantDisclaimer" style="padding:6px 12px; font-size:10px; color: rgba(226,232,240,0.72); border-bottom: 1px solid rgba(255,255,255,0.08);">
      This assistant provides explanations and suggestions only. It does not generate geometry, validate policy decisions, or guarantee investment outcomes.
    </div>
    <div id="assistantMessages"></div>
    <div id="assistantChips"></div>
    <div id="assistantSuggestions"></div>
    <div id="assistantInputArea">
      <input type="text" id="assistantInput" placeholder="Ask the ecology assistant..." />
      <button id="assistantSend">Send</button>
    </div>
  </div>
  <!-- Floating toggle to show/hide the assistant -->
  <button id="assistantToggle" class="assistant-toggle"><i class="fa-solid fa-robot"></i></button>

<div id="overviewModal">
  <div class="modal-content">
    <div class="modal-header">
      <span style="font-size:18px; font-weight:900; color:white;">Detailed Ecological Summary</span>
      <button class="close-btn" onclick="closeOverview()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="report-section">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fas fa-temperature-high"></i> 1. Urban Heat Island (UHI)
        </div>
        <p><strong>Description:</strong> The Urban Heat Island (UHI) layer uses surface temperature proxies to highlight pockets of heat across the city. It shows relative temperatures based on the underlying raster; cooler areas appear green while hotter areas trend toward browns. UHI arises from heatâ€‘absorbing materials, limited vegetation and anthropogenic heat sources.</p>
        <p><strong>Priority rule:</strong> This digital twin uses UHI values above 35Â Â°C combined with NDVI below 0.20 at a buildingâ€™s centroid to flag heatâ€‘stressed buildings for cooling interventions.</p>
        <p><strong>Analysis tip:</strong> Overlay the UHI heatmap with vegetation (NDVI) to quickly identify where planting trees or installing green roofs can reduce temperatures.</p>
      </div>

      <div class="report-section">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fas fa-route"></i> 2. Wellâ€‘being Corridors & Movement
        </div>
        <p><strong>Description:</strong> Wellâ€‘being corridors are polylines linking parks and other green spaces to illustrate ecological connectivity and provide walkable routes for residents. Connected habitats improve genetic diversity and species richness, and corridors reduce plant extinction rates while boosting colonisation and mental wellâ€‘being.</p>
        <p><strong>Dynamic arrows:</strong> The corridor lines feature animated arrowheads moving along the direction of travel. These arrows symbolise flow and make it easier to see the intended direction of ecological or pedestrian movement.</p>
        <p><strong>Use case:</strong> Turn on wellâ€‘being corridors together with green spaces to understand how parks, lawns and trees can be connected into continuous networks that benefit both biodiversity and human wellâ€‘being.</p>
      </div>

      <div class="report-section">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fa-solid fa-draw-polygon"></i> 3. Scenario Polygons (Smooth Draw)
        </div>
        <p><strong>Functionality:</strong> Scenario polygons let you draw intervention areas for grass, shrubs, trees or mixed vegetation. The drawing is smoothed automatically to produce natural boundaries.</p>
        <p><strong>Impacts:</strong> Each vegetation type modifies NDVI, cooling effect, stormwater infiltration and biodiversity proxies based on predefined parameters. After drawing, gauges and comparison panels update to reflect your scenarioâ€™s ecological benefits.</p>
        <p><strong>Tip:</strong> Use mixed vegetation to balance cooling, biodiversity and water management, or experiment with different types to see tradeâ€‘offs.</p>
      </div>

      <div class="report-section" style="border:none;">
        <div class="report-title" style="color:var(--primary); font-size:16px; font-weight:900; margin-bottom:10px;">
          <i class="fa-solid fa-city"></i> 4. 3D Context + Shadows
        </div>
        <p><strong>Details:</strong> Levelâ€‘ofâ€‘DetailÂ 2.2 (LODÂ 2.2) models offer realistic roof and wall geometry for buildings. They provide context for proposed interventions and allow shadowâ€‘casting simulations.</p>
        <p><strong>Hidden attributes:</strong> Each building contains metadata such as BAG ID, construction year and footprint area (from the LODÂ 1 layer). Select a building to reveal these attributes in the popup.</p>
        <p><strong>Shadows:</strong> Shadows are computed in real time. Use them to assess how building form and orientation influence potential tree planting and facade greening.</p>
      </div>
    </div>
  </div>
</div>

<div id="layerInfoModal">
  <div class="modal-content small">
    <div class="modal-header">
      <span id="layerInfoTitle" style="font-size:18px; font-weight:900; color:white;">Layer Info</span>
      <button class="close-btn" onclick="closeLayerInfo()">Ã—</button>
    </div>
    <div class="modal-body" id="layerInfoBody"></div>
  </div>
</div>

<div id="mcdaModal">
  <div class="modal-content small">
    <div class="modal-header">
      <span style="font-size:18px; font-weight:900; color:white;">Decision Support Wizard (MCDA)</span>
      <!-- Added info icon providing plain language explanation -->
      <details class="mcda-info" style="display:inline-block;margin-left:6px;">
        <summary style="list-style:none; cursor:pointer;">
          <i class="fa-solid fa-circle-info" style="color:var(--primary); font-size:14px;"></i>
        </summary>
        <div style="background:rgba(2,6,23,0.95); border:1px solid var(--border); padding:10px; border-radius:8px; max-width:300px; font-size:11px; color:var(--text-sub); position:absolute; z-index:1000;">
          <p style="margin-top:0;"><strong>How it works:</strong> The wizard ranks buildings by combining five criteria â€” UHI, vegetation deficit, proximity to green corridors, building age and footprint area â€” into a single score. Each criterion is first <em>normalized</em> to a 0â€“1 range so that different units are comparable. You then assign <em>weights</em> to indicate relative importance. The final score is a weighted sum of the normalized values (this method is called a <em>weighted linear combination</em>). Weights are automatically scaled to sum to one before scoring. See <a href="https://www.inowas.com/tools/t05-gis-mcda/#5" target="_blank">WLC guidance</a>, <a href="https://knowledge4policy.ec.europa.eu/composite-indicators/toolkit_en/navigation-page/10-step-guide_en/step-5-normalisation_en" target="_blank">normalisation guidelines</a> and <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC6011778/" target="_blank">weighting best practice</a> for details.</p>
        </div>
      </details>
      <button class="close-btn" onclick="closeMCDA()">Ã—</button>
    </div>
    <div class="modal-body">
      <div style="color:rgba(226,232,240,0.80); font-size:12px;">
        Prioritizes buildings for interventions using UHI, NDVI, corridor proximity, footprint area and building age (attributes remain hidden).
      </div>

      <div class="mcda-grid">
        <div class="mcda-card">
          <label>Primary Objective</label>
          <select id="mcdaObjective">
            <option value="cooling">Cooling (reduce heat)</option>
            <option value="biodiversity">Biodiversity</option>
            <option value="stormwater">Stormwater reduction</option>
            <option value="balanced" selected>Balanced</option>
          </select>
        </div>

        <div class="mcda-card">
          <label>Corridor Importance</label>
          <select id="mcdaCorridor">
            <option value="low">Low</option>
            <option value="high" selected>High</option>
          </select>
        </div>

        <div class="mcda-card">
          <label>Budget Level</label>
          <select id="mcdaBudget">
            <option value="low">Low (prefer grass/shrubs)</option>
            <option value="medium" selected>Medium (mixed)</option>
            <option value="high">High (trees + facades)</option>
          </select>
        </div>

        <div class="mcda-card">
          <label>How many priorities?</label>
          <input id="mcdaTopN" type="number" min="1" max="15" value="5" />
        </div>
      </div>

      <!-- New: MCDA weight sliders and budget controls -->
      <div class="mcda-sliders">
        <div class="slider-row">
          <label for="mcdaWeightU">UHI weight (w<sub>U</sub>)</label>
          <input type="range" id="mcdaWeightU" min="0" max="1" step="0.05" value="0.46" oninput="updateMcdaWeightLabel('mcdaWeightU','mcdaWeightUVal')">
          <span id="mcdaWeightUVal" class="value">0.46</span>
        </div>
        <div class="slider-row">
          <label for="mcdaWeightN">Vegetation deficit weight (w<sub>N</sub>)</label>
          <input type="range" id="mcdaWeightN" min="0" max="1" step="0.05" value="0.28" oninput="updateMcdaWeightLabel('mcdaWeightN','mcdaWeightNVal')">
          <span id="mcdaWeightNVal" class="value">0.28</span>
        </div>
        <div class="slider-row">
          <label for="mcdaWeightC">Corridor proximity weight (w<sub>C</sub>)</label>
          <input type="range" id="mcdaWeightC" min="0" max="1" step="0.05" value="0.10" oninput="updateMcdaWeightLabel('mcdaWeightC','mcdaWeightCVal')">
          <span id="mcdaWeightCVal" class="value">0.10</span>
        </div>
        <div class="slider-row">
          <label for="mcdaWeightA">Building age weight (w<sub>A</sub>)</label>
          <input type="range" id="mcdaWeightA" min="0" max="1" step="0.05" value="0.08" oninput="updateMcdaWeightLabel('mcdaWeightA','mcdaWeightAVal')">
          <span id="mcdaWeightAVal" class="value">0.08</span>
        </div>
        <div class="slider-row">
          <label for="mcdaWeightR">Footprint area weight (w<sub>R</sub>)</label>
          <input type="range" id="mcdaWeightR" min="0" max="1" step="0.05" value="0.08" oninput="updateMcdaWeightLabel('mcdaWeightR','mcdaWeightRVal')">
          <span id="mcdaWeightRVal" class="value">0.08</span>
        </div>
        <div class="slider-row">
          <label for="mcdaCorrFactor">Corridor importance factor</label>
          <input type="number" id="mcdaCorrFactor" min="0" max="2" step="0.1" value="1">
          <span></span>
        </div>
        <div class="slider-row">
          <label for="mcdaMaxTrees">Max trees/interventions</label>
          <input type="number" id="mcdaMaxTrees" min="1" step="1" value="">
          <span></span>
        </div>
        <div class="slider-row">
          <label for="mcdaMaxArea">Max area (mÂ²)</label>
          <input type="number" id="mcdaMaxArea" min="1" step="1" value="">
          <span></span>
        </div>
      </div>

      <div class="mcda-note" style="margin-top:8px; font-size:10px; color:rgba(226,232,240,0.62);">
        <p style="margin:4px 0;">Normalization note: Each criterion is scaled to a 0â€“1 range so that different units (Â°C, NDVI deficit, age, area) are comparable. Higher values correspond to higher priority for all criteria shown here (UHI, vegetation deficit, corridor proximity, age, footprint).</p>
      </div>

      <!-- Assumptions & equations panel -->
      <details style="margin-top:8px; font-size:10px; color:rgba(226,232,240,0.62);">
        <summary>Show MCDA assumptions &amp; equations</summary>
        <div style="margin-top:6px;">
          <p><strong>Criteria &amp; direction:</strong> UHI (Â°C, benefit), vegetation deficit (unitless, benefit), corridor proximity (0/1, benefit), age (years, benefit), footprint area (mÂ², benefit).</p>
          <p><strong>Normalization:</strong> For each criterion \(x_{s,j}\), compute a normalized value \(x'_{s,j}\) on 0â€“1 scale. For benefit criteria: \(x'_{s,j} = (x_{s,j} - \min(x_j)) / (\max(x_j) - \min(x_j))\). For cost criteria: \(x'_{s,j} = (\max(x_j) - x_{s,j}) / (\max(x_j) - \min(x_j))\).</p>
          <p><strong>Weighted linear combination:</strong> The overall score is \(S_s = \sum_j w_j \cdot x'_{s,j}\) where weights \(w_j\) sum to 1. Adjust the sliders to change weights; they are normalized internally.</p>
          <p><strong>Spatial de-clustering:</strong> The algorithm ensures recommended buildings are spread out by enforcing a minimum distance between selected priorities.</p>
          <p><strong>No double counting:</strong> Each criterion captures a distinct aspect (temperature mitigation, vegetation deficit, corridor proximity, age and footprint). MCDA best practice recommends avoiding highly correlated criteria to prevent double counting.</p>
          <p style="margin-top:6px;"><em>References:</em> Weighted linear combination method explanation, normalisation to avoid â€œapples vs pearsâ€ comparisons and weighting guidance where importance weights are scaled to 0â€“1 and sum to one.</p>
        </div>
      </details>

      <div class="mcda-actions">
        <button onclick="runMCDA()"><i class="fa-solid fa-wand-magic-sparkles"></i> Generate Priorities</button>
        <button onclick="clearMCDA()"><i class="fa-solid fa-eraser"></i> Clear Markers</button>
        <button onclick="exportMCDA('csv')"><i class="fa-solid fa-download"></i> Export CSV</button>
        <button onclick="exportMCDA('json')"><i class="fa-solid fa-download"></i> Export JSON</button>
        <button onclick="sensitivityTest()"><i class="fa-solid fa-chart-line"></i> Sensitivity Â±20%</button>
      </div>

      <div style="margin-top:12px; font-size:11px; color:rgba(226,232,240,0.62);">
        Score uses: (UHI high) + (NDVI low) + (corridor proximity) + (age) + (footprint area). Results are also spatially de-clustered.
      </div>
    </div>
  </div>
</div>

<!-- Weather details pop-up (appears when clicking the weather bar) -->
<div id="weatherModal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width:320px; background: var(--panel-bg); border: 1px solid var(--border); border-radius: 14px; padding: 20px; font-size:14px; z-index: 500; display: none; box-shadow: 0 10px 28px rgba(0,0,0,0.45); backdrop-filter: blur(12px);">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <span style="font-size:14px; font-weight:800; color: var(--text-main);">Weather Details</span>
    <button onclick="closeWeatherModal()" style="background:none; border:none; color: rgba(226,232,240,0.65); font-size:18px; cursor:pointer; line-height:1;">Ã—</button>
  </div>
  <div id="weatherDetailContent" style="margin-top:8px; font-size:12px;"></div>
</div>

<div id="ecoPopup">
  <div class="pop-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
    <h3 id="popType" class="pop-title" style="color:rgba(45, 212, 191, 0.95); margin:0; border:none; padding:0;">Object</h3>
    <button style="background:none; border:none; color:rgba(226,232,240,0.65); font-size:18px; cursor:pointer;" onclick="closePopup()">Ã—</button>
  </div>
  <div id="popContent"></div>
</div>

<div id="toast">Action Complete</div>

<script>
/* ===========================================================
   CRITICAL FIX: Cesium Property Guard
=========================================================== */
(function(){
  const P = Cesium.Property;
  if(!P || P.__guarded) return;
  P.__guarded = true;

  const orig1 = P.getValueOrDefault;
  P.getValueOrDefault = function(property, time, defaultValue, result){
    if(property === null || property === undefined) return defaultValue;
    if(typeof property.getValue === "function") return orig1(property, time, defaultValue, result);
    return property;
  };

  const orig2 = P.getValueOrClonedDefault;
  P.getValueOrClonedDefault = function(property, time, defaultValue, result){
    if(property === null || property === undefined) return defaultValue;
    if(typeof property.getValue === "function") return orig2(property, time, defaultValue, result);
    return property;
  };
})();

/* ==============================
   CONFIG
================================ */

// ------------------------------------------------------------
// Cloudflare Pages + R2 support
// If config.js defines window.DT_CONFIG.R2_BASE, all data assets
// are loaded from that public R2 bucket. If empty, local relative
// paths are used (works on localhost / Live Server).
// ------------------------------------------------------------
const R2_BASE   = (window.DT_CONFIG?.R2_BASE || "").replace(/\/+$/, "");
const R2_PREFIX = (window.DT_CONFIG?.R2_PREFIX || "").replace(/^\/+|\/+$/g, "");
function dataUrl(name){
  if(!R2_BASE) return name;
  const parts = [R2_BASE];
  if(R2_PREFIX) parts.push(R2_PREFIX);
  parts.push(String(name || "").replace(/^\/+/, ""));
  return parts.join("/");
}

// Cesium ION token
Cesium.Ion.defaultAccessToken =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1NmE1ZGMwYy0xNTQxLTRmMzgtYWM3NS0wYWUzMjk3MjNmYTAiLCJpZCI6MzYwODkxLCJpYXQiOjE3NjM0ODU3MTF9.D_qofjwKf6t1mnUO06Hkz-t7xr2UrPHklhG3a5Lfz8E";

// Your ION asset (LOD 2.2)
const ION_LOD22_ASSET_ID = 4261194;

// Hidden (backend) building attributes file (LOD1 polygons)
const LOD1_BUILDINGS_GEOJSON = dataUrl("twekkelerveld_buildings_energy_ageEUI_wgs84_201225.geojson");

// Files
const GREENSPACES_GEOJSON     = dataUrl("greenspace_4326.geojson");
const TREES_OPEN_GEOJSON      = dataUrl("trees_co2_4326_final.geojson"); // Updated filename
// Municipality trees dataset; use correct filename (plural trees_ and point)
const TREES_MUNI_GEOJSON      = dataUrl("trees_point_municipality.geojson");
const NDVI_PNG                = dataUrl("NDVI.png");
// NOTE: R2 is case-sensitive. Your bucket uses UHI.png (all caps), so keep it exact.
const UHI_PNG                 = dataUrl("UHI.png");

// for age normalization
const NOW_YEAR = 2025;

/* Bounds used for raster probing */
const bounds = { west: 6.8445, south: 52.2249, east: 6.8661, north: 52.2363 };

/* --------------------------------------------------------------------
   UHI BOUNDS ADJUSTMENT
   The original UHI PNG did not perfectly align with the study area.
   To compensate for the observed offset, we apply a small longitudinal
   and latitudinal shift when overlaying the heatmap.  If the image
   still appears misaligned, tweak these offsets accordingly.
-------------------------------------------------------------------- */
// Reset offsets for the UHI heatmap. Previously negative longitude
// and positive latitude values were used to compensate for misalignment.
// Based on updated testing and the provided screenshot, those
// corrections were overâ€‘shifting the raster. Setting both values to
// zero ensures the heatmap aligns with the study area bounds. Adjust
// lon and lat here if future tweaks are needed.
const UHI_OFFSET = { lon: 0.0, lat: 0.0 };
const UHI_BOUNDS = {
  west: bounds.west + UHI_OFFSET.lon,
  south: bounds.south + UHI_OFFSET.lat,
  east: bounds.east + UHI_OFFSET.lon,
  north: bounds.north + UHI_OFFSET.lat
};

/* ==============================
   VIEWER
================================ */
const viewer = new Cesium.Viewer("cesiumContainer", {
  terrain: Cesium.Terrain.fromWorldTerrain(),
  animation: false,
  timeline: false,
  baseLayerPicker: false,
  selectionIndicator: false,
  infoBox: false,
  navigationHelpButton: false,
  sceneModePicker: false,
  homeButton: false,
  geocoder: false,
  shadows: true,
  contextOptions: { webgl: { preserveDrawingBuffer: true } }
});

viewer.cesiumWidget.creditContainer.style.display = "none";
viewer.scene.globe.enableLighting = true;
viewer.scene.globe.depthTestAgainstTerrain = true;
viewer.scene.postProcessStages.fxaa.enabled = true;

viewer.shadowMap.darkness = 0.35;
viewer.shadowMap.enabled = true;

viewer.camera.setView({
  destination: Cesium.Rectangle.fromDegrees(bounds.west, bounds.south, bounds.east, bounds.north)
});

// -----------------------------------------------------------------------------
// Customise the camera controller to improve map navigation
//
// On some deployments (e.g. Cloudflare Pages) users reported that after
// exiting planting mode the map would spin instead of panning left/right.  The
// default Cesium behaviour assigns leftâ€‘drag to rotate and middle/right
// buttons to translate (pan).  To make panning intuitive and ensure the
// controls are restored after interaction modes, we explicitly assign
// translation (panning) to the left mouse drag and rotation to the right
// mouse drag.  Tilt remains on the middle mouse drag.  Pinch gestures on
// touch devices continue to zoom/translate.  If you prefer the default
// behaviour, comment out the following block.
try {
  const controller = viewer.scene.screenSpaceCameraController;
  if (controller) {
    controller.enableRotate = true;
    controller.enableTranslate = true;
    controller.enableTilt = true;
    controller.enableZoom = true;
    controller.enableLook = true;
    // Build arrays of supported event types.  Older versions of Cesium may not
    // define some constants (e.g. TWO_FINGER).  Only include values that are
    // defined to avoid passing `undefined` into Cesium internals, which causes
    // errors like "Cannot read properties of undefined (reading 'eventType')".
    //
    // Restore Cesium's default behaviour: rightâ€‘mouse drags pan (translate)
    // and leftâ€‘mouse drags rotate around the globe.  Pinch gestures on touch
    // screens continue to translate/zoom and twoâ€‘finger gestures rotate.  This
    // makes it possible to move the view horizontally and vertically by
    // dragging with the right mouse button, matching user expectations.
    const translateEvents = [];
    // Right mouse drag should pan (translate)
    if (Cesium.CameraEventType.RIGHT_DRAG !== undefined) {
      translateEvents.push(Cesium.CameraEventType.RIGHT_DRAG);
    }
    // Pinch gesture should translate/zoom on touch screens
    if (Cesium.CameraEventType.PINCH !== undefined) {
      translateEvents.push(Cesium.CameraEventType.PINCH);
    }
    controller.translateEventTypes = translateEvents;

    // Left mouse drag should rotate around the globe
    const rotateEvents = [];
    if (Cesium.CameraEventType.LEFT_DRAG !== undefined) {
      rotateEvents.push(Cesium.CameraEventType.LEFT_DRAG);
    }
    // Older Cesium versions may not support a separate two finger rotate gesture.
    if (Cesium.CameraEventType.TWO_FINGER !== undefined) {
      rotateEvents.push(Cesium.CameraEventType.TWO_FINGER);
    }
    controller.rotateEventTypes = rotateEvents;

    // Middle mouse drag tilts the camera
    const tiltEvents = [];
    if (Cesium.CameraEventType.MIDDLE_DRAG !== undefined) {
      tiltEvents.push(Cesium.CameraEventType.MIDDLE_DRAG);
    }
    controller.tiltEventTypes = tiltEvents;
  }
} catch (e) {
  console.warn('Camera controller customisation failed', e);
}

// Helper to restore camera controls.  Calling this function ensures that
// pan/rotate/tilt/zoom handlers are set correctly after toggling interaction
// modes such as planting or drawing.  It applies the same assignments as
// performed at initialisation.  Invoke this after leaving any custom mode.
function resetCameraControls() {
  try {
    const ctrl = viewer.scene.screenSpaceCameraController;
    if (!ctrl) return;
    ctrl.enableRotate = true;
    ctrl.enableTranslate = true;
    ctrl.enableTilt = true;
    ctrl.enableZoom = true;
    ctrl.enableLook = true;
    // Assemble translation (panning) events only if defined.  Newer Cesium versions may
    // omit certain constants (e.g. TWO_FINGER), so guard against undefined values.
    // Restore defaults: panning assigned to the right mouse drag, rotation to left
    const translateEvents2 = [];
    if (Cesium.CameraEventType.RIGHT_DRAG !== undefined) {
      translateEvents2.push(Cesium.CameraEventType.RIGHT_DRAG);
    }
    if (Cesium.CameraEventType.PINCH !== undefined) {
      translateEvents2.push(Cesium.CameraEventType.PINCH);
    }
    ctrl.translateEventTypes = translateEvents2;

    const rotateEvents2 = [];
    if (Cesium.CameraEventType.LEFT_DRAG !== undefined) {
      rotateEvents2.push(Cesium.CameraEventType.LEFT_DRAG);
    }
    if (Cesium.CameraEventType.TWO_FINGER !== undefined) {
      rotateEvents2.push(Cesium.CameraEventType.TWO_FINGER);
    }
    ctrl.rotateEventTypes = rotateEvents2;

    const tiltEvents2 = [];
    if (Cesium.CameraEventType.MIDDLE_DRAG !== undefined) {
      tiltEvents2.push(Cesium.CameraEventType.MIDDLE_DRAG);
    }
    ctrl.tiltEventTypes = tiltEvents2;
  } catch (err) {
    console.warn('resetCameraControls failed', err);
  }
}

viewer.canvas.addEventListener('contextmenu', (e) => e.preventDefault(), false);

/* ==============================
   SAFE GETTERS
================================ */
function safeGet(v, time){
  if(v === null || v === undefined) return v;
  return (typeof v.getValue === "function") ? v.getValue(time) : v;
}
function safePropString(entity, keys, time){
  if(!entity || !entity.properties) return "";
  for(const k of keys){
    const p = entity.properties[k];
    if(p === undefined || p === null) continue;
    const val = safeGet(p, time);
    if(val !== undefined && val !== null && String(val).trim() !== "") return String(val);
  }
  return "";
}
function safePropNumber(entity, keys, time){
  const s = safePropString(entity, keys, time);
  const n = Number(String(s).replace(",", "."));
  return Number.isFinite(n) ? n : null;
}
function safePolygonPositions(polygon, time){
  if(!polygon || !polygon.hierarchy) return [];
  const h = safeGet(polygon.hierarchy, time);
  if(!h) return [];
  if(h.positions && Array.isArray(h.positions)) return h.positions;
  if(Array.isArray(h)) return h;
  return [];
}

/* ==============================
   GROWTH PROJECTION UPDATE
   When a municipal tree is selected, display low/medium/high projections
   for DBH increment (cm), AGB (kg) and COâ‚‚ (kg/yr).  If no tree or an
   open dataset tree is selected this panel is hidden.
================================ */
function updateGrowthInfo(treeEntity){
  // Elements for growth panel and header
  const header = document.getElementById("growthHeader");
  const panel  = document.getElementById("growthPanel");
  // If no entity or entity is not municipal, hide panel
  if(!treeEntity || treeEntity._type !== "tree_muni"){
    if(header) header.style.display = "none";
    if(panel) panel.style.display  = "none";
    return;
  }
  const t = viewer.clock.currentTime || Cesium.JulianDate.now();
  // Helper to format triple values; uses a fallback of â€œâ€”â€
  const formatTriple = (lo, med, hi, unit) => {
    const f = v => (v !== null && v !== undefined && v !== "" && !isNaN(v)) ? (Math.round(Number(v) * 100) / 100) : null;
    const fl = f(lo);
    const fm = f(med);
    const fh = f(hi);
    const pieces = [
      fl !== null ? fl + (unit || "") : "â€”",
      fm !== null ? fm + (unit || "") : "â€”",
      fh !== null ? fh + (unit || "") : "â€”"
    ];
    return pieces.join(" / ");
  };
  // Read DBH increment low/med/high
  const dbhLow  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.dbhIncLow,  t);
  const dbhMed  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.dbhIncMed,  t);
  const dbhHigh = safePropNumber(treeEntity, TREE_EXTRA_KEYS.dbhIncHigh, t);
  // Read AGB next low/med/high (kg)
  const agbLow  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.agbNextLow,  t);
  const agbMed  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.agbNextMed,  t);
  const agbHigh = safePropNumber(treeEntity, TREE_EXTRA_KEYS.agbNextHigh, t);
  // Read COâ‚‚ next low/med/high (kg/yr)
  const co2Low  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.co2NextLow,  t);
  const co2Med  = safePropNumber(treeEntity, TREE_EXTRA_KEYS.co2NextMed,  t);
  const co2High = safePropNumber(treeEntity, TREE_EXTRA_KEYS.co2NextHigh, t);
  // Update DOM values
  const elDbh  = document.getElementById("valDbhGrowth");
  const elAgb  = document.getElementById("valAgbGrowth");
  const elCo2  = document.getElementById("valCo2Growth");
  if(elDbh) elDbh.innerText = formatTriple(dbhLow, dbhMed, dbhHigh, " cm");
  if(elAgb) elAgb.innerText = formatTriple(agbLow, agbMed, agbHigh, " kg");
  if(elCo2) elCo2.innerText = formatTriple(co2Low, co2Med, co2High, " kg/yr");
  if(header) header.style.display = "";
  if(panel)  panel.style.display  = "";
}

/* ==============================
   LAYERS REGISTRY
================================ */
const layers = {
  buildings3d: null,
  trees_open: null, // Open data trees
  trees_muni: null, // Muni data trees
  greenery: null,
  corridors: null,
  heatmap: null
};

/* ==============================
   RASTER PROBING (NDVI + UHI)
================================ */
const dataMaps = {
  ndvi: { ctx: null, width: 0, height: 0, min: 0.05, max: 0.65, loaded: false },
  uhi:  { ctx: null, width: 0, height: 0, min: 28.0, max: 40.0, loaded: false }
};

function loadMapData(id, url) {
  /**
   * Attempt to load a raster image from a list of candidate URLs.  On some deployments
   * (e.g. Cloudflare R2) the NDVI or UHI PNG files may be stored with different casing
   * or the bucket may not send permissive CORS headers.  In those cases using the
   * original URL causes the image to fail to load or the resulting canvas becomes
   * "tainted", meaning that pixel data cannot be read and default values are returned.
   *
   * To make probing robust, we try several filename variants (lowerâ€‘case/upperâ€‘case)
   * and wrap the load attempt in a recursive helper.  Each image is marked with
   * crossOrigin='anonymous' prior to setting the src so that, when the bucket
   * does send appropriate CORS headers, the pixel data remains readable.  When all
   * variants fail the fallback silently falls back to defaults.
   */
  const candidates = [];
  // always try the passed URL first
  candidates.push(url);
  // fallback variants: lowerâ€‘case and upperâ€‘case filenames.  Some hosting providers
  // (notably Cloudflare R2) are case-sensitive and may store assets using a
  // different naming convention.  Trying multiple variants improves the chances of
  // successfully loading the raster.
  if (id === "ndvi") {
    candidates.push(dataUrl("ndvi.png"));
    candidates.push(dataUrl("NDVI.PNG"));
    candidates.push(dataUrl("ndvi.PNG"));
  }
  if (id === "uhi") {
    candidates.push(dataUrl("uhi.png"));
    candidates.push(dataUrl("UHI.PNG"));
    candidates.push(dataUrl("uhi.PNG"));
  }
  // helper to attempt loading sequentially
  function attempt(i) {
    if (i >= candidates.length) {
      console.warn(`All ${id.toUpperCase()} image variants failed to load. Probing will use defaults.`);
      return;
    }
    const candidate = candidates[i];
    const img = new Image();
    // Set crossOrigin to attempt an anonymous CORS request.  If the resource
    // lacks the proper headers the image will still load but canvas pixel reads
    // will be blocked.  In that case the next candidate is tried.
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const c = document.getElementById("canvas" + id.toUpperCase());
      c.width = img.width;
      c.height = img.height;
      const ctx = c.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(img, 0, 0);
      dataMaps[id].ctx = ctx;
      dataMaps[id].width = img.width;
      dataMaps[id].height = img.height;
      dataMaps[id].loaded = true;
    };
    img.onerror = () => {
      // try next variant
      attempt(i + 1);
    };
    img.src = candidate;
  }
  attempt(0);
}
loadMapData("ndvi", NDVI_PNG);
loadMapData("uhi",  UHI_PNG);

function getPixelData(lat, lon) {
  const u = (lon - bounds.west) / (bounds.east - bounds.west);
  const v = (bounds.north - lat) / (bounds.north - bounds.south);

  let res = { ndvi: "0.15", uhi: "34.5Â°C", uhiVal: 34.5 };
  if (u < 0 || u > 1 || v < 0 || v > 1) return res;

  try {
    if (dataMaps.ndvi.ctx) {
      const x = Math.min(Math.floor(u * dataMaps.ndvi.width), dataMaps.ndvi.width - 1);
      const y = Math.min(Math.floor(v * dataMaps.ndvi.height), dataMaps.ndvi.height - 1);
      const p = dataMaps.ndvi.ctx.getImageData(x, y, 1, 1).data;
      const gray = (p[0] + p[1] + p[2]) / 3;
      const val = dataMaps.ndvi.min + (gray / 255) * (dataMaps.ndvi.max - dataMaps.ndvi.min);
      res.ndvi = val.toFixed(2);
    }
    if (dataMaps.uhi.ctx) {
      const x2 = Math.min(Math.floor(u * dataMaps.uhi.width), dataMaps.uhi.width - 1);
      const y2 = Math.min(Math.floor(v * dataMaps.uhi.height), dataMaps.uhi.height - 1);
      const p2 = dataMaps.uhi.ctx.getImageData(x2, y2, 1, 1).data;
      const gray2 = (p2[0] + p2[1] + p2[2]) / 3;
      const val2 = dataMaps.uhi.min + (gray2 / 255) * (dataMaps.uhi.max - dataMaps.uhi.min);
      res.uhiVal = val2;
      res.uhi = val2.toFixed(1) + "Â°C";
    }
  } catch (e) {
    console.warn("Pixel read error:", e);
  }
  return res;
}

/* ==============================
   UHI HEATMAP LAYER
================================ */
const heatmapLayer = viewer.imageryLayers.addImageryProvider(
  new Cesium.SingleTileImageryProvider({
    url: UHI_PNG,
    // Use adjusted bounds for the UHI PNG to improve alignment
    rectangle: Cesium.Rectangle.fromDegrees(
      UHI_BOUNDS.west,
      UHI_BOUNDS.south,
      UHI_BOUNDS.east,
      UHI_BOUNDS.north
    )
  })
);
heatmapLayer.alpha = 0.45;
heatmapLayer.show = false; // Default off
layers.heatmap = heatmapLayer;

/* ==============================
   LOD 2.2 BUILDINGS
================================ */
let lod22Tileset = null;
(async () => {
  try{
    lod22Tileset = await Cesium.Cesium3DTileset.fromIonAssetId(ION_LOD22_ASSET_ID);
    lod22Tileset.maximumScreenSpaceError = 2;
    lod22Tileset.dynamicScreenSpaceError = true;
    lod22Tileset.shadows = Cesium.ShadowMode.ENABLED;
    lod22Tileset.show = true;

    lod22Tileset.style = new Cesium.Cesium3DTileStyle({
      color: "color('#d1d5db', 0.85)"
    });

    viewer.scene.primitives.add(lod22Tileset);
    layers.buildings3d = lod22Tileset;
  }catch(e){
    console.warn("LOD 2.2 tileset failed:", e);
    layers.buildings3d = { show: false };
    document.getElementById("sw-buildings3d")?.classList.remove("active");
    showToast("LOD 2.2 failed (check token access / asset sharing)");
  }
})();

/* ==============================
   CORRIDOR MATERIAL (moving arrows)
================================ */
(function registerPolylineFlow(){
  if(Cesium.Material.PolylineFlowType) return;

  Cesium.Material.PolylineFlowType = 'PolylineFlow';
  Cesium.Material.PolylineFlowSource = `
    czm_material czm_getMaterial(czm_materialInput materialInput)
    {
      czm_material material = czm_getDefaultMaterial(materialInput);
      vec2 st = materialInput.st;

      float s = fract(st.s * repeat - time);
      float t = st.t - 0.5;

      float body = smoothstep(0.12, 0.18, s) * (1.0 - smoothstep(0.52, 0.58, s));
      body *= (1.0 - smoothstep(0.18, 0.22, abs(t)));

      float head = smoothstep(0.52, 0.58, s) * (1.0 - smoothstep(0.82, 0.88, s));
      float k = clamp((s - 0.52) / 0.30, 0.0, 1.0);
      float w = mix(0.22, 0.02, k);
      head *= (1.0 - smoothstep(w, w + 0.02, abs(t)));

      float arrow = clamp(body + head, 0.0, 1.0);

      float base = 0.10;
      material.diffuse = color.rgb;
      material.alpha = color.a * (base + 0.90 * arrow);
      return material;
    }
  `;

  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineFlowType, {
    fabric: {
      type: Cesium.Material.PolylineFlowType,
      uniforms: {
        // Use a vibrant green for corridors and reduce the repeat count so arrows
        // are longer and more recognisable.  A smaller repeat value means
        // fewer, larger arrows along each polyline.
        color: new Cesium.Color(0.145, 0.86, 0.50, 0.95),
        time: 0,
        repeat: 8.0
      },
      source: Cesium.Material.PolylineFlowSource
    },
    translucent: () => true
  });
})();

function PolylineFlowMaterialProperty(options){
  options = options || {};
  this._definitionChanged = new Cesium.Event();
  this.color = options.color || Cesium.Color.fromCssColorString('#fbbf24');
  this.duration = options.duration || 1.8;
  this.repeat = options.repeat || 18.0;
  this._t0 = performance.now();
}
Object.defineProperties(PolylineFlowMaterialProperty.prototype, {
  isConstant: { get: () => false },
  definitionChanged: { get: function(){ return this._definitionChanged; } }
});
PolylineFlowMaterialProperty.prototype.getType = () => Cesium.Material.PolylineFlowType;
PolylineFlowMaterialProperty.prototype.getValue = function(_time, result){
  if(!result) result = {};
  result.color = this.color;
  const sec = (performance.now() - this._t0) / 1000.0;
  result.time = (sec / this.duration) % 1.0;
  result.repeat = this.repeat;
  return result;
};
PolylineFlowMaterialProperty.prototype.equals = function(other){ return this === other; };

/* ==============================
   GREEN SPACES + CORRIDORS
================================ */
let corridorPolylines = [];
let corridorEntities = [];

Cesium.GeoJsonDataSource.load(GREENSPACES_GEOJSON, {
  clampToGround: true,
  stroke: Cesium.Color.fromCssColorString("#2dd4bf"),
  strokeWidth: 2,
  fill: Cesium.Color.fromCssColorString("#14b8a6").withAlpha(0.30)
}).then(ds => {
  layers.greenery = ds;
  viewer.dataSources.add(ds);

  for (const e of ds.entities.values) {
    e._type = "green";
    if (e.polygon){
      e.polygon.classificationType = Cesium.ClassificationType.BOTH;
    }
  }

  const centroids = ds.entities.values
    .filter(x => x.polygon)
    .map(x => {
      const t = viewer.clock.currentTime || Cesium.JulianDate.now();
      return polygonCentroidCartesian(safePolygonPositions(x.polygon, t));
    })
    .filter(Boolean);

  corridorPolylines = [];
  corridorEntities = [];

  const maxLinkDist = 260;
  for(let i=0; i<centroids.length; i++){
    let bestJ = -1, bestD = Infinity;
    for(let j=0; j<centroids.length; j++){
      if(i===j) continue;
      const d = Cesium.Cartesian3.distance(centroids[i], centroids[j]);
      if(d < bestD && d <= maxLinkDist){ bestD = d; bestJ = j; }
    }
    if(bestJ !== -1){
        const positions = [centroids[i], centroids[bestJ]];
        corridorPolylines.push(positions);
        // Compute length and a holistic wellâ€‘being score.  Besides connectivity
        // (shorter corridors are better), we also consider vegetation (NDVI) and
        // cooling (UHI).  Each factor is normalised to 0â€“1 and weighted
        // (NDVI 40%, UHI 40%, connectivity 20%).
        const lengthMeters = bestD;
        // Get geographic coordinates of the endpoints
        const cartoA = Cesium.Cartographic.fromCartesian(centroids[i]);
        const cartoB = Cesium.Cartographic.fromCartesian(centroids[bestJ]);
        const latA = Cesium.Math.toDegrees(cartoA.latitude);
        const lonA = Cesium.Math.toDegrees(cartoA.longitude);
        const latB = Cesium.Math.toDegrees(cartoB.latitude);
        const lonB = Cesium.Math.toDegrees(cartoB.longitude);
        // Probe raster values at both ends
        const pdA = getPixelData(latA, lonA);
        const pdB = getPixelData(latB, lonB);
        const ndviA = parseFloat(pdA.ndvi);
        const ndviB = parseFloat(pdB.ndvi);
        const avgNdvi = (ndviA + ndviB) / 2;
        const uhiA = pdA.uhiVal;
        const uhiB = pdB.uhiVal;
        const avgUhi = (uhiA + uhiB) / 2;
        // Normalise NDVI between 0 and 1 (higher NDVI is better)
        let ndviScore;
        if(dataMaps.ndvi && dataMaps.ndvi.max !== undefined && dataMaps.ndvi.min !== undefined){
          ndviScore = (avgNdvi - dataMaps.ndvi.min) / (dataMaps.ndvi.max - dataMaps.ndvi.min);
        } else {
          ndviScore = 0;
        }
        ndviScore = Math.max(0, Math.min(1, ndviScore));
        // Normalise UHI: cooler temperatures get higher scores
        let uhiScore;
        if(dataMaps.uhi && dataMaps.uhi.max !== undefined && dataMaps.uhi.min !== undefined){
          uhiScore = (dataMaps.uhi.max - avgUhi) / (dataMaps.uhi.max - dataMaps.uhi.min);
        } else {
          uhiScore = 0;
        }
        uhiScore = Math.max(0, Math.min(1, uhiScore));
        // Normalise connectivity (shorter distance is better)
        let lengthScore = 1 - (lengthMeters / maxLinkDist);
        lengthScore = Math.max(0, Math.min(1, lengthScore));
        // Weighted combination
        const score = (ndviScore * 0.4 + uhiScore * 0.4 + lengthScore * 0.2) * 100;

        const ent = viewer.entities.add({
          polyline: {
            positions,
            width: 6,
            material: new PolylineFlowMaterialProperty({
              color: Cesium.Color.fromCssColorString('#86efac').withAlpha(0.95),
              duration: 2.8,
              repeat: 12.0
            }),
            clampToGround: true
          },
          show: false
        });
        // Tag entity type and store length/score properties for popups, along with
        // average NDVI and UHI values for use in popups.
        ent._type = "corridor";
        ent._lengthMeters = lengthMeters;
        ent._wellBeingScore = score;
        ent._ndviAvg = avgNdvi;
        ent._uhiAvg = avgUhi;
        corridorEntities.push(ent);
    }
  }

  layers.corridors = {
    show: false,
    toggle: (s) => {
      corridorEntities.forEach(e => e.show = s);
      viewer.scene.requestRender();
    }
  };

  updateLegend();
}).catch(e => console.warn("Green spaces load failed:", e));

/* ==============================
   LAYER 1: TREES OPEN DATA (Clickable)
================================ */
const TREE_KEYS = {
  species: ["species","soort","boomsoort","tree_type","type","genus","latin_name","naam"],
  height: ["tree_height_m1","tree_height_m","height_m","height","hoogte","hoogte_m","h_m"],
  co2: [
    "co2_yr_kg",        // new property name in final dataset
    "co2_yr_med",       // additional variant
    "co2_kg", "co2kg", "co2", "co2_stored_kg", "co2_storage_kg", "co2_kg_year", "co2_kg_yr"
  ]
};

/**
 * Additional property keys for trees.  These arrays list potential
 * property names across both the open and municipal tree datasets.
 * Using the same approach as TREE_KEYS, we search for the first
 * available key on the entity and return its value.  These keys
 * allow us to extract crown area, aboveâ€‘ground biomass (AGB), size
 * class, and future growth metrics such as DBH increment and COâ‚‚
 * projections.  If a property does not exist for the selected tree
 * the corresponding value will remain null and will be rendered as â€œâ€”â€.
 */
const TREE_EXTRA_KEYS = {
  crown:      ["crown_m2","crown","area_m2","crown_area_m2"],
  agb:        ["agb_kg","agb","agb_m","agb_next_kg","agb_next"],
  sizeClass:  ["size_class","sizeclass","dbh_class","dbh_size_class"],
  dbhInc:     ["dbh_inc_cm","dbh_inc"],
  dbhIncLow:  ["dbh_inc_low"],
  dbhIncMed:  ["dbh_inc_med"],
  dbhIncHigh: ["dbh_inc_high"],
  agbNextLow:  ["agb_next_low"],
  agbNextMed:  ["agb_next_med"],
  agbNextHigh: ["agb_next_high"],
  co2NextLow:  ["co2_yr_low"],
  co2NextMed:  ["co2_yr_med"],
  co2NextHigh: ["co2_yr_high"]
};

Cesium.GeoJsonDataSource.load(TREES_OPEN_GEOJSON, { clampToGround: true })
.then(ds => {
  layers.trees_open = ds;
  viewer.dataSources.add(ds);

  for (const e of ds.entities.values) {
    e.billboard = undefined;

    const t = viewer.clock.currentTime || Cesium.JulianDate.now();

    const co2Stored = safePropNumber(e, TREE_KEYS.co2, t) ?? 0;
    const height = safePropNumber(e, TREE_KEYS.height, t) ?? 0;
    const species = safePropString(e, TREE_KEYS.species, t) || "Tree";

    const size = Math.max(3, Math.min(8, (co2Stored || 50) / 80));
    const color = (co2Stored > 600) ? "#0d9488" : (co2Stored > 400 ? "#2dd4bf" : "#99f6e4");

    e.point = {
      pixelSize: size,
      color: Cesium.Color.fromCssColorString(color),
      outlineColor: Cesium.Color.WHITE,
      outlineWidth: 1,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      disableDepthTestDistance: Number.POSITIVE_INFINITY
    };

    e._type = "tree_open";
    e._data = { co2Stored, height, species, baseSize: size };
  }
  updateLegend();
}).catch(e => console.warn("Open Data Trees load failed:", e));

/* ==============================
   LAYER 2: TREES MUNICIPALITY (Clickable with full info)
================================ */
Cesium.GeoJsonDataSource.load(TREES_MUNI_GEOJSON, { clampToGround: true })
.then(ds => {
  layers.trees_muni = ds;
  viewer.dataSources.add(ds);

  for (const e of ds.entities.values) {
    e.billboard = undefined;
    
    // Different visual style for Muni trees (blue-ish)
    e.point = {
      pixelSize: 6,
      color: Cesium.Color.fromCssColorString("#60a5fa"), // Blue-400
      outlineColor: Cesium.Color.WHITE,
      outlineWidth: 1,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      disableDepthTestDistance: Number.POSITIVE_INFINITY
    };

    e._type = "tree_muni";
    // We don't extract specific props here, we extract them dynamically on click
  }
  updateLegend();
}).catch(e => console.warn("Municipality Trees load failed:", e));

/* ==============================
   HIDDEN BACKEND BUILDINGS (LOD1 polygons)
================================ */
const LOD1_KEYS = {
  bag: ["bag_id","pand_id","id","identificatie","identification","rdf_seealso"],
  bouwjaar: ["bouwjaar","year","build_year","construction_year","bouwjaar_pand","vbo_bouwjaar"],
};

function getPropString(entity, keys){
  const t = viewer?.clock?.currentTime || Cesium.JulianDate.now();
  return safePropString(entity, keys, t);
}

let lod1Ds = null;
let _lod1ReadyResolve = null;
const lod1Ready = new Promise((resolve) => { _lod1ReadyResolve = resolve; });

let lod1Spatial = [];

function pointInRing(x, y, ring){
  let inside = false;
  for(let i=0, j=ring.length-1; i<ring.length; j=i++){
    const xi = ring[i][0], yi = ring[i][1];
    const xj = ring[j][0], yj = ring[j][1];
    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / ((yj - yi) + 1e-12) + xi);
    if(intersect) inside = !inside;
  }
  return inside;
}

function rebuildLod1SpatialIndex(){
  lod1Spatial = [];
  if(!lod1Ds) return;

  const t = viewer.clock.currentTime || Cesium.JulianDate.now();
  const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);

  for(const e of lod1Ds.entities.values){
    if(e._type !== 'lod1_building' || !e.polygon) continue;

    const pos = safePolygonPositions(e.polygon, t);
    if(!pos || pos.length < 3) continue;

    const ring = [];
    let minx=Infinity, miny=Infinity, maxx=-Infinity, maxy=-Infinity;

    for(const c3 of pos){
      const carto = Cesium.Cartographic.fromCartesian(c3);
      const p = proj.project(carto);
      const x = p.x, y = p.y;
      ring.push([x,y]);
      if(x<minx) minx=x; if(y<miny) miny=y; if(x>maxx) maxx=x; if(y>maxy) maxy=y;
    }

    const cen = polygonCentroidCartographic(pos);
    let cx=(minx+maxx)/2, cy=(miny+maxy)/2;
    if(cen){
      const cp = proj.project(cen);
      cx = cp.x; cy = cp.y;
    }

    lod1Spatial.push({
      entity: e,
      ring,
      bbox: {minx,miny,maxx,maxy},
      centroid: [cx,cy]
    });
  }
}

function findLod1BuildingByLonLat(lonDeg, latDeg){
  if(!lod1Spatial.length) return null;

  const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);
  const p = proj.project(Cesium.Cartographic.fromDegrees(lonDeg, latDeg));
  const x = p.x, y = p.y;

  const candidates = lod1Spatial.filter(r =>
    x>=r.bbox.minx && x<=r.bbox.maxx && y>=r.bbox.miny && y<=r.bbox.maxy
  );

  for(const c of candidates){
    if(pointInRing(x, y, c.ring)) return c.entity;
  }

  // fallback: nearest centroid within 60m
  let bestD2 = Infinity;
  let bestRec = null;
  for(const r of lod1Spatial){
    const dx = x - r.centroid[0];
    const dy = y - r.centroid[1];
    const d2 = dx*dx + dy*dy;
    if(d2 < bestD2){
      bestD2 = d2;
      bestRec = r;
    }
  }
  if(bestRec && Math.sqrt(bestD2) <= 60) return bestRec.entity;
  return null;
}

// Basic Env computation for MCDA (kept for wizard, removed from Heat-Stress Layer logic)
function computeEnvForEntity(e){
  try{
    if(!e || !e.polygon) return;
    const t = viewer.clock.currentTime || Cesium.JulianDate.now();
    const c = polygonCentroidCartographic(safePolygonPositions(e.polygon, t));
    if(!c){ e._env = null; e._centroid = null; return; }

    const lat = Cesium.Math.toDegrees(c.latitude);
    const lon = Cesium.Math.toDegrees(c.longitude);
    e._env = getPixelData(lat, lon);
    e._centroid = { lat, lon };
  }catch(_){ e._env = null; e._centroid = null; }
}

Cesium.GeoJsonDataSource.load(LOD1_BUILDINGS_GEOJSON, { clampToGround: true })
.then(ds => {
  lod1Ds = ds;
  viewer.dataSources.add(ds);

  const t = viewer.clock.currentTime || Cesium.JulianDate.now();

  for (const e of ds.entities.values) {
    if(!e.polygon) continue;
    // Keep invisible (backend-only)
    e.show = false;
    e._type = "lod1_building";
    e._bag = getPropString(e, LOD1_KEYS.bag);
    e._bouwjaar = getPropString(e, LOD1_KEYS.bouwjaar);

    // compute footprint area (mÂ²)
    const pos = safePolygonPositions(e.polygon, t);
    e._areaM2 = polygonAreaM2(pos);
    computeEnvForEntity(e);
  }

  ds.show = false; // hard hidden
  rebuildLod1SpatialIndex();
  if(_lod1ReadyResolve) _lod1ReadyResolve(true);
}).catch(e => {
  console.warn("Backend buildings (LOD1) load failed:", e);
  if(_lod1ReadyResolve) _lod1ReadyResolve(false);
});

/* ==============================
   LEGEND
================================ */
function setLegend(title, rows){
  const body = document.getElementById("legendBody");
  document.getElementById("legendTitle").innerText = title;

  body.innerHTML = "";
  rows.forEach(r => {
    const div = document.createElement("div");
    div.className = "leg-row";
    div.innerHTML = `
      <div class="leg-chip">
        <span class="chip ${r.type || ""}" style="background:${r.color};"></span>
        <span>${r.label}</span>
      </div>
      <span style="color:rgba(226,232,240,0.62);">${r.meta || ""}</span>
    `;
    body.appendChild(div);
  });
}

/* --------------------------------------------------------------------
   Panel collapse handlers
   These functions hide or show the side panels and reveal their
   corresponding toggle tabs.  When a panel is collapsed the panel
   element is hidden (display:none) and its toggle tab becomes
   visible; clicking the tab will restore the panel.  Feel free to
   adjust this logic to animate the transition or to remember
   collapsed state across sessions.
-------------------------------------------------------------------- */
function toggleLeftPanel(){
  const panel = document.getElementById('leftPanel');
  const toggle = document.getElementById('leftPanelToggle');
  if(!panel) return;
  if(panel.style.display === 'none'){
    panel.style.display = '';
    if(toggle) toggle.style.display = 'none';
  } else {
    panel.style.display = 'none';
    if(toggle) toggle.style.display = 'flex';
  }
}
function toggleRightPanel(){
  const panel = document.getElementById('rightPanel');
  const toggle = document.getElementById('rightPanelToggle');
  if(!panel) return;
  if(panel.style.display === 'none'){
    panel.style.display = '';
    if(toggle) toggle.style.display = 'none';
  } else {
    panel.style.display = 'none';
    if(toggle) toggle.style.display = 'flex';
  }
}

function updateLegend(){
  const on = (id) => document.getElementById("sw-"+id)?.classList.contains("active");

  if(on("heatmap")){
    // Custom legend for the UHI heatmap.  Colours are ordered from cool
    // (greens) through moderate (light green) to warm (brown) and very warm
    // (light brown).  Adjust colours or labels here to fineâ€‘tune the
    // representation of surface temperature.
    setLegend("UHI Heatmap", [
      { label: "UHI / Surface temp", color: "#16a34a", meta: "low" },       // dark green â€“ cooler areas
      { label: "UHI / Surface temp", color: "#4ade80", meta: "moderate" },  // light green
      { label: "UHI / Surface temp", color: "#92400e", meta: "high" },      // brown
      { label: "UHI / Surface temp", color: "#f5deb3", meta: "very high" } // light brown
    ]);
    return;
  }

  setLegend("Legend", [
    {label:"Trees (Open)", color:"#10b981", meta:"points"},
    {label:"Trees (Muni)", color:"#60a5fa", meta:"points"},
    {label:"Green spaces", color:"rgba(20,184,166,0.55)", meta:"polygons"},
    {label:"Corridors", color:"#fbbf24", meta:"moving arrows", type:"line"},
    {label:"Buildings", color:"rgba(209,213,219,0.75)", meta:"LOD 2.2"},
    {label:"Green facades", color:"rgba(34,197,94,0.85)", meta:"squares"}
  ]);
}

/* ==============================
   LAYER TOGGLES
================================ */
function toggleLayer(name){
  const sw = document.getElementById("sw-"+name);
  if(!sw) return;

  sw.classList.toggle("active");
  const isOn = sw.classList.contains("active");

  if(name === "corridors"){
    if(layers.corridors) layers.corridors.toggle(isOn);
    updateLegend();
    return;
  }

  if(name === "heatmap"){
    if(layers.heatmap) layers.heatmap.show = isOn;
    updateLegend();
    return;
  }

  if(name === "buildings3d"){
    if(layers.buildings3d && typeof layers.buildings3d.show !== "undefined"){
      layers.buildings3d.show = isOn;
      viewer.scene.requestRender();
    }
    return;
  }

  if(layers[name] && typeof layers[name].show !== "undefined"){
    layers[name].show = isOn;
    viewer.scene.requestRender();
    return;
  }
}

/* ==============================
   INFO MODALS
================================ */
const LAYER_INFO = {
  trees_open: {
    title: "Tree Inventory (Open Data)",
    html: `
      <p><strong>Description:</strong> Publicly available street tree inventory. Each point represents a documented tree from the city's open dataset.</p>
      <p><strong>Attributes:</strong></p>
      <ul style="margin-left:16px;">
        <li><b>Species</b> (taxonomic name)</li>
        <li><b>Height</b> (approximate metres)</li>
        <li><b>Crown area</b> (mÂ²)</li>
        <li><b>Aboveâ€‘ground biomass (AGB)</b> if available</li>
        <li><b>Size class</b> (small, medium, large)</li>
        <li><b>COâ‚‚ stored</b> (kg of carbon stored in the tree)</li>
      </ul>
      <p>Click a tree to view these details in the popup. Growth projections (future DBH/AGB/COâ‚‚) are only available for municipal records.</p>
    `
  },
  trees_muni: {
    title: "Tree Points (Municipality)",
    html: `
      <p><strong>Description:</strong> Official municipal tree registry capturing extensive biological and growth information about each tree.</p>
      <p><strong>Attributes:</strong></p>
      <ul style="margin-left:16px;">
        <li><b>Species</b> (common name and scientific name)</li>
        <li><b>Height</b> (m), <b>Crown area</b> (mÂ²) and <b>Diameter at Breast Height (DBH)</b> (cm)</li>
        <li><b>Size class</b> (S/M/L) based on canopy spread</li>
        <li><b>Aboveâ€‘ground biomass (AGB)</b> (kg)</li>
        <li><b>COâ‚‚ stored</b> (kg of carbon in the tree)</li>
        <li><b>Growth projections</b>: low/medium/high forecasts for DBH increment, future biomass and annual COâ‚‚ sequestration</li>
      </ul>
      <p>Click a tree to view its current attributes. When a municipal tree is selected, the growth projections panel on the right shows how it may evolve over time.</p>
    `
  },
  greenery: {
    title: "Green Spaces",
    html: `
      <p><strong>Description:</strong> Polygons delineating parks, lawns, sports fields and other vegetated areas.</p>
      <p>These areas provide habitat, recreation space and are used when analysing corridor connectivity and scenario planning.</p>
    `
  },
  buildings3d: {
    title: "Buildings (LOD 2.2)",
    html: `
      <p><strong>Description:</strong> Level of Detail 2.2 building models sourced from Cesium ION (Asset ID: ${ION_LOD22_ASSET_ID}).</p>
      <p>Each model has a detailed roof and wall geometry. Hidden attributes from LOD1 include BAG ID, construction year and footprint area.</p>
      <p>Click a building to inspect these attributes in the popup.</p>
    `
  },
  corridors: {
    title: "Wellâ€‘being Corridors (Moving Arrows)",
    html: `
        <p><strong>Description:</strong> Wellâ€‘being corridors are lines connecting parks and other green spaces that facilitate movement for wildlife, pollinators and people. Connected habitats improve gene flow and genetic diversity; studies show that plant species richness increases when gardens are linked, and corridors reduce extinction rates while boosting colonisation.</p>
        <p>These corridors also provide walkable routes for residents, supporting recreation and mental health. Each corridor is assigned a wellâ€‘being score that combines three factors: (1) vegetation health (NDVI), (2) cooling intensity (UHI), and (3) connectivity. NDVI and UHI values are sampled at both ends of the corridor and normalised between their observed minima and maxima. The score is calculated as 40% NDVI + 40% cooling (inverted UHI) + 20% connectivity (shorter segments score higher). Thus, greener, cooler and betterâ€‘connected corridors receive higher scores.</p>
        <p>The length shown in the popup refers to the straightâ€‘line distance between the two connected green spaces.</p>
    `
  },
  growthProjection: {
    title: "Growth Projection",
    html: `
      <p><strong>Description:</strong> The growth projection panel shows simulated changes in tree diameter at breast height (DBH), aboveâ€‘ground biomass (AGB) and carbon sequestration over future years. These projections are calculated from allometric equations that relate biomass to wood density (Ï), DBH (D) and tree height (H), such as AGB = 0.0673 Ã— (Ï Ã— DÂ² Ã— H)<sup>0.96</sup>. By comparing low, medium and high growth scenarios, the projection helps to estimate future biomass and COâ‚‚ sequestration.</p>
      <p>Ecosystem services provided by treesâ€”such as carbon storage, shade and habitatâ€”contribute to multiple components of human wellâ€‘being, including health, security, social relations and freedom of choice. Growth projections therefore inform planning decisions that maximise ecological and human benefits.</p>
    `
  },
  heatmap: {
    title: "Heatmap (UHI)",
    html: `
        <p><strong>Description:</strong> Raster overlay representing the urban heat island (UHI) intensity. It is derived from land surface temperature (LST) imagery captured on 7Â AugÂ 2022 by the Sentinelâ€‘2 satellite. The values approximate surface temperature and do not represent air temperature.</p>
        <p>Each pixel contains a Â°C value interpolated from the LST raster (<code>${UHI_PNG}</code>). This heatmap illustrates relative temperature across the city, with cooler areas appearing green and hotter areas trending toward browns. The selected date represents a worstâ€‘case baseline day, so use this layer as a qualitative guide rather than precise, current conditions.</p>
    `
  }
};

function openLayerInfo(key, ev){
  if(ev) ev.stopPropagation();
  const box = document.getElementById("layerInfoModal");
  const t = document.getElementById("layerInfoTitle");
  const b = document.getElementById("layerInfoBody");

  const info = LAYER_INFO[key] || { title:"Layer Info", html:"<p>No details available.</p>" };
  t.innerText = info.title;
  b.innerHTML = info.html;
  // Optional: enrich with Wikipedia context
  try{ appendWikiToLayerInfo(key, b); }catch(e){}

  box.style.display = "flex";
}
function closeLayerInfo(){ document.getElementById("layerInfoModal").style.display = "none"; }
function openOverview(){ document.getElementById("overviewModal").style.display = "flex"; }
function closeOverview(){ document.getElementById("overviewModal").style.display = "none"; }
function openMCDA(){ document.getElementById('mcdaModal').style.display = 'flex'; }
function closeMCDA(){ document.getElementById('mcdaModal').style.display = 'none'; }

// Reset the camera to the study area boundary.  When users zoom far away or lose
// their position, this helper flies the camera back to the predefined
// bounding rectangle over Twekkelerveld.  The destination rectangle is
// derived from the global bounds object and uses a short animation.
function resetToStudyArea(){
  try{
    viewer.camera.flyTo({
      destination: Cesium.Rectangle.fromDegrees(bounds.west, bounds.south, bounds.east, bounds.north),
      duration: 2.0
    });
  }catch(e){
    console.warn('Reset view failed', e);
  }
}

// Removed toggleRightPanel logic as user requested static panels

/* ==============================
   SIMULATION DATA
================================ */
let sim = { trees: 0, facades: 0, cost: 0, co2: 0, uhi: 0, bio: 1.20, water: 0 };
let impactLoss = { co2: 0, water: 0, temp: 0, money: 0 };
let undoStack = [];
let currentYear = 1;

const speciesData = {
  oak:  { name: "Oak",  cost: 250, Smax: 1600, k: 0.18, t0: 12, uhi: 0.012, bio: 0.05, water: 1000, color: "#eab308" },
  birch:{ name: "Birch",cost: 100, Smax:  900, k: 0.22, t0: 10, uhi: 0.005, bio: 0.02, water:  400, color: "#f97316" },
  pine: { name: "Pine", cost: 150, Smax: 1100, k: 0.20, t0: 11, uhi: 0.008, bio: 0.03, water:  600, color: "#84cc16" }
};
let selectedSpecies = "oak";

const facadeTypes = {
  ivy: { name: "Ivy", cost: 3500, co2: 6, uhi: 0.018, bio: 0.07, water: 120, color: "#22c55e" },
  livingwall: { name: "Living Wall", cost: 6000, co2: 10, uhi: 0.028, bio: 0.10, water: 180, color: "#16a34a" },
  trellis: { name: "Trellis", cost: 2000, co2: 4, uhi: 0.012, bio: 0.05, water: 80, color: "#84cc16" }
};
let selectedFacadeType = "ivy";

function treeStorageCO2(spec, age){
  const e = Math.exp(-spec.k * (age - spec.t0));
  return spec.Smax / (1 + e);
}
function treeAnnualCO2(spec, age){
  const e = Math.exp(-spec.k * (age - spec.t0));
  return spec.Smax * spec.k * e / Math.pow(1 + e, 2);
}

/* ==============================
   CHART
================================ */
let tradeoffChart = null;
// Gauges for impact overview
let gaugeCo2 = null;
let gaugeWater = null;
let gaugeUhi = null;
let gaugeCost = null;
// Additional biodiversity gauge for habitat suitability proxy
let gaugeBio = null;

/**
 * Helper to create a semi-circular gauge using Chart.js. The gauge
 * renders a percentage of the circle based on the first value in
 * dataset.data and uses a simple plugin to draw the numeric value
 * and caption in the centre. A custom colour can be supplied.
 *
 * @param {string} canvasId   The id of the canvas element
 * @param {string} color      The primary colour of the gauge arc
 * @param {string} caption    The caption displayed beneath the value
 * @returns {Chart}           The created Chart.js instance
 */
function createGauge(canvasId, color, caption){
  const ctx = document.getElementById(canvasId).getContext('2d');
  return new Chart(ctx, {
    type: 'pie',
    data: {
      labels: ['Value', 'Remainder'],
      datasets: [{
        data: [0, 100],
        backgroundColor: [color, 'rgba(255,255,255,0.08)'],
        hoverBackgroundColor: [color, 'rgba(255,255,255,0.08)'],
        borderWidth: 0,
        // values will be updated externally via updateAllGauges
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '60%',
      animation: {
        animateRotate: true,
        animateScale: false
      },
      plugins: {
        legend: { display: false },
        tooltip: { enabled: false }
      }
    },
    plugins: []
  });
}

/**
 * Updates all gauges with the latest net values. Each gauge uses a
 * predetermined maximum value for normalisation and displays both
 * the percentage of the maximum and the actual human-readable
 * measurement inside. Values exceeding the maximum are capped at
 * 100% on the gauge but the real value is still displayed.
 *
 * @param {number} netCo2   Net COâ‚‚ sequestration (kg/yr)
 * @param {number} netWater Net stormwater reduction (L/yr)
 * @param {number} netUhi   Net cooling effect (Â°C)
 * @param {number} netCost  Net investment (â‚¬)
 */
function updateAllGauges(netCo2, netWater, netUhi, netCost){
  // Define max values for normalisation
  const maxCo2 = 600;      // kg/yr, approximate max sequestration
  const maxWater = 25000;  // L/yr, approximate max runoff reduction
  const maxUhi = 0.5;      // Â°C, approximate max cooling effect
  const maxCost = 20000;   // â‚¬, approximate max investment

  // Helper to compute percentage and label
  const compute = (value, max, unit) => {
    const pct = Math.min(Math.abs(value) / max * 100, 100);
    // Format the displayed value with units and sign
    let display;
    if(unit === 'Â°C'){
      display = (value >= 0 ? '-' : '+') + Math.abs(value).toFixed(3) + unit;
    } else if(unit === 'kg/yr'){
      display = (value >= 0 ? '+' : '-') + Math.round(Math.abs(value)).toLocaleString() + ' kg';
    } else if(unit === 'L/yr'){
      display = (value >= 0 ? '-' : '+') + Math.round(Math.abs(value)).toLocaleString() + ' L';
    } else if(unit === 'â‚¬'){
      display = (value >= 0 ? 'â‚¬' : '-â‚¬') + Math.round(Math.abs(value)).toLocaleString();
    } else {
      display = Math.round(value).toString();
    }
    return { pct, display };
  };

  // COâ‚‚ gauge
  if(gaugeCo2){
    const { pct, display } = compute(netCo2, maxCo2, 'kg/yr');
    gaugeCo2.data.datasets[0].data[0] = pct;
    gaugeCo2.data.datasets[0].data[1] = 100 - pct;
    gaugeCo2.update();
    const el = document.getElementById('gaugeCo2Value');
    if(el) el.innerText = display;
  }
  // Water gauge
  if(gaugeWater){
    const { pct, display } = compute(netWater, maxWater, 'L/yr');
    gaugeWater.data.datasets[0].data[0] = pct;
    gaugeWater.data.datasets[0].data[1] = 100 - pct;
    gaugeWater.update();
    const el = document.getElementById('gaugeWaterValue');
    if(el) el.innerText = display;
  }
  // Cooling gauge (UHI)
  if(gaugeUhi){
    const { pct, display } = compute(netUhi, maxUhi, 'Â°C');
    gaugeUhi.data.datasets[0].data[0] = pct;
    gaugeUhi.data.datasets[0].data[1] = 100 - pct;
    gaugeUhi.update();
    const el = document.getElementById('gaugeUhiValue');
    if(el) el.innerText = display;
  }
  // Investment gauge
  if(gaugeCost){
    const { pct, display } = compute(netCost, maxCost, 'â‚¬');
    gaugeCost.data.datasets[0].data[0] = pct;
    gaugeCost.data.datasets[0].data[1] = 100 - pct;
    gaugeCost.update();
    const el = document.getElementById('gaugeCostValue');
    if(el) el.innerText = display;
  }
}
  try {
    const ctx = document.getElementById("tradeoffChart").getContext("2d");
    tradeoffChart = new Chart(ctx, {
      type: "bar",
      data: {
        // Use descriptive labels with units so users understand what each axis measures
        labels: ["Cost (â‚¬)", "COâ‚‚ (t)", "Cooling (Â°C)", "Biodiversity (index)"],
        datasets: [{
          label: "Scenario Impact",
          data: [0, 0, 0, 0],
          backgroundColor: ["#fb7185", "#2dd4bf", "#60a5fa", "#c084fc"]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: true,
            max: 100,
            grid: { color: "rgba(255,255,255,0.15)" },
            ticks: { color: "rgba(255,255,255,0.7)" }
          },
          x: {
            grid: { color: "rgba(255,255,255,0.15)" },
            ticks: { color: "rgba(255,255,255,0.85)" }
          }
        },
        plugins: {
          legend: { display: false }
        }
      }
    });
  } catch(e) {
    console.warn("Chart init failed", e);
  }

/* ==============================
   MODES
================================ */
let interactionMode = "idle"; // idle | plant | draw | facade
const popup = document.getElementById("ecoPopup");

/* ==============
   TREE UI
============== */
function selectSpecies(key, el){
  selectedSpecies = key;
  document.querySelectorAll(".species-grid")[0].querySelectorAll(".species-opt").forEach(d => d.classList.remove("selected"));
  el.classList.add("selected");

  const btn = document.getElementById("btnPlant");
  const spec = speciesData[key];
  if(interactionMode !== "plant"){
    btn.innerHTML = `<i class="fas fa-plus-circle"></i> Plant ${spec.name} (â‚¬${spec.cost})`;
  }
}
function togglePlanting(){
  const btn = document.getElementById("btnPlant");
  const spec = speciesData[selectedSpecies];

  if(interactionMode === "plant"){
    interactionMode = "idle";
    btn.classList.remove("planting");
    btn.innerHTML = `<i class="fas fa-plus-circle"></i> Plant ${spec.name} (â‚¬${spec.cost})`;
    viewer.canvas.style.cursor = "default";
    showToast("Planting mode OFF");
    // Restore camera controls when exiting planting mode
    resetCameraControls();
    return;
  }

  if(interactionMode === "facade") toggleFacading(true);
  cancelPolygonDraw(true);

  interactionMode = "plant";
  btn.classList.add("planting");
  btn.innerHTML = `<i class="fas fa-hand-holding-seedling"></i> Click map to plant ${spec.name}`;
  viewer.canvas.style.cursor = "crosshair";
  closePopup();
  showToast("Planting mode ON");
  // During planting mode we still allow panning/rotation; ensure controls remain
  resetCameraControls();
}

/* ==============
   FACADE UI
============== */
function selectFacadeType(key, el){
  selectedFacadeType = key;

  const grids = document.querySelectorAll(".species-grid");
  const facadeGrid = grids[1];
  facadeGrid.querySelectorAll(".species-opt").forEach(d => d.classList.remove("selected"));
  el.classList.add("selected");

  const btn = document.getElementById("btnFacade");
  const f = facadeTypes[key];
  if(interactionMode !== "facade"){
    btn.innerHTML = `<i class="fa-solid fa-square-plus"></i> Apply ${f.name} Facade (click a building)`;
  }
}

function toggleFacading(silent=false){
  const btn = document.getElementById("btnFacade");
  const f = facadeTypes[selectedFacadeType];

  if(interactionMode === "facade"){
    interactionMode = "idle";
    btn.classList.remove("facading");
    btn.innerHTML = `<i class="fa-solid fa-square-plus"></i> Apply ${f.name} Facade (click a building)`;
    viewer.canvas.style.cursor = "default";
    if(!silent) showToast("Facade mode OFF");
    // Restore camera controls when exiting facade mode
    resetCameraControls();
    return;
  }

  if(interactionMode === "plant") togglePlanting();
  cancelPolygonDraw(true);

  interactionMode = "facade";
  btn.classList.add("facading");
  btn.innerHTML = `<i class="fa-solid fa-square-check"></i> Click a building to add ${f.name} facade`;
  viewer.canvas.style.cursor = "crosshair";
  closePopup();
  if(!silent) showToast("Facade mode ON");
  // Ensure camera controls remain consistent in facade mode
  resetCameraControls();
}

/* ==============================
   GREEN FACADE SQUARE PLACEMENT
================================ */
function enuSquareCorners(centerCartesian, sizeM, liftM){
  const half = sizeM / 2;
  const m = Cesium.Transforms.eastNorthUpToFixedFrame(centerCartesian);

  const cornersLocal = [
    new Cesium.Cartesian3(-half, -half, liftM),
    new Cesium.Cartesian3( half, -half, liftM),
    new Cesium.Cartesian3( half,  half, liftM),
    new Cesium.Cartesian3(-half,  half, liftM)
  ];

  return cornersLocal.map(v => {
    const out = new Cesium.Cartesian3();
    return Cesium.Matrix4.multiplyByPoint(m, v, out);
  });
}

/* Patch: prevent duplicates per BAG */
const facadeByBag = new Map();
function registerFacadeForBag(bag, entity){
  if(!bag || !entity) return;

  const old = facadeByBag.get(bag);
  if(old && old !== entity && viewer.entities.contains(old)){
    viewer.entities.remove(old);
  }
  facadeByBag.set(bag, entity);

  updateSim();
}

function addFacadeSquareAt(cartesian, meta){
  const f = facadeTypes[selectedFacadeType] || facadeTypes.ivy;
  const corners = enuSquareCorners(cartesian, 6.0, 0.35);

  const ent = viewer.entities.add({
    polygon: {
      hierarchy: corners,
      perPositionHeight: true,
      material: Cesium.Color.fromCssColorString(f.color).withAlpha(0.85),
      outline: true,
      outlineColor: Cesium.Color.WHITE.withAlpha(0.85)
    },
    label: {
      text: f.name,
      font: "10px Inter",
      pixelOffset: new Cesium.Cartesian2(0, -16),
      distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 700),
      disableDepthTestDistance: Number.POSITIVE_INFINITY,
      fillColor: Cesium.Color.WHITE,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 4
    }
  });

  ent._type = "facade_square";
  ent._data = { ...f };
  ent._meta = meta || { bag: "", bouwjaar: "", areaM2: null };

  if(ent._meta && ent._meta.bag) registerFacadeForBag(ent._meta.bag, ent);

  undoStack.push({ kind: "facade_add", entity: ent });

  updateSim();
  showToast(`${f.name} facade added`);
  return ent;
}

/* ==============================
   TREE REMOVAL IMPACT (kept)
================================ */
function applyTreeRemovalImpact(tree, direction){
  if(!tree || !tree._data) return;

  const d = tree._data;
  const height = d.height || 8;

  const canopy = height * 0.75;
  const lostCO2 = d.co2Stored || (12 * height);
  const lostWater = 450 + canopy * 30;
  const tempInc = canopy * 0.03;
  const moneyLoss = canopy * 8;

  impactLoss.co2 += direction * lostCO2;
  impactLoss.water += direction * lostWater;
  impactLoss.temp += direction * tempInc;
  impactLoss.money += direction * moneyLoss;
}

/* ==============================
   SCENARIO POLYGONS (smooth draw)
================================ */
let scenarioType = "grass";
let scenarioPolygons = [];
let scenarioIdSeq = 1;

const SCENARIO_PARAMS = {
  grass: { label:"Grass",  color:"rgba(34,197,94,0.35)", outline:"#22c55e", ndviBoost:0.08, coolPerHa:0.05, waterPerHa:12000, bioPerHa:0.06, costPerM2:6 },
  shrubs:{ label:"Shrubs", color:"rgba(16,185,129,0.35)", outline:"#10b981", ndviBoost:0.12, coolPerHa:0.08, waterPerHa:16000, bioPerHa:0.09, costPerM2:10 },
  trees: { label:"Trees",  color:"rgba(34,211,238,0.30)", outline:"#22d3ee", ndviBoost:0.18, coolPerHa:0.12, waterPerHa:22000, bioPerHa:0.12, costPerM2:18 },
  mixed: { label:"Mixed",  color:"rgba(245,158,11,0.28)", outline:"#f59e0b", ndviBoost:0.15, coolPerHa:0.10, waterPerHa:19000, bioPerHa:0.11, costPerM2:14 }
  ,
  /*
   * Additional intervention types beyond traditional planting.  These
   * approximate NDVI improvements, cooling effects, stormwater
   * infiltration and biodiversity benefits using available proxy data.
   */
  raingarden: {
    label: "Rain Garden",
    color: "rgba(59,130,246,0.35)",
    outline: "#3b82f6",
    ndviBoost: 0.10,
    coolPerHa: 0.08,
    waterPerHa: 30000,
    bioPerHa: 0.08,
    costPerM2: 20
  },
  greenroof: {
    label: "Green Roof",
    color: "rgba(34,197,94,0.25)",
    outline: "#22c55e",
    ndviBoost: 0.12,
    coolPerHa: 0.15,
    waterPerHa: 18000,
    bioPerHa: 0.09,
    costPerM2: 25
  },
  permeable: {
    label: "Permeable",
    color: "rgba(107,114,128,0.35)",
    outline: "#6b7280",
    ndviBoost: 0.05,
    coolPerHa: 0.04,
    waterPerHa: 26000,
    bioPerHa: 0.02,
    costPerM2: 12
  },
  shading: {
    label: "Shading",
    color: "rgba(250,204,21,0.30)",
    outline: "#facc15",
    ndviBoost: 0.00,
    coolPerHa: 0.20,
    waterPerHa: 5000,
    bioPerHa: 0.00,
    costPerM2: 15
  },
  removeimpervious: {
    label: "Remove Impervious",
    color: "rgba(236,72,153,0.30)",
    outline: "#ec4899",
    ndviBoost: 0.06,
    coolPerHa: 0.06,
    waterPerHa: 24000,
    bioPerHa: 0.05,
    costPerM2: 8
  }
};

function selectScenarioType(type, el){
  scenarioType = type;
  document.querySelectorAll(".sc-type").forEach(x => x.classList.remove("selected"));
  el.classList.add("selected");
}

let drawState = {
  active: false,
  positions: [],
  tempPos: null,
  polygonEntity: null,
  vertexEntities: [],
  usedFreehand: false,
  pencil: { active: false, lastAdd: 0, lastPos: null }
};

function startPolygonDraw(){
  if(interactionMode === "plant") togglePlanting();
  if(interactionMode === "facade") toggleFacading(true);

  interactionMode = "draw";
  drawState.active = true;
  drawState.positions = [];
  drawState.tempPos = null;
  drawState.usedFreehand = false;
  drawState.pencil.active = false;
  drawState.pencil.lastAdd = 0;
  drawState.pencil.lastPos = null;

  if(drawState.polygonEntity) viewer.entities.remove(drawState.polygonEntity);
  drawState.vertexEntities.forEach(v => viewer.entities.remove(v));
  drawState.vertexEntities = [];

  const p = SCENARIO_PARAMS[scenarioType];

  drawState.polygonEntity = viewer.entities.add({
    polygon: {
      hierarchy: new Cesium.CallbackProperty(() => {
        const pts = drawState.positions.slice();
        if(drawState.tempPos) pts.push(drawState.tempPos);
        if(pts.length < 3) return undefined;
        return new Cesium.PolygonHierarchy(pts);
      }, false),
      material: Cesium.Color.fromCssColorString(p.color),
      outline: true,
      outlineColor: Cesium.Color.fromCssColorString(p.outline),
      perPositionHeight: false,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      classificationType: Cesium.ClassificationType.BOTH
    }
  });
  drawState.polygonEntity._type = "draw_preview";

  showToast("Draw: click points. Right-click to finish. SHIFT+drag = smooth freehand.");
  closePopup();
  viewer.canvas.style.cursor = "crosshair";
}

function cancelPolygonDraw(silent=false){
  if(interactionMode !== "draw" && !drawState.active){
    if(!silent) showToast("Nothing to cancel");
    return;
  }
  drawState.active = false;
  if(interactionMode === "draw") interactionMode = "idle";
  viewer.canvas.style.cursor = "default";

  if(drawState.polygonEntity){
    viewer.entities.remove(drawState.polygonEntity);
    drawState.polygonEntity = null;
  }
  drawState.vertexEntities.forEach(v => viewer.entities.remove(v));
  drawState.vertexEntities = [];
  drawState.positions = [];
  drawState.tempPos = null;
  drawState.pencil.active = false;
  drawState.pencil.lastPos = null;
  drawState.usedFreehand = false;

  // After cancelling a draw session restore the camera controls.  Without this
  // explicit reset the default Cesium handler may continue to treat left
  // drags as rotation (the libraryâ€™s default), causing the map to spin
  // rather than pan on some deployments.  This matches the behaviour when
  // exiting planting or facade modes.
  resetCameraControls();

  if(!silent) showToast("Drawing cancelled");

  // Ensure camera controls are restored when exiting draw mode
  resetCameraControls();
}

/* ---- Smooth helpers (Chaikin + simplification) ---- */
function perpendicularDistance(p, a, b){
  const x = p[0], y = p[1];
  const x1 = a[0], y1 = a[1];
  const x2 = b[0], y2 = b[1];
  const dx = x2 - x1, dy = y2 - y1;
  if(Math.abs(dx) < 1e-12 && Math.abs(dy) < 1e-12){
    const ux = x - x1, uy = y - y1;
    return Math.sqrt(ux*ux + uy*uy);
  }
  const t = ((x - x1)*dx + (y - y1)*dy) / (dx*dx + dy*dy);
  const tt = Math.max(0, Math.min(1, t));
  const px = x1 + tt*dx;
  const py = y1 + tt*dy;
  const ux = x - px, uy = y - py;
  return Math.sqrt(ux*ux + uy*uy);
}

function rdpSimplify(points, eps){
  if(points.length <= 3) return points.slice();
  const stack = [[0, points.length - 1]];
  const keep = new Array(points.length).fill(false);
  keep[0] = keep[points.length - 1] = true;

  while(stack.length){
    const [s, e] = stack.pop();
    let maxD = -1, idx = -1;
    for(let i = s + 1; i < e; i++){
      const d = perpendicularDistance(points[i], points[s], points[e]);
      if(d > maxD){ maxD = d; idx = i; }
    }
    if(maxD > eps && idx !== -1){
      keep[idx] = true;
      stack.push([s, idx], [idx, e]);
    }
  }

  const out = [];
  for(let i=0; i<points.length; i++){
    if(keep[i]) out.push(points[i]);
  }
  return out.length >= 3 ? out : points.slice(0,3);
}

function chaikinSmooth(points, iterations, closed=true){
  let pts = points.slice();
  if(pts.length < 3) return pts;

  for(let it=0; it<iterations; it++){
    const next = [];
    const n = pts.length;
    for(let i=0; i<n; i++){
      const p0 = pts[i];
      const p1 = pts[(i+1) % n];

      if(!closed && i === n-1) break;

      const q = [0.75*p0[0] + 0.25*p1[0], 0.75*p0[1] + 0.25*p1[1]];
      const r = [0.25*p0[0] + 0.75*p1[0], 0.25*p0[1] + 0.75*p1[1]];
      next.push(q, r);
    }

    pts = closed ? next : [pts[0], ...next, pts[n-1]];
    if(pts.length > 800) break;
  }
  return pts;
}

function refinePolygonPositions(cartesians, strong){
  if(!cartesians || cartesians.length < 3) return cartesians || [];

  const cleaned = [];
  for(const p of cartesians){
    if(!cleaned.length){ cleaned.push(p); continue; }
    if(Cesium.Cartesian3.distance(p, cleaned[cleaned.length-1]) > 0.8){
      cleaned.push(p);
    }
  }
  if(cleaned.length < 3) return cartesians.slice(0,3);

  const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);

  let ptsXY = cleaned.map(c3 => {
    const carto = Cesium.Cartographic.fromCartesian(c3);
    const p = proj.project(carto);
    return [p.x, p.y];
  });

  const eps1 = strong ? 2.2 : 1.4;
  ptsXY = rdpSimplify(ptsXY, eps1);

  const smoothIter = strong ? 2 : 1;
  ptsXY = chaikinSmooth(ptsXY, smoothIter, true);

  ptsXY = rdpSimplify(ptsXY, strong ? 1.2 : 0.9);

  if(ptsXY.length < 3) ptsXY = ptsXY.concat([ptsXY[ptsXY.length-1]]).slice(0,3);

  const hVals = cleaned.map(c3 => {
    const carto = Cesium.Cartographic.fromCartesian(c3);
    return Number.isFinite(carto.height) ? carto.height : 0;
  });
  const hAvg = hVals.length ? (hVals.reduce((a,b)=>a+b,0) / hVals.length) : 0;

  const out = ptsXY.map(([x,y]) => {
    const carto = proj.unproject(new Cesium.Cartesian2(x,y));
    return Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, hAvg);
  });

  return out.length >= 3 ? out : cleaned;
}

function finalizeScenarioPolygon(){
  if(drawState.positions.length < 3){
    showToast("Need at least 3 points");
    return;
  }

  let pts = drawState.positions.slice();

  const strong = drawState.usedFreehand || pts.length > 80;
  pts = refinePolygonPositions(pts, strong);

  const p = SCENARIO_PARAMS[scenarioType];

  const poly = viewer.entities.add({
    polygon: {
      hierarchy: new Cesium.PolygonHierarchy(pts),
      material: Cesium.Color.fromCssColorString(p.color),
      outline: true,
      outlineColor: Cesium.Color.fromCssColorString(p.outline),
      perPositionHeight: false,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      classificationType: Cesium.ClassificationType.BOTH
    }
  });

  if(drawState.polygonEntity){
    viewer.entities.remove(drawState.polygonEntity);
    drawState.polygonEntity = null;
  }
  drawState.vertexEntities.forEach(v => viewer.entities.remove(v));
  drawState.vertexEntities = [];

  const areaM2 = polygonAreaM2(pts);
  const centroidCarto = polygonCentroidCartographic(pts);

  const centroidLat = centroidCarto ? Cesium.Math.toDegrees(centroidCarto.latitude) : null;
  const centroidLon = centroidCarto ? Cesium.Math.toDegrees(centroidCarto.longitude) : null;

  let env = { ndvi:"0.15", uhi:"34.5Â°C", uhiVal:34.5 };
  if(centroidLat !== null && centroidLon !== null){
    env = getPixelData(centroidLat, centroidLon);
  }

  const impacts = scenarioImpacts(scenarioType, areaM2, env, centroidCarto);

  poly._type = "scenario_poly";
  poly._data = impacts;
  poly._scenarioId = scenarioIdSeq;

  undoStack.push({ kind: "scenario_add", entity: poly });

  const rec = {
    id: scenarioIdSeq++,
    entity: poly,
    type: scenarioType,
    areaM2,
    impacts,
    centroidLatLon: (centroidLat !== null) ? {lat: centroidLat, lon: centroidLon} : null
  };
  scenarioPolygons.push(rec);

  drawState.active = false;
  interactionMode = "idle";
  viewer.canvas.style.cursor = "default";

  // After finalising a scenario polygon reset camera controls to ensure
  // intuitive panning.  Without this the screenâ€‘space controller may retain
  // modeâ€‘specific event mappings causing the globe to rotate when attempting
  // to pan.
  resetCameraControls();

  updateScenarioList();
  updateSim();
  showToast("Scenario applied");
}

function updateScenarioList(){
  const box = document.getElementById("scenarioList");
  box.innerHTML = "";

  if(scenarioPolygons.length === 0){
    box.innerHTML = `<div style="font-size:11px;color:rgba(226,232,240,0.62);margin-top:10px;">No scenario polygons yet.</div>`;
    return;
  }

  scenarioPolygons.forEach(s => {
    const p = SCENARIO_PARAMS[s.type];
    const div = document.createElement("div");
    div.className = "scenario-item";
    div.innerHTML = `
      <div>
        <strong>#${s.id} ${p.label}</strong>
        <small>
          ${formatArea(s.areaM2)}
          Â· NDVI ${s.impacts.ndviBefore.toFixed(2)} â†’ ${s.impacts.ndviAfter.toFixed(2)}
          Â· Cooling -${s.impacts.cooling.toFixed(3)}Â°C
          Â· Stormwater -${Math.round(s.impacts.waterDelta).toLocaleString()} L/yr
          Â· Cost â‚¬${Math.round(s.impacts.cost).toLocaleString()}
        </small>
      </div>
      <button title="Remove" onclick="removeScenario(${s.id}); event.stopPropagation();"><i class="fa-solid fa-trash"></i></button>
    `;
    div.onclick = () => {
      if(s.centroidLatLon){
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(s.centroidLatLon.lon, s.centroidLatLon.lat, 240),
          duration: 1.2
        });
      }
    };
    box.appendChild(div);
  });
}

function removeScenario(id){
  const idx = scenarioPolygons.findIndex(x => x.id === id);
  if(idx === -1) return;

  const s = scenarioPolygons[idx];
  if(s.entity) viewer.entities.remove(s.entity);
  scenarioPolygons.splice(idx, 1);

  updateScenarioList();
  updateSim();
  showToast("Scenario removed");
}

function scenarioImpacts(type, areaM2, env, centroidCarto){
  const prm = SCENARIO_PARAMS[type];
  const areaHa = areaM2 / 10000.0;

  const ndviBefore = clamp(parseFloat(env.ndvi), 0, 1);
  const ndviAfter = clamp(ndviBefore + prm.ndviBoost, 0, 1);

  const cooling = prm.coolPerHa * areaHa;
  const waterDelta = prm.waterPerHa * areaHa;
  const cost = prm.costPerM2 * areaM2;

  const corridorBonus = (centroidCarto && isNearCorridor(centroidCarto, 100)) ? 1 : 0;

  const bioBefore = habitatScore(ndviBefore, areaM2, corridorBonus);
  const bioAfter  = habitatScore(ndviAfter,  areaM2, corridorBonus);

  const bioDelta = Math.max(0, bioAfter - bioBefore) + (prm.bioPerHa * areaHa * 0.15);

  return { kind: "scenario_poly", type, areaM2, ndviBefore, ndviAfter, cooling, waterDelta, bioDelta, cost, corridorBonus };
}

function habitatScore(ndvi, areaM2, corridorBonus){
  const ndviNorm = clamp((ndvi - 0.05) / (0.65 - 0.05), 0, 1);
  const areaNorm = clamp(areaM2 / 20000.0, 0, 1);
  return 0.6*ndviNorm + 0.3*areaNorm + 0.1*corridorBonus;
}

function isNearCorridor(carto, thresholdM){
  if(!carto || !corridorPolylines.length) return false;
  const p = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
  let best = Infinity;

  for(const seg of corridorPolylines){
    for(const q of seg){
      const d = Cesium.Cartesian3.distance(p, q);
      if(d < best) best = d;
    }
  }
  return best <= thresholdM;
}

/* ==============================
   UPDATE SIM
================================ */
function updateSim(){
  let totalCost = 0, totalCO2 = 0, totalUHI = 0, totalBio = 1.20, totalWater = 0;
  let newTreeCount = 0, facadeCount = 0;

  const entities = viewer.entities.values;
  for(const e of entities){
    if(e._type === "tree_new" && e._data){
      newTreeCount++;
      totalCost += e._data.cost;

      const spec = speciesData[e._data.specKey] || speciesData.oak;
      const age = Math.max(1, currentYear - (e._data.plantedYear || 1) + 1);
      const annualCO2 = treeAnnualCO2(spec, age);

      totalCO2 += annualCO2;
      totalUHI += (e._data.uhi || 0) * clamp(age/20, 0.3, 1.0);
      totalBio += (e._data.bio || 0) * clamp(age/20, 0.3, 1.0);
      totalWater += (e._data.water || 0) * clamp(age/20, 0.3, 1.0);
    }
    else if(e._type === "facade_square" && e._data){
      facadeCount++;
      totalCost += e._data.cost;
      totalCO2 += e._data.co2;
      totalUHI += e._data.uhi;
      totalBio += e._data.bio;
      totalWater += e._data.water;
    }
    else if(e._type === "scenario_poly" && e._data){
      totalCost += e._data.cost;
      totalUHI  += e._data.cooling;
      totalBio  += e._data.bioDelta;
      totalWater += e._data.waterDelta;
    }
  }

  sim = { trees: newTreeCount, facades: facadeCount, cost: totalCost, co2: totalCO2, uhi: totalUHI, bio: totalBio, water: totalWater };

  const netCO2 = sim.co2 - impactLoss.co2;
  const netWater = sim.water - impactLoss.water;
  const netUHI = sim.uhi - impactLoss.temp;
  const netCost = sim.cost - impactLoss.money;

  document.getElementById("valTrees").innerText = sim.trees;
  document.getElementById("valFacades").innerText = sim.facades;

  // Values for impact overview are updated via gauges; the old
  // valCO2/valCost/valUHI/valWater elements have been removed.

  document.getElementById("valCutTemp").innerText = "+" + impactLoss.temp.toFixed(3) + "Â°C";

  if(tradeoffChart){
    const maxCost = 20000, maxCO2 = 600, maxCool = 0.5, maxBio = 2.0;
    tradeoffChart.data.datasets[0].data = [
      Math.min((Math.abs(netCost) / maxCost) * 100, 100),
      Math.min((Math.abs(netCO2) / maxCO2) * 100, 100),
      Math.min((Math.abs(netUHI) / maxCool) * 100, 100),
      Math.min(((sim.bio - 1.2) / (maxBio - 1.2)) * 100, 100)
    ];
    tradeoffChart.update();
  }

  updateComparisonPanel();
}

function updateComparisonPanel(){
  const netCO2 = sim.co2 - impactLoss.co2;
  const netWater = sim.water - impactLoss.water;
  const netUHI = sim.uhi - impactLoss.temp;
  const netCost = sim.cost - impactLoss.money;

  const maxCo2 = 600, maxWater = 25000, maxCool = 0.5, maxCost = 20000;

  const pctCo2 = Math.min(Math.abs(netCO2) / maxCo2 * 100, 100);
  const pctWater = Math.min(Math.abs(netWater) / maxWater * 100, 100);
  const pctCool = Math.min(Math.abs(netUHI) / maxCool * 100, 100);
  const pctCost = Math.min(Math.abs(netCost) / maxCost * 100, 100);

  document.getElementById("cmpCo2Before").style.width = "0%";
  document.getElementById("cmpCo2After").style.width = pctCo2 + "%";
  document.getElementById("cmpCo2Text").innerText = `Baseline 0 â†’ ${Math.round(netCO2).toLocaleString()} kg/yr`;
  document.getElementById("cmpCo2Delta").innerText = (netCO2 >= 0)
    ? `Gain of ${Math.round(netCO2).toLocaleString()} kg COâ‚‚/yr`
    : `Loss of ${Math.round(-netCO2).toLocaleString()} kg COâ‚‚/yr`;

  document.getElementById("cmpUhiBefore").style.width = "0%";
  document.getElementById("cmpUhiAfter").style.width = pctCool + "%";
  const coolingDisplay = (netUHI >= 0 ? "-" : "+") + Math.abs(netUHI).toFixed(3) + "Â°C";
  document.getElementById("cmpUhiText").innerText = `Baseline 0 â†’ ${coolingDisplay}`;
  document.getElementById("cmpUhiDelta").innerText = (netUHI >= 0)
    ? `Cooling of ${Math.abs(netUHI).toFixed(3)}Â°C`
    : `Net warming of ${Math.abs(netUHI).toFixed(3)}Â°C`;

  document.getElementById("cmpWaterBefore").style.width = "0%";
  document.getElementById("cmpWaterAfter").style.width = pctWater + "%";
  const waterDisplay = (netWater >= 0 ? "-" : "+") + Math.abs(Math.round(netWater)).toLocaleString() + " L/yr";
  document.getElementById("cmpWaterText").innerText = `Baseline 0 â†’ ${waterDisplay}`;
  document.getElementById("cmpWaterDelta").innerText = (netWater >= 0)
    ? `Reduced runoff by ${Math.round(netWater).toLocaleString()} L/yr`
    : `Extra ${Math.round(-netWater).toLocaleString()} L/yr runoff`;

  document.getElementById("cmpCostBefore").style.width = "0%";
  document.getElementById("cmpCostAfter").style.width = pctCost + "%";
  document.getElementById("cmpCostText").innerText = `Baseline â‚¬0 â†’ â‚¬${Math.round(netCost).toLocaleString()}`;
  document.getElementById("cmpCostDelta").innerText = (netCost >= 0)
    ? `Investment of â‚¬${Math.round(netCost).toLocaleString()}`
    : `Asset loss of â‚¬${Math.round(-netCost).toLocaleString()}`;

  // Update impact overview gauges with current net values
  updateAllGauges(netCO2, netWater, netUHI, netCost);

  // Also update the biodiversity gauge based on the change in habitat proxy.
  // The base biodiversity value is 1.20 (no interventions).  Any
  // interventions that increase habitat suitability add to sim.bio.  We
  // normalise the delta (sim.bio - 1.20) against an approximate maximum
  // delta of 1.0 to compute a percentage for the gauge.  Values below
  // zero (i.e., net biodiversity loss) are displayed as negative values.
  const netBio = sim.bio - 1.20;
  const maxBio = 1.0;
  const pctBio = Math.min(Math.abs(netBio) / maxBio * 100, 100);
  if (gaugeBio) {
    gaugeBio.data.datasets[0].data[0] = pctBio;
    gaugeBio.data.datasets[0].data[1] = 100 - pctBio;
    gaugeBio.update();
    const valEl = document.getElementById('gaugeBioValue');
    if (valEl) valEl.innerText = netBio.toFixed(2);
  }
}

function toggleCompare(){
  const body = document.getElementById("compareBody");
  body.style.display = (body.style.display === "none") ? "block" : "none";
}

/* ==============================
   GROWTH + SUN + SHADOWS
================================ */
function updateGrowth(year){
  currentYear = parseInt(year);
  document.getElementById("lblYear").innerText = "Year " + currentYear;

  for(const e of viewer.entities.values){
    if(e._type === "tree_new" && e.point){
      const baseSize = 5;
      e.point.pixelSize = new Cesium.ConstantProperty(baseSize * (0.6 + (currentYear/30)*0.6));
    }
  }
  updateSim();
}

function updateSun(val){
  const time = parseFloat(val);
  const hours = Math.floor(time);
  const mins = Math.floor((time - hours) * 60);

  document.getElementById("lblTime").innerText =
    `${String(hours).padStart(2,"0")}:${String(mins).padStart(2,"0")}`;

  const date = new Date();
  date.setMonth(5);
  date.setDate(21);
  date.setHours(hours);
  date.setMinutes(mins);
  date.setSeconds(0);

  viewer.clock.currentTime = Cesium.JulianDate.fromDate(date);
  viewer.scene.requestRender();
}

function toggleShadowsFromSlider(val){
  const on = String(val) === "1";
  document.getElementById("lblShadows").innerText = on ? "ON" : "OFF";

  viewer.shadowMap.enabled = on;
  viewer.shadows = on;
  viewer.scene.globe.enableLighting = on;

  if(lod22Tileset){
    lod22Tileset.shadows = on ? Cesium.ShadowMode.ENABLED : Cesium.ShadowMode.DISABLED;
  }
  viewer.scene.requestRender();
}

/* ==============================
   PDF REPORT + CHART
================================ */
function scenarioSummaryLines(){
  const lines = [];
  let totalArea = 0;
  scenarioPolygons.forEach(s => totalArea += s.areaM2);

  lines.push(`Scenario polygons: ${scenarioPolygons.length}`);
  if(scenarioPolygons.length > 0){
    lines.push(`Total scenario area: ${formatArea(totalArea)}`);
    scenarioPolygons.slice(0,8).forEach(s => {
      const p = SCENARIO_PARAMS[s.type];
      lines.push(`#${s.id} ${p.label} Â· ${formatArea(s.areaM2)} Â· NDVI ${s.impacts.ndviBefore.toFixed(2)}â†’${s.impacts.ndviAfter.toFixed(2)} Â· Cool -${s.impacts.cooling.toFixed(3)}Â°C Â· Water -${Math.round(s.impacts.waterDelta)} L/yr Â· â‚¬${Math.round(s.impacts.cost)}`);
    });
    if(scenarioPolygons.length > 8) lines.push(`... +${scenarioPolygons.length - 8} more`);
  }
  return lines;
}

async function downloadReport(){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit: "mm", format: "a4" });

  let imgData = "";
  try{
    viewer.scene.requestRender();
    await new Promise(r => setTimeout(r, 250));
    imgData = viewer.canvas.toDataURL("image/png", 0.95);
  }catch(e){
    console.warn("Snapshot failed:", e);
  }

  let y = 10;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(14);
  doc.text("TWEKKELERVELD ECOLOGY DIGITAL TWIN â€” REPORT", 10, y);
  y += 4;

  if(imgData){
    doc.addImage(imgData, "PNG", 10, y, 190, 90);
    y += 98;
  }else{
    y += 10;
  }

  const netCO2 = sim.co2 - impactLoss.co2;
  const netWater = sim.water - impactLoss.water;
  const netUHI = sim.uhi - impactLoss.temp;
  const netCost = sim.cost - impactLoss.money;

  const reportCooling = (netUHI >= 0 ? "-" : "+") + Math.abs(netUHI).toFixed(3);
  const reportWater  = (netWater >= 0 ? "-" : "+") + Math.abs(Math.round(netWater)).toLocaleString();

  doc.setFont("courier", "normal");
  doc.setFontSize(10);

  const lines = [
    `Date: ${new Date().toLocaleString()}`,
    `Simulated Timeframe: Year ${currentYear}`,
    "",
    "SCENARIO SUMMARY:",
    "-----------------",
    `New Trees Planted:      ${sim.trees}`,
    `Green Facades Added:    ${sim.facades}`,
    `Scenario Investment:    â‚¬${Math.round(netCost).toLocaleString()}`,
    "",
    `COâ‚‚ Sequestration:      +${Math.round(netCO2).toLocaleString()} kg/year`,
    `Stormwater (runoff Î”):  ${reportWater} L/year (negative = less runoff)`,
    `Temperature (UHI Î”):    ${reportCooling} Â°C (negative = cooling)`,
    `Tree Removal Temp Cost: +${impactLoss.temp.toFixed(3)} Â°C`,
    "",
    "SCENARIO POLYGONS:",
    "-----------------",
    ...scenarioSummaryLines(),
    "",
    "Notes:",
    "- Map snapshot shows current layers + user edits (trees, polygons, facade squares).",
    "- COâ‚‚ for new trees uses a growth curve (annual sequestration peaks mid-age).",
    "- Biodiversity proxy uses NDVI + area + corridor proximity."
  ];

  const wrapped = doc.splitTextToSize(lines.join("\n"), 190);
  doc.text(wrapped, 10, y);

  doc.save("Eco_Simulation_Report.pdf");
}

function downloadCharts(){
  const link = document.createElement("a");
  link.download = "Tradeoff_Chart.png";
  link.href = document.getElementById("tradeoffChart").toDataURL();
  link.click();
}

/* ==============================
   EXPORT SCENARIO GEOJSON
================================ */
function exportScenarioGeoJSON(){
  const features = [];

  scenarioPolygons.forEach(s => {
    if(!s.entity || !s.entity.polygon) return;

    const t = viewer.clock.currentTime || Cesium.JulianDate.now();
    const positions = safePolygonPositions(s.entity.polygon, t);

    const coords = positions.map(c => {
      const carto = Cesium.Cartographic.fromCartesian(c);
      return [Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude)];
    });
    if(coords.length > 0) coords.push(coords[0]);

    features.push({
      type: "Feature",
      properties: {
        scenario_id: s.id,
        type: s.type,
        area_m2: s.areaM2,
        bio_delta: s.impacts.bioDelta,
        cooling_c: s.impacts.cooling,
        water_delta_l_yr: s.impacts.waterDelta,
        cost_eur: s.impacts.cost
      },
      geometry: { type: "Polygon", coordinates: [coords] }
    });
  });

  const gj = { type:"FeatureCollection", features };
  const blob = new Blob([JSON.stringify(gj, null, 2)], { type: "application/geo+json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "scenario_polygons.geojson";
  a.click();

  URL.revokeObjectURL(url);
  showToast("Scenario GeoJSON exported");
}

/* ==============================
   MCDA (priorities with more variance)
================================ */
let mcdaMarkers = [];
let recommendations = [];

function clearMCDA(){
  mcdaMarkers.forEach(m => viewer.entities.remove(m));
  mcdaMarkers = [];
  recommendations = [];

  const listEl = document.getElementById("recList");
  listEl.innerHTML = `<div class="rec-item"><div class="rec-title">No priorities yet</div><div class="rec-meta">Run the wizard to generate ranked buildings.</div></div>`;
  showToast('Priority markers cleared');
}

function normalizeYearOlderIsHigher(yearStr){
  const y = parseInt(String(yearStr || "").replace(/[^\d]/g, ""), 10);
  if(!Number.isFinite(y) || y < 1600 || y > NOW_YEAR) return 0.35;
  const age = NOW_YEAR - y;
  return clamp(age / 120, 0, 1);
}
function normalizeArea(areaM2){
  const a = Number(areaM2);
  if(!Number.isFinite(a) || a <= 0) return 0.25;
  return clamp(a / 500, 0, 1);
}

function runMCDA(){
  if(!lod1Ds){
    showToast('Building attributes not loaded yet');
    return;
  }

  const obj = document.getElementById('mcdaObjective').value;
  const corr = document.getElementById('mcdaCorridor').value;
  const budget = document.getElementById('mcdaBudget').value;
  const topN = clamp(parseInt(document.getElementById('mcdaTopN').value || '5'), 1, 15);

  // Base weights for MCDA.  These may be overridden by the objective
  // dropdown or by custom values provided via ECO_SETTINGS.  If
  // ECO_SETTINGS.weights is defined the custom values supersede the
  // objective presets and corridor adjustment below.
  let wU = 0.46, wN = 0.28, wC = 0.10, wA = 0.08, wR = 0.08;
  let customWeights = null;
  try {
    if (window.ECO_SETTINGS && window.ECO_SETTINGS.weights) {
      customWeights = window.ECO_SETTINGS.weights;
    }
  } catch (e) { customWeights = null; }
  if (!customWeights) {
    if(obj === 'cooling'){      wU = 0.55; wN = 0.20; wC = 0.10; wA = 0.05; wR = 0.10; }
    if(obj === 'biodiversity'){ wU = 0.32; wN = 0.42; wC = 0.14; wA = 0.06; wR = 0.06; }
    if(obj === 'stormwater'){   wU = 0.38; wN = 0.26; wC = 0.12; wA = 0.06; wR = 0.18; }
    if(obj === 'balanced'){     wU = 0.46; wN = 0.28; wC = 0.10; wA = 0.08; wR = 0.08; }
    if(corr === 'high'){ wC += 0.06; wU -= 0.03; wN -= 0.03; }
  } else {
    wU = (customWeights.uhi      !== undefined) ? customWeights.uhi      : wU;
    wN = (customWeights.ndvi     !== undefined) ? customWeights.ndvi     : wN;
    wC = (customWeights.corridor !== undefined) ? customWeights.corridor : wC;
    wA = (customWeights.age      !== undefined) ? customWeights.age      : wA;
    wR = (customWeights.area     !== undefined) ? customWeights.area     : wR;
  }

  // Additional: Override weights using sliders from MCDA wizard and apply corridor factor.
  try {
    const wuElem = document.getElementById('mcdaWeightU');
    const wnElem = document.getElementById('mcdaWeightN');
    const wcElem = document.getElementById('mcdaWeightC');
    const waElem = document.getElementById('mcdaWeightA');
    const wrElem = document.getElementById('mcdaWeightR');
    if (wuElem && wnElem && wcElem && waElem && wrElem) {
      const wUval = parseFloat(wuElem.value || '0');
      const wNval = parseFloat(wnElem.value || '0');
      const wCval = parseFloat(wcElem.value || '0');
      const wAval = parseFloat(waElem.value || '0');
      const wRval = parseFloat(wrElem.value || '0');
      let sumW = wUval + wNval + wCval + wAval + wRval;
      if(!sumW || sumW <= 0){ sumW = 1; }
      wU = wUval / sumW;
      wN = wNval / sumW;
      wC = wCval / sumW;
      wA = wAval / sumW;
      wR = wRval / sumW;
      const cfElem = document.getElementById('mcdaCorrFactor');
      if(cfElem){
        const cf = parseFloat(cfElem.value || '1');
        if(Number.isFinite(cf) && cf > 0){
          const adjusted = wC * cf;
          const totalW = wU + wN + wA + wR + adjusted;
          wU = wU / totalW;
          wN = wN / totalW;
          wA = wA / totalW;
          wR = wR / totalW;
          wC = adjusted / totalW;
        }
      }
    }
  } catch(e){}

  // store used weights globally for breakdown and export
  window.lastMCDAWeights = { wU: wU, wN: wN, wC: wC, wA: wA, wR: wR };

  const prefer = (budget === 'low') ? 'shrubs' : (budget === 'medium' ? 'mixed' : 'trees');

  const candidates = [];
  lod1Ds.entities.values.forEach(e => {
    if(e._type !== 'lod1_building' || !e._centroid) return;

    const env = e._env || getPixelData(e._centroid.lat, e._centroid.lon);
    const nd = parseFloat(env.ndvi);
    const uh = env.uhiVal || 0;

    const nearCorr = isNearCorridor(Cesium.Cartographic.fromDegrees(e._centroid.lon, e._centroid.lat), 120) ? 1 : 0;

    const uhiTerm = clamp((uh - 30) / 10, 0, 1);
    const ndviTerm = clamp((0.55 - nd) / 0.55, 0, 1);

    const ageTerm = normalizeYearOlderIsHigher(e._bouwjaar);
    const areaTerm = normalizeArea(e._areaM2);

    const score = (wU*uhiTerm) + (wN*ndviTerm) + (wC*nearCorr) + (wA*ageTerm) + (wR*areaTerm);

    if(score < 0.24) return;

    candidates.push({
      entity: e,
      lat: e._centroid.lat,
      lon: e._centroid.lon,
      env,
      nearCorr,
      score,
      suggestType: prefer,
      breakdown: {
        uhi: uhiTerm,
        ndvi: ndviTerm,
        corr: nearCorr,
        age: ageTerm,
        area: areaTerm
      }
    });
  });

  candidates.sort((a,b) => b.score - a.score);

  const chosen = [];
  const minDistM = 90;
  // read budget limits for number of interventions and total area
  let maxTrees = parseInt((document.getElementById('mcdaMaxTrees') && document.getElementById('mcdaMaxTrees').value) ? document.getElementById('mcdaMaxTrees').value : '0');
  if(!Number.isFinite(maxTrees) || maxTrees <= 0) maxTrees = topN;
  let maxArea = parseFloat((document.getElementById('mcdaMaxArea') && document.getElementById('mcdaMaxArea').value) ? document.getElementById('mcdaMaxArea').value : '0');
  if(!Number.isFinite(maxArea) || maxArea <= 0) maxArea = Infinity;
  const finalLimit = Math.min(topN, maxTrees);
  let areaSum = 0;
  for(const c of candidates){
    if(chosen.length >= finalLimit) break;
    // compute area for budget constraint
    const areaVal = (c.entity && c.entity._areaM2) ? Number(c.entity._areaM2) : 0;
    // skip if adding this candidate would exceed area budget
    if(areaSum + areaVal > maxArea) continue;
    const cp = Cesium.Cartesian3.fromDegrees(c.lon, c.lat, 0);
    let ok = true;
    for(const s of chosen){
      const sp = Cesium.Cartesian3.fromDegrees(s.lon, s.lat, 0);
      if(Cesium.Cartesian3.distance(cp, sp) < minDistM){ ok = false; break; }
    }
    if(ok){
      chosen.push(c);
      areaSum += areaVal;
    }
  }
  if(chosen.length < finalLimit){
    for(const c of candidates){
      if(chosen.length >= finalLimit) break;
      if(chosen.includes(c)) continue;
      const areaVal = (c.entity && c.entity._areaM2) ? Number(c.entity._areaM2) : 0;
      if(areaSum + areaVal > maxArea) continue;
      chosen.push(c);
      areaSum += areaVal;
    }
  }

  recommendations = chosen;

  mcdaMarkers.forEach(m => viewer.entities.remove(m));
  mcdaMarkers = [];

  const t0 = Cesium.JulianDate.now();
  recommendations.forEach((r, idx) => {
    const marker = viewer.entities.add({
      position: new Cesium.ConstantPositionProperty(Cesium.Cartesian3.fromDegrees(r.lon, r.lat, 4)),
      point: {
        pixelSize: new Cesium.CallbackProperty((time) => {
          const dt = Math.max(0, Cesium.JulianDate.secondsDifference(time, t0));
          return 12 + 7*Math.abs(Math.sin(dt*2.1 + idx*0.9));
        }, false),
        color: Cesium.Color.fromCssColorString('#2dd4bf').withAlpha(0.9),
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 2,
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      },
      label: {
        text: `Priority ${idx+1}`,
        font: '11px Inter',
        pixelOffset: new Cesium.Cartesian2(0, -18),
        fillColor: Cesium.Color.WHITE,
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 4,
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 1200),
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      }
    });
    marker._type = 'mcda_marker';
    marker._idx = idx;
    marker._lod1 = r.entity;
    mcdaMarkers.push(marker);
  });

  const listEl = document.getElementById('recList');
  listEl.innerHTML = '';
  if(recommendations.length === 0){
    listEl.innerHTML = `<div class="rec-item"><div class="rec-title">No priorities detected</div><div class="rec-meta">Area already well vegetated.</div></div>`;
    showToast('No priorities found');
    return;
  }
  // prepare weights for breakdown display
  const weightsUsed = (window.lastMCDAWeights ? window.lastMCDAWeights : { wU: wU, wN: wN, wC: wC, wA: wA, wR: wR });
  recommendations.forEach((rec, idx) => {
    const div = document.createElement('div');
    div.className = 'rec-item';
    // compute contributions
    const uContr = (rec.breakdown.uhi * weightsUsed.wU);
    const nContr = (rec.breakdown.ndvi * weightsUsed.wN);
    const cContr = (rec.breakdown.corr * weightsUsed.wC);
    const aContr = (rec.breakdown.age * weightsUsed.wA);
    const rContr = (rec.breakdown.area * weightsUsed.wR);
    const score = rec.score;
    div.innerHTML = `
      <details class="rec-breakdown" style="cursor:pointer;">
        <summary>
          <div class="rec-title">Priority ${idx+1} Â· Suggested: ${SCENARIO_PARAMS[rec.suggestType].label}</div>
          <div class="rec-meta">Score: ${(score*100).toFixed(1)}/100 (click to expand)</div>
        </summary>
        <div class="rec-meta">UHI normalized: ${rec.breakdown.uhi.toFixed(2)} (weight ${weightsUsed.wU.toFixed(2)}, contrib ${uContr.toFixed(2)})</div>
        <div class="rec-meta">NDVI deficit: ${rec.breakdown.ndvi.toFixed(2)} (weight ${weightsUsed.wN.toFixed(2)}, contrib ${nContr.toFixed(2)})</div>
        <div class="rec-meta">Corridor proximity: ${rec.breakdown.corr.toFixed(2)} (weight ${weightsUsed.wC.toFixed(2)}, contrib ${cContr.toFixed(2)})</div>
        <div class="rec-meta">Age: ${rec.breakdown.age.toFixed(2)} (weight ${weightsUsed.wA.toFixed(2)}, contrib ${aContr.toFixed(2)})</div>
        <div class="rec-meta">Area: ${rec.breakdown.area.toFixed(2)} (weight ${weightsUsed.wR.toFixed(2)}, contrib ${rContr.toFixed(2)})</div>
        <div class="rec-meta" style="margin-top:6px;color:rgba(226,232,240,0.80);">Click on summary again to collapse</div>
      </details>
    `;
    div.onclick = () => {
      viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(rec.lon, rec.lat, 250), duration: 1.2 });
      showToast(`Zoomed to Priority ${idx+1}`);
    };
    listEl.appendChild(div);
  });

  closeMCDA();
  showToast('Priorities updated');
}

// Helper to update weight label values when sliders change
function updateMcdaWeightLabel(sliderId, labelId){
  const slider = document.getElementById(sliderId);
  const label = document.getElementById(labelId);
  if(slider && label){
    const val = parseFloat(slider.value || '0');
    label.textContent = val.toFixed(2);
  }
}

// Export MCDA recommendations to CSV or JSON
function exportMCDA(format){
  if(!window.recommendations || !Array.isArray(window.recommendations) || window.recommendations.length === 0){
    showToast('No priorities to export');
    return;
  }
  const weights = window.lastMCDAWeights || {};
  if(format === 'json'){
    const rows = window.recommendations.map((rec, idx) => ({
      rank: idx+1,
      lat: rec.lat,
      lon: rec.lon,
      uhi: rec.breakdown.uhi,
      ndvi: rec.breakdown.ndvi,
      corridor: rec.breakdown.corr,
      age: rec.breakdown.age,
      area: rec.breakdown.area,
      score: rec.score
    }));
    const jsonObj = { weights: weights, results: rows };
    const jsonStr = JSON.stringify(jsonObj, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'mcda_results.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('MCDA results exported as JSON');
  } else {
    // build CSV string including weights for transparency
    let csv = 'weights_uhi,weights_ndvi,weights_corridor,weights_age,weights_area\n';
    csv += `${weights.wU ?? ''},${weights.wN ?? ''},${weights.wC ?? ''},${weights.wA ?? ''},${weights.wR ?? ''}\n`;
    csv += 'rank,lat,lon,uhi,ndvi,corridor,age,area,score\n';
    window.recommendations.forEach((rec, idx) => {
      csv += `${idx+1},${rec.lat},${rec.lon},${rec.breakdown.uhi},${rec.breakdown.ndvi},${rec.breakdown.corr},${rec.breakdown.age},${rec.breakdown.area},${rec.score}\n`;
    });
    const blob = new Blob([csv], { type:'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'mcda_results.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('MCDA results exported as CSV');
  }
}

// Sensitivity analysis: vary each weight Â±20% and check if top 5 rankings change
function sensitivityTest(){
  if(!window.recommendations || window.recommendations.length === 0){
    showToast('Run MCDA first to test sensitivity');
    return;
  }
  const base = window.lastMCDAWeights || { wU:0.46, wN:0.28, wC:0.10, wA:0.08, wR:0.08 };
  // generate varied weights
  const vary = (w) => {
    const factor = 0.8 + Math.random() * 0.4; // 0.8 to 1.2
    return w * factor;
  };
  let wU = vary(base.wU), wN = vary(base.wN), wC = vary(base.wC), wA = vary(base.wA), wR = vary(base.wR);
  const total = wU + wN + wC + wA + wR;
  wU /= total; wN /= total; wC /= total; wA /= total; wR /= total;
  // compute new scores for existing recommendations
  const scores = window.recommendations.map((rec) => rec.breakdown.uhi * wU + rec.breakdown.ndvi * wN + rec.breakdown.corr * wC + rec.breakdown.age * wA + rec.breakdown.area * wR);
  // derive order arrays
  const baselineOrder = window.recommendations.map((_, idx) => idx);
  const newOrder = baselineOrder.slice().sort((a,b) => scores[b] - scores[a]);
  let changed = false;
  for(let i=0; i<Math.min(5, newOrder.length); i++){
    if(newOrder[i] !== i){
      changed = true;
      break;
    }
  }
  showToast(changed ? 'Top 5 priorities change under Â±20% weight variation' : 'Top 5 priorities stable under Â±20% weight variation');
}

/* ==============================
   UNDO (tree + facade + scenario)
================================ */
function undoRemoval(){
  while(undoStack.length > 0){
    const peek = undoStack[undoStack.length - 1];
    if(peek.entity && viewer.entities.contains(peek.entity)) break;
    if(peek.kind === "tree_hide" && peek.entity) break;
    undoStack.pop();
  }

  if(undoStack.length === 0){
    showToast("Nothing to undo");
    return;
  }

  const last = undoStack.pop();

  if(last.kind === "tree_hide" && last.entity){
    last.entity.show = true;
    last.entity._removed = false;
    last.entity._removing = false;
    applyTreeRemovalImpact(last.entity, -1);
    updateSim();
    showToast("Existing tree restored");
    closePopup();
    return;
  }

  if(last.kind === "plant"){
    if(last.entity && viewer.entities.contains(last.entity)){
      viewer.entities.remove(last.entity);
      updateSim();
      showToast("Last tree planting undone");
      closePopup();
      return;
    }
  }

  if(last.kind === "facade_add"){
    if(last.entity && viewer.entities.contains(last.entity)){
      viewer.entities.remove(last.entity);
      updateSim();
      showToast("Last facade undone");
      closePopup();
      return;
    }
  }

  if(last.kind === "scenario_add"){
    if(last.entity && viewer.entities.contains(last.entity)){
      viewer.entities.remove(last.entity);
      updateScenarioList();
      updateSim();
      showToast("Last scenario undone");
      closePopup();
      return;
    }
  }
}

/* ==============================
   POPUP + PICK HELPERS
================================ */
let isPinned = false;

function closePopup(){
  popup.style.display = "none";
  isPinned = false;
}

function row(lbl, val){
  return `<div class="pop-row"><span class="pop-label">${lbl}</span><span class="pop-val">${val}</span></div>`;
}

// Helper to generate a table of ALL properties
function generatePropertiesTable(properties, time) {
  if (!properties) return row("Info", "No data");
  
  // Get all property names
  const keys = properties.propertyNames;
  if (!keys || keys.length === 0) return row("Info", "No data");

  let html = '<table class="pop-table"><tbody>';
  keys.forEach(key => {
    // Skip internal Cesium props
    if (key.startsWith('_')) return;
    
    let val = safeGet(properties[key], time);
    if (val !== undefined && val !== null && val !== "") {
      // Basic formatting
      if (typeof val === 'number') val = Math.round(val * 100) / 100;
      html += `<tr><td class="k">${key}</td><td class="v">${val}</td></tr>`;
    }
  });
  html += '</tbody></table>';
  return html;
}

/* robust tileset surface pick */
async function pickTilesetSurfacePosition(windowPosition){
  if(viewer.scene.pickPositionSupported){
    const c = viewer.scene.pickPosition(windowPosition);
    if(c) return c;
  }

  const ray = viewer.camera.getPickRay(windowPosition);

  if(typeof viewer.scene.pickFromRayMostDetailed === "function"){
    try{
      const hit = await viewer.scene.pickFromRayMostDetailed(ray, [viewer.scene.globe]);
      if(hit && hit.position) return hit.position;
    }catch(_){}
  }

  if(typeof viewer.scene.pickFromRay === "function"){
    try{
      const hit2 = viewer.scene.pickFromRay(ray, [viewer.scene.globe]);
      if(hit2 && hit2.position) return hit2.position;
    }catch(_){}
  }

  return viewer.scene.globe.pick(ray, viewer.scene);
}

function pickGroundPosition(windowPosition){
  const ray = viewer.camera.getPickRay(windowPosition);
  const c = viewer.scene.globe.pick(ray, viewer.scene);
  if(c) return c;
  if(viewer.scene.pickPositionSupported) return viewer.scene.pickPosition(windowPosition);
  return null;
}

/* Patch: more reliable LOD2.2 pick detection */
function isTileFeature(p){
  if(!p) return false;

  if(typeof p.getProperty === "function" || typeof p.getPropertyIds === "function") return true;

  if(p.primitive && lod22Tileset && p.primitive === lod22Tileset) return true;

  if(p.primitive && lod22Tileset && p.primitive instanceof Cesium.Cesium3DTileset && p.primitive === lod22Tileset) return true;

  return false;
}

/* ==============================
   LOD2.2 -> HIDDEN LOD1 INFO (BAG + year + area ONLY)
================================ */
let _lod22ClickSeq = 0;

// Attempt to extract a plausible construction year from a BAG identifier.
// Some BAG identifiers may encode the year of construction as a 4â€‘digit
// sequence (e.g. 1974 or 2008).  This helper searches for the first
// fourâ€‘digit sequence beginning with 18, 19 or 20 and returns it if
// it falls within a reasonable range (1800â€“2050).  Otherwise it returns
// an empty string.
function guessYearFromBagId(bag){
  if(!bag) return "";
  const str = String(bag);
  const match = str.match(/(18|19|20)\d{2}/);
  if(match){
    const year = parseInt(match[0], 10);
    if(year >= 1800 && year <= 2050) return year.toString();
  }
  return "";
}

function buildHouseInfoFromBackend(lod1){
  const bag = lod1 ? (lod1._bag || "â€”") : "â€”";
  let by  = lod1 ? (lod1._bouwjaar || "") : "";
  // If the construction year is missing or empty, attempt to derive it from the BAG id.
  if(!by || by === "â€”"){
    const guess = guessYearFromBagId(bag);
    by = guess ? guess : "â€”";
  }
  const ar  = lod1 && Number.isFinite(Number(lod1._areaM2)) ? formatArea(Number(lod1._areaM2)) : "â€”";
  return row("BAG ID", bag) + row("Construction year", by) + row("Area", ar);
}

function showBuildingPopup(screenPos, lod1EntityOrNull){
  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;

  // Hide growth panel when clicking nonâ€‘tree objects
  updateGrowthInfo(null);

  document.getElementById("popType").innerText = "Building";
  document.getElementById("popContent").innerHTML = buildHouseInfoFromBackend(lod1EntityOrNull);
}

function showLod22Popup(screenPos, lon, lat){
  const mySeq = ++_lod22ClickSeq;

  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;

  // Hide growth panel when clicking nonâ€‘tree objects
  updateGrowthInfo(null);

  document.getElementById("popType").innerText = "Building";
  document.getElementById("popContent").innerHTML =
    row("BAG ID", "Loadingâ€¦") + row("Construction year", "Loadingâ€¦") + row("Area", "Loadingâ€¦");

  lod1Ready.then(() => {
    if(mySeq !== _lod22ClickSeq) return;
    const lod1 = findLod1BuildingByLonLat(lon, lat);
    document.getElementById("popContent").innerHTML = buildHouseInfoFromBackend(lod1);
  });
}

/* ==============================
   TREE POPUP (HANDLES OPEN vs MUNI)
================================ */
function showTreePopup(screenPos, treeEntity){
  // Update assistant suggestions when a tree entity is selected
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('tree');
  }catch(e){}
  // Update assistant suggestions when a building is selected
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('building');
  }catch(e){}
  // Update assistant suggestions when selecting a building via LOD2.2
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('building');
  }catch(e){}
  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;
  const t = viewer.clock.currentTime || Cesium.JulianDate.now();

  // Handle Open or Municipal tree: display limited fields and update growth panel
  if(treeEntity._type === "tree_open" || treeEntity._type === "tree_muni"){
    // Extract species, height, crown, AGB, size class and COâ‚‚
    const sp    = safePropString(treeEntity, TREE_KEYS.species, t) || "Tree";
    const hVal  = safePropNumber(treeEntity, TREE_KEYS.height, t);
    const crVal = safePropNumber(treeEntity, TREE_EXTRA_KEYS.crown, t);
    const agbVal= safePropNumber(treeEntity, TREE_EXTRA_KEYS.agb, t);
    const szVal = safePropString(treeEntity, TREE_EXTRA_KEYS.sizeClass, t);
    const co2Val= safePropNumber(treeEntity, TREE_KEYS.co2, t);

    const heightText = (hVal !== null && hVal !== undefined) ? (Number(hVal).toFixed(1) + " m") : "â€”";
    const crownText  = (crVal !== null && crVal !== undefined) ? (Number(crVal).toFixed(1) + " mÂ²") : "â€”";
    const agbText    = (agbVal !== null && agbVal !== undefined) ? (Math.round(agbVal).toLocaleString() + " kg") : "â€”";
    const sizeText   = (szVal && String(szVal).trim() !== "") ? szVal : "â€”";
    const co2Text    = (co2Val !== null && co2Val !== undefined) ? (Math.round(co2Val).toLocaleString() + " kg") : "â€”";

    document.getElementById("popType").innerText =
      (treeEntity._type === "tree_muni") ? "Tree (Municipality)" : "Tree (Open Data)";
    document.getElementById("popContent").innerHTML =
      row("Species", sp) +
      row("Height", heightText) +
      row("Crown", crownText) +
      row("AGB", agbText) +
      row("Size class", sizeText) +
      row("COâ‚‚ stored", co2Text);
    // Show growth projection only for municipal trees
    updateGrowthInfo(treeEntity._type === "tree_muni" ? treeEntity : null);
    return;
  }

  // Hide growth panel for other entity types
  updateGrowthInfo(null);

  // 3. NEWLY PLANTED TREE
  if(treeEntity._type === "tree_new"){
    const d = treeEntity._data || {};
    const spec = speciesData[d.specKey] || speciesData.oak;
    const age = Math.max(1, currentYear - (d.plantedYear || 1) + 1);
    const annual = treeAnnualCO2(spec, age);

    document.getElementById("popType").innerText = "New Tree";
    document.getElementById("popContent").innerHTML =
      row("Species", spec.name) +
      row("Planted (scenario year)", String(d.plantedYear || currentYear)) +
      row("Estimated annual COâ‚‚", Math.round(annual).toLocaleString() + " kg/yr");
    return;
  }
}

/* Added: scenario polygon popup on click */
function showScenarioPopup(screenPos, polyEntity){
  // Update assistant suggestions when a scenario polygon is selected
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('scenario');
  }catch(e){}
  popup.style.left = (screenPos.x + 15) + "px";
  popup.style.top  = (screenPos.y + 15) + "px";
  popup.style.display = "block";
  isPinned = true;

  // Hide growth panel when clicking scenarios
  updateGrowthInfo(null);

  const d = polyEntity? (polyEntity._data || null) : null;
  if(!d){
    document.getElementById("popType").innerText = "Scenario";
    document.getElementById("popContent").innerHTML = row("Info","â€”");
    return;
  }

  const label = SCENARIO_PARAMS[d.type]?.label || d.type || "Scenario";
  const corridorTxt = d.corridorBonus ? "near corridor" : "not near corridor";

  document.getElementById("popType").innerText = "Scenario Polygon";
  document.getElementById("popContent").innerHTML =
    row("Type", label) +
    row("Area", formatArea(d.areaM2)) +
    row("NDVI", `${d.ndviBefore.toFixed(2)} â†’ ${d.ndviAfter.toFixed(2)}`) +
    row("Cooling", `-${d.cooling.toFixed(3)}Â°C`) +
    row("Stormwater", `-${Math.round(d.waterDelta).toLocaleString()} L/yr`) +
    row("Cost", `â‚¬${Math.round(d.cost).toLocaleString()}`) +
    row("Connectivity", corridorTxt);
}

// Display a popup for a corridor entity showing its length and wellâ€‘being score
function showCorridorPopup(screenPos, corridorEntity){
  // Update assistant suggestions when selecting a corridor
  try{
    if(window.assistantUpdateChips) window.assistantUpdateChips('corridor');
  }catch(e){}
    // Position and show the popup
    popup.style.left = (screenPos.x + 15) + "px";
    popup.style.top  = (screenPos.y + 15) + "px";
    popup.style.display = "block";
    isPinned = true;
    // Hide growth panel when clicking corridors
    updateGrowthInfo(null);
    // Read stored properties for the popup.  We include average NDVI and UHI values if they exist.
    const length = corridorEntity && corridorEntity._lengthMeters ? corridorEntity._lengthMeters : 0;
    const score  = corridorEntity && corridorEntity._wellBeingScore ? corridorEntity._wellBeingScore : 0;
    const ndviAvg = corridorEntity && corridorEntity._ndviAvg !== undefined ? corridorEntity._ndviAvg : null;
    const uhiAvg  = corridorEntity && corridorEntity._uhiAvg !== undefined ? corridorEntity._uhiAvg : null;
    document.getElementById("popType").innerText = "Wellâ€‘being Corridor";
    // Craft an explanatory sentence based on the multiâ€‘criteria score.  High scores come from green (high NDVI), cool (low UHI) and short corridors.
    let expl;
    if(score >= 70){
      expl = "High score: this corridor is short, green and cool, supporting wildlife movement and comfortable walking conditions.";
    } else if(score >= 40){
      expl = "Moderate score: improve greenery or add shade to reduce temperature, or create additional connections to shorten the route.";
    } else {
      expl = "Low score: this corridor is long, lacks vegetation or is heatâ€‘stressed. Planting trees and reducing surface temperatures can improve wellâ€‘being.";
    }
    // Build the popup content: show segment length and average NDVI/UHI where available
    let html = "";
    html += row("Segment length", Math.round(length).toLocaleString() + " m");
    if(ndviAvg !== null){ html += row("NDVI (avg)", ndviAvg.toFixed(2)); }
    if(uhiAvg !== null){ html += row("UHI (avg)", uhiAvg.toFixed(1) + "Â°C"); }
    html += row("Wellâ€‘being score", Math.round(score).toLocaleString() + " / 100");
    html += `<div style="font-size:10px; margin-top:6px; color:rgba(226,232,240,0.80);">${expl}<br/>Score formula: 40% NDVI + 40% cooling (UHI) + 20% connectivity.</div>`;
    document.getElementById("popContent").innerHTML = html;
}

/* ==============================
   INPUT HANDLERS
================================ */
const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

handler.setInputAction(m => {
  if(popup.style.display === "block" && !isPinned){
    popup.style.left = (m.endPosition.x + 15) + "px";
    popup.style.top  = (m.endPosition.y + 15) + "px";
  }

  if(drawState.active && interactionMode === "draw"){
    const cartesian = pickGroundPosition(m.endPosition);
    if(cartesian){
      drawState.tempPos = cartesian;

      if(drawState.pencil.active){
        const now = performance.now();
        const last = drawState.pencil.lastPos || drawState.positions[drawState.positions.length-1] || null;
        const dist = last ? Cesium.Cartesian3.distance(cartesian, last) : 999;

        if(dist > 1.8 && (now - drawState.pencil.lastAdd > 28)){
          drawState.positions.push(cartesian);
          drawState.pencil.lastAdd = now;
          drawState.pencil.lastPos = cartesian;
          drawState.usedFreehand = true;
        }
      }
    }
  }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

handler.setInputAction(() => {
  if(interactionMode === 'draw' && drawState.active && window.__shiftDown){
    drawState.pencil.active = true;
    drawState.pencil.lastAdd = 0;
    drawState.pencil.lastPos = drawState.positions[drawState.positions.length-1] || null;
    drawState.usedFreehand = true;
  }
}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

handler.setInputAction(() => {
  if(interactionMode === 'draw' && drawState.active){
    drawState.pencil.active = false;
    drawState.pencil.lastPos = null;
  }
}, Cesium.ScreenSpaceEventType.LEFT_UP);

/* LEFT CLICK */
handler.setInputAction(async (click) => {
  const pos2D = click.position;

  // DRAW mode: add points
  if(interactionMode === "draw" && drawState.active && !drawState.pencil.active){
    const cart = pickGroundPosition(pos2D);
    if(cart){
      drawState.positions.push(cart);
      showToast(`Point ${drawState.positions.length} added`);
    }
    return;
  }

  // PLANT mode
  if(interactionMode === "plant"){
    const cart = pickGroundPosition(pos2D);
    if(cart){
      const spec = speciesData[selectedSpecies];

      const tree = viewer.entities.add({
        position: new Cesium.ConstantPositionProperty(cart),
        point: {
          pixelSize: 5,
          color: Cesium.Color.fromCssColorString(spec.color),
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 2,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        },
        label: {
          text: "New " + spec.name,
          font: "10px Inter",
          pixelOffset: new Cesium.Cartesian2(0, -12),
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 500),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
      });
      tree._type = "tree_new";
      tree._data = {
        specKey: selectedSpecies,
        name: spec.name,
        cost: spec.cost,
        uhi: spec.uhi,
        bio: spec.bio,
        water: spec.water,
        plantedYear: currentYear
      };

      undoStack.push({ kind: "plant", entity: tree });

      const annual = treeAnnualCO2(spec, 1);
      updateSim();
      showToast(`${spec.name} planted (Year1 â‰ˆ ${Math.round(annual)} kg COâ‚‚/yr)`);
    }
    return;
  }

  const picks = viewer.scene.drillPick(pos2D, 16) || [];

  // click trees (Both Open and Muni are handled here)
  const entPick = picks.find(p => p && p.id && (
    p.id._type === "tree_open" || 
    p.id._type === "tree_muni" || 
    p.id._type === "tree_new"
  ));
  if(entPick && entPick.id){
    showTreePopup(pos2D, entPick.id);
    return;
  }

  // click scenario polygon
  const scPick = picks.find(p => p && p.id && p.id._type === "scenario_poly");
  if(scPick && scPick.id){
    showScenarioPopup(pos2D, scPick.id);
    return;
  }

  // click MCDA marker -> show BAG + year + area
  const mcdaPick = picks.find(p => p && p.id && p.id._type === 'mcda_marker');
  if(mcdaPick && mcdaPick.id && mcdaPick.id._lod1){
    showBuildingPopup(pos2D, mcdaPick.id._lod1);
    return;
  }

  // click corridor -> show wellâ€‘being corridor popup
  const corPick = picks.find(p => p && p.id && p.id._type === 'corridor');
  if(corPick && corPick.id){
    showCorridorPopup(pos2D, corPick.id);
    return;
  }

  // FACADE mode: click on LOD 2.2 building (robust + BAG dedupe)
  if(interactionMode === "facade"){
    const tileFeature = lod22Tileset ? picks.find(p => isTileFeature(p)) : null;
    if(!tileFeature){
      showToast("Click a building (LOD 2.2)");
      return;
    }

    const cart = await pickTilesetSurfacePosition(pos2D);
    if(!cart){
      showToast("Could not place facade here");
      return;
    }

    const c = Cesium.Cartographic.fromCartesian(cart);
    const lon = Cesium.Math.toDegrees(c.longitude);
    const lat = Cesium.Math.toDegrees(c.latitude);

    showLod22Popup(pos2D, lon, lat);

    const facadeEnt = addFacadeSquareAt(cart, { bag: "", bouwjaar: "", areaM2: null });

    lod1Ready.then(() => {
      const lod1 = findLod1BuildingByLonLat(lon, lat);

      const bag = lod1 ? (lod1._bag || "") : "";
      const bouwjaar = lod1 ? (lod1._bouwjaar || "") : "";
      const areaM2 = lod1 ? (lod1._areaM2 || null) : null;

      if(facadeEnt && facadeEnt._type === "facade_square"){
        facadeEnt._meta = { bag, bouwjaar, areaM2 };

        if(bag) registerFacadeForBag(bag, facadeEnt);
      }
    });

    return;
  }

  // normal click: LOD2.2 -> show BAG + year + area
  const tileFeature = lod22Tileset ? picks.find(p => isTileFeature(p)) : null;
  if(tileFeature){
    const cart = await pickTilesetSurfacePosition(pos2D);
    if(cart){
      const c = Cesium.Cartographic.fromCartesian(cart);
      const lon = Cesium.Math.toDegrees(c.longitude);
      const lat = Cesium.Math.toDegrees(c.latitude);
      showLod22Popup(pos2D, lon, lat);
      return;
    }
  }

  // fallback surface scan
  const cart = pickGroundPosition(pos2D);
  if(cart){
    popup.style.left = (pos2D.x + 15) + "px";
    popup.style.top  = (pos2D.y + 15) + "px";
    popup.style.display = "block";
    isPinned = false;

    const cc = Cesium.Cartographic.fromCartesian(cart);
    const env = getPixelData(Cesium.Math.toDegrees(cc.latitude), Cesium.Math.toDegrees(cc.longitude));

    document.getElementById("popType").innerText = "Surface Scan";
    document.getElementById("popContent").innerHTML =
      row("Surface Temp (UHI)", env.uhi) +
      row("NDVI", env.ndvi);
  }else{
    closePopup();
  }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);

/* RIGHT CLICK: finish polygon in draw mode */
handler.setInputAction(() => {
  if(interactionMode === "draw" && drawState.active){
    finalizeScenarioPolygon();
    return;
  }
}, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

viewer.camera.moveStart.addEventListener(() => closePopup());

window.__shiftDown = false;
window.addEventListener("keydown", (e) => {
  if(e.key === 'Shift') window.__shiftDown = true;
  if(e.key === "Escape"){
    cancelPolygonDraw(true);
    if(interactionMode === "plant") togglePlanting();
    if(interactionMode === "facade") toggleFacading(true);
    showToast("Interaction cancelled");
  }
});
window.addEventListener("keyup", (e) => {
  if(e.key === 'Shift') window.__shiftDown = false;
});

/* ==============================
   UTILITIES
================================ */
function showToast(msg){
  const t = document.getElementById("toast");
  t.innerText = msg;
  t.style.opacity = 1;
  t.style.top = "100px";
  setTimeout(() => {
    t.style.opacity = 0;
    t.style.top = "90px";
  }, 1800);
}

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function polygonCentroidCartographic(positions){
  try{
    if(!positions || positions.length < 3) return null;
    let lon = 0, lat = 0;
    positions.forEach(p => {
      const c = Cesium.Cartographic.fromCartesian(p);
      lon += c.longitude;
      lat += c.latitude;
    });
    lon /= positions.length;
    lat /= positions.length;
    return new Cesium.Cartographic(lon, lat);
  }catch(_){ return null; }
}

function polygonCentroidCartesian(positions){
  const c = polygonCentroidCartographic(positions);
  if(!c) return null;
  return Cesium.Cartesian3.fromRadians(c.longitude, c.latitude, 0);
}

function polygonAreaM2(positions){
  try{
    if(!positions || positions.length < 3) return 0;
    const proj = new Cesium.WebMercatorProjection(Cesium.Ellipsoid.WGS84);
    const pts = positions.map(p => proj.project(Cesium.Cartographic.fromCartesian(p)));

    let area = 0;
    for(let i=0; i<pts.length; i++){
      const j = (i+1) % pts.length;
      area += (pts[i].x * pts[j].y) - (pts[j].x * pts[i].y);
    }
    return Math.abs(area) / 2.0;
  }catch(_){ return 0; }
}

function formatArea(m2){
  if(!Number.isFinite(Number(m2))) return "â€”";
  m2 = Number(m2);
  if(m2 >= 10000) return (m2/10000).toFixed(2) + " ha";
  return Math.round(m2).toLocaleString() + " mÂ²";
}

/* ==============================
   INIT
================================ */
function initDefaults(){
  document.getElementById("sw-trees_open").classList.add("active");
  document.getElementById("sw-trees_muni").classList.add("active");
  document.getElementById("sw-greenery").classList.add("active");
  document.getElementById("sw-buildings3d").classList.add("active");

  document.getElementById("sw-corridors").classList.remove("active");
  document.getElementById("sw-heatmap").classList.remove("active");

  updateLegend();
  updateScenarioList();
  updateSim();
  updateSun(document.getElementById("sliderTime").value);
  toggleShadowsFromSlider(document.getElementById("shadowToggle").value);

  const spec = speciesData[selectedSpecies];
  document.getElementById("btnPlant").innerHTML = `<i class="fas fa-plus-circle"></i> Plant ${spec.name} (â‚¬${spec.cost})`;

  const f = facadeTypes[selectedFacadeType];
  document.getElementById("btnFacade").innerHTML = `<i class="fa-solid fa-square-plus"></i> Apply ${f.name} Facade (click a building)`;

  // Initialise impact overview gauges once DOM elements are ready
  gaugeCo2 = createGauge('gaugeCo2', getComputedStyle(document.documentElement).getPropertyValue('--blue') || '#60a5fa', 'COâ‚‚');
  gaugeWater = createGauge('gaugeWater', getComputedStyle(document.documentElement).getPropertyValue('--gold') || '#fbbf24', 'Water');
  gaugeUhi = createGauge('gaugeUhi', getComputedStyle(document.documentElement).getPropertyValue('--danger') || '#fb7185', 'Cooling');
  gaugeCost = createGauge('gaugeCost', getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#2dd4bf', 'Investment');

  // Initialise biodiversity gauge using the purple accent colour.  This gauge
  // reflects the net change in the habitat suitability proxy (biodiversity).
  gaugeBio = createGauge('gaugeBio', getComputedStyle(document.documentElement).getPropertyValue('--purple') || '#c084fc', 'Biodiversity');

  // Kick off with initial zero values on the gauges
  updateAllGauges(0, 0, 0, 0);
}
initDefaults();

/* ==============================
   Wikipedia + Budget Planner helpers
   - Wikipedia summaries are fetched clientâ€‘side (CORS supported).
   - Budget planner proposes portfolios based on tradeâ€‘offs.
================================ */

const __wikiCache = new Map();
async function fetchWikiSummary(title){
  const key = String(title || "").trim();
  if(!key) return null;
  if(__wikiCache.has(key)) return __wikiCache.get(key);
  const url = "https://en.wikipedia.org/api/rest_v1/page/summary/" + encodeURIComponent(key);
  try{
    const resp = await fetch(url, { mode: "cors" });
    if(!resp.ok) throw new Error("wiki summary failed");
    const data = await resp.json();
    const out = {
      title: data.title || key,
      extract: data.extract || "",
      page: (data.content_urls && data.content_urls.desktop && data.content_urls.desktop.page) ? data.content_urls.desktop.page : ""
    };
    __wikiCache.set(key, out);
    return out;
  }catch(e){
    __wikiCache.set(key, null);
    return null;
  }
}

async function wikiOpenSearch(query){
  const q = String(query || "").trim();
  if(!q) return null;
  // Try multiple languages (Dutch, German, English) to broaden lookup for unknown terms
  const langs = ['nl','de','en'];
  for(const lang of langs){
    const url = `https://${lang}.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(q)}&limit=1&namespace=0&format=json&origin=*`;
    try{
      const resp = await fetch(url);
      const data = await resp.json();
      const title = (data && data[1] && data[1][0]) ? data[1][0] : null;
      if(title) return title;
    }catch(e){
      // ignore and try next language
    }
  }
  return null;
}

// Attach wiki snippets to Layer Info modal
async function appendWikiToLayerInfo(layerKey, bodyEl){
  if(!bodyEl) return;

  const map = {
    trees_open: ["Urban forestry", "Tree inventory"],
    trees_muni: ["Urban forestry"],
    greenery: ["Urban green space"],
    corridors: ["Wildlife corridor", "Ecological connectivity"],
    heatmap: ["Urban heat island"],
    buildings3d: ["3D city model"]
  };
  const titles = map[layerKey] || [];
  if(!titles.length) return;

  const s = await fetchWikiSummary(titles[0]);
  if(!s || !s.extract) return;

  const excerpt = s.extract.length > 520 ? (s.extract.slice(0, 520) + "â€¦") : s.extract;

  bodyEl.insertAdjacentHTML("beforeend", `
    <div style="margin-top:14px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.08);">
      <div style="font-weight:900;color:rgba(45,212,191,0.95);text-transform:uppercase;letter-spacing:1px;font-size:10px;margin-bottom:6px;">
        Wikipedia context
      </div>
      <div style="color:rgba(226,232,240,0.84);font-size:12px;line-height:1.6;">
        ${excerpt}
      </div>
      ${s.page ? `<div style="margin-top:8px;"><a href="${s.page}" target="_blank" rel="noopener">Open Wikipedia: ${s.title}</a></div>` : ``}
    </div>
  `);
}

// ------- Budget planner -------

function __objectiveWeights(key){
  const k = String(key || "balanced").toLowerCase();
  if(k === "cooling")      return { co2:0.15, cool:0.45, bio:0.20, water:0.20 };
  if(k === "carbon")       return { co2:0.55, cool:0.20, bio:0.10, water:0.15 };
  if(k === "biodiversity") return { co2:0.10, cool:0.20, bio:0.55, water:0.15 };
  if(k === "stormwater")   return { co2:0.10, cool:0.20, bio:0.20, water:0.50 };
  return { co2:0.25, cool:0.25, bio:0.25, water:0.25 }; // balanced
}

function __normalize(v, max){ return max <= 0 ? 0 : clamp(v / max, 0, 1); }

function __makeInterventionCatalog(){
  const ageForTree = Math.max(5, Math.min(12, currentYear || 5));
  const items = [];

  // Trees (repeatable)
  for(const [k, spec] of Object.entries(speciesData || {})){
    const co2 = treeAnnualCO2(spec, ageForTree);
    items.push({
      id: "tree:" + k,
      label: `${spec.name} tree`,
      cost: spec.cost,
      co2, cool: spec.uhi || 0, bio: spec.bio || 0, water: spec.water || 0,
      notes: "Longâ€‘term benefits; needs planting space"
    });
  }

  // Facades (repeatable but usually 0..few)
  for(const [k, f] of Object.entries(facadeTypes || {})){
    items.push({
      id: "facade:" + k,
      label: `${f.name} facade`,
      cost: f.cost,
      co2: f.co2 || 0, cool: f.uhi || 0, bio: f.bio || 0, water: f.water || 0,
      notes: "Strong cooling/biodiversity on walls; higher upfront cost"
    });
  }

  // Scenario polygons (10 mÂ² blocks; repeatable)
  const blockM2 = 10;
  for(const [k, p] of Object.entries(SCENARIO_PARAMS || {})){
    items.push({
      id: "poly:" + k,
      label: `${p.label} planting (â‰ˆ${blockM2} mÂ²)`,
      cost: blockM2 * (p.costPerM2 || 0),
      co2: 0,
      cool: (p.coolPerHa || 0) / 10000 * blockM2,
      bio: (p.bioPerHa || 0) / 10000 * blockM2,
      water: (p.waterPerHa || 0) / 10000 * blockM2,
      notes: "Needs available space; good for stormwater + habitat"
    });
  }

  return items.filter(x => Number.isFinite(x.cost) && x.cost > 0);
}

function planForBudget(budgetEur, objectiveKey){
  const budget = Math.max(0, Number(budgetEur) || 0);
  const W = __objectiveWeights(objectiveKey);
  const items = __makeInterventionCatalog();

  // Maxima for normalisation (rough, from item catalog)
  const maxCo2 = Math.max(...items.map(i => i.co2 || 0), 1);
  const maxCool = Math.max(...items.map(i => i.cool || 0), 1e-6);
  const maxBio = Math.max(...items.map(i => i.bio || 0), 1e-6);
  const maxWater = Math.max(...items.map(i => i.water || 0), 1);

  function scoreItem(i){
    const s =
      W.co2   * __normalize(i.co2 || 0, maxCo2) +
      W.cool  * __normalize(i.cool || 0, maxCool) +
      W.bio   * __normalize(i.bio || 0, maxBio) +
      W.water * __normalize(i.water || 0, maxWater);
    return s;
  }

  // Greedy by "score per euro", with a small penalty for very expensive single items
  const scored = items.map(i => {
    const s = scoreItem(i);
    const per = s / Math.max(i.cost, 1);
    const penalty = i.cost > 3000 ? 0.85 : 1.0;
    return { ...i, _score: s, _per: per * penalty };
  }).sort((a,b) => b._per - a._per);

  let remaining = budget;
  const picks = [];
  const cap = 250; // safety loop
  let steps = 0;

  while(steps++ < cap){
    const next = scored.find(i => i.cost <= remaining);
    if(!next) break;
    picks.push(next);
    remaining -= next.cost;
    if(remaining < Math.min(...scored.map(i => i.cost))) break;
  }

  const totals = picks.reduce((acc, i) => {
    acc.cost += i.cost;
    acc.co2 += i.co2 || 0;
    acc.cool += i.cool || 0;
    acc.bio += i.bio || 0;
    acc.water += i.water || 0;
    return acc;
  }, { cost:0, co2:0, cool:0, bio:0, water:0 });

  // Summarise counts
  const counts = {};
  picks.forEach(p => counts[p.id] = (counts[p.id] || 0) + 1);

  return { budget, remaining, objectiveKey, counts, totals };
}

function formatPlanText(plan){
  const lines = [];
  lines.push(`Budget: â‚¬${Math.round(plan.budget).toLocaleString()} Â· Objective: ${plan.objectiveKey}`);
  const entries = Object.entries(plan.counts);
  if(entries.length === 0){
    lines.push("No actions fit this budget (try increasing budget or choose cheaper actions).");
    return lines.join("\n");
  }

  lines.push("Suggested portfolio:");
  entries.forEach(([id, n]) => {
    if(id.startsWith("tree:")){
      const k = id.split(":")[1];
      const s = speciesData[k];
      lines.push(`- ${n}Ã— ${s.name} tree (â‚¬${s.cost} each)`);
    }else if(id.startsWith("facade:")){
      const k = id.split(":")[1];
      const f = facadeTypes[k];
      lines.push(`- ${n}Ã— ${f.name} facade (â‚¬${Math.round(f.cost).toLocaleString()} each)`);
    }else if(id.startsWith("poly:")){
      const k = id.split(":")[1];
      const p = SCENARIO_PARAMS[k];
      lines.push(`- ${n}Ã— ${p.label} polygon blocks (â‰ˆ10 mÂ² each, â‚¬${p.costPerM2}/mÂ²)`);
    }
  });

  lines.push("");
  lines.push("Tradeâ€‘offs (modelâ€‘based):");
  lines.push(`â€¢ COâ‚‚: +${Math.round(plan.totals.co2).toLocaleString()} kg/yr`);
  lines.push(`â€¢ Cooling: -${Math.abs(plan.totals.cool).toFixed(3)} Â°C`);
  lines.push(`â€¢ Biodiversity proxy: +${plan.totals.bio.toFixed(3)}`);
  lines.push(`â€¢ Stormwater: -${Math.round(plan.totals.water).toLocaleString()} L/yr`);
  lines.push(`Remaining (buffer): â‚¬${Math.round(plan.remaining).toLocaleString()}`);

  lines.push("");
  lines.push("How to apply in the twin:");
  lines.push("1) Use 'Plant Selected Tree' to place the trees.");
  lines.push("2) If facades are included: turn on facade mode and click buildings.");
  lines.push("3) For polygons: use 'Start Draw' and draw the suggested vegetation type.");

  return lines.join("\n");
}

function runBudgetPlanner(){
  const b = document.getElementById("budgetInput");
  const o = document.getElementById("budgetObjective");
  const out = document.getElementById("budgetResults");
  const budget = b ? Number(b.value || 0) : 0;
  const obj = o ? o.value : "balanced";
  const plan = planForBudget(budget, obj);

  if(out){
    out.textContent = formatPlanText(plan);
    out.style.whiteSpace = "pre-line";
  }
  showToast("Budget plan ready");
}
function clearBudgetPlanner(){
  const out = document.getElementById("budgetResults");
  if(out) out.textContent = "";
}


/* ==============================
   ECOLOGY ASSISTANT
  ============================== */
(function(){
  const defaultChips = [
    { label: 'Explain NDVI', command: 'explain ndvi' },
    { label: 'Explain UHI', command: 'explain uhi' },
    { label: 'Run MCDA', command: 'run mcda' },
    { label: 'Start Draw', command: 'start drawing trees' },
    { label: 'Toggle Heatmap', command: 'turn on heatmap' },
    { label: 'Download Report', command: 'download report' },
    // custom chips for tree statistics and predictions
    { label: 'Tree Summary', command: 'tree summary' },
    { label: 'Future Prediction', command: 'future prediction' }
  ];

  /* --------------------------------------------------------------------
     Ecological dictionary and predictive suggestion data
     Provides definitions, related concepts and suggestion prompts for
     key ecological terms used in the digital twin.  These entries
     enable instant definitions and contextual assistance when users
     type or ask about ecology keywords.
  -------------------------------------------------------------------- */
  const ecoDictionary = {
    'ndvi': {
      definition: 'NDVI (Normalised Difference Vegetation Index) compares nearâ€‘infrared and red reflectance to assess vegetation health. Values range from -1 to +1, with higher values indicating healthier or denser vegetation.',
      related: ['vegetation health','remote sensing','photosynthesis'],
      suggestions: ['How does NDVI relate to cooling impact?','Explain UHI','How does NDVI relate to green corridors?','NDVI vs LAI']
    },
    'uhi': {
      definition: 'Urban Heat Island (UHI) refers to pockets of higher temperature within cities caused by heatâ€‘absorbing materials, reduced vegetation and anthropogenic heat. UHI maps visualise relative surface temperatures.',
      related: ['heat stress','temperature','cooling strategies'],
      suggestions: ['How to reduce UHI?','Impact of green roofs on UHI','Why is this area hot?','How does UHI affect human comfort?']
    },
    'biodiversity': {
      definition: 'Biodiversity describes the variety of life in an ecosystem, encompassing species richness, genetic diversity and ecosystem variety. High biodiversity contributes to ecological resilience and health.',
      related: ['ecosystem services','species richness','habitats'],
      suggestions: ['How to improve biodiversity?','Effect of wellâ€‘being corridors on biodiversity','Biodiversity in urban environments','What are biodiversity benefits?']
    },
      'green corridor': {
        definition: 'Wellâ€‘being corridors (sometimes called green corridors) are continuous strips of natural vegetation connecting isolated green spaces. They enable wildlife movement, ecological connectivity and provide walkable routes for people. In this digital twin, each corridor receives a wellâ€‘being score that combines vegetation health (NDVI), cooling intensity (UHI) and connectivity; greener, cooler and shorter corridors score higher.',
        related: ['ecological connectivity','wildlife movement','habitat fragmentation','well-being'],
        suggestions: ['Benefits of wellâ€‘being corridors?','How to design corridors','Impact of corridors on species and people','How do corridors enhance biodiversity benefit?']
      },
    'scenario polygon': {
      definition: 'A scenario polygon is a userâ€‘drawn shape representing planned vegetation interventions such as grass, shrubs, trees or mixed planting. Each type affects NDVI, cooling, stormwater infiltration and biodiversity.',
      related: ['urban planning','vegetation types','ecology scenarios'],
      suggestions: ['How to draw scenario polygons?','Impact of shrubs vs trees','Draw mixed vegetation area']
    },
    'mcda': {
      definition: 'Multiâ€‘Criteria Decision Analysis (MCDA) is a decisionâ€‘support technique that ranks options based on multiple weighted criteria. Here it prioritises buildings using UHI, NDVI, corridor proximity, age and footprint.',
      related: ['decision support','ranking','priority'],
      suggestions: ['Run MCDA','Explain MCDA parameters','How to adjust MCDA weights?']
    },
    'ecosystem services': {
      definition: 'Ecosystem services are the benefits that natural ecosystems provide, including provisioning (food, water), regulating (climate regulation, flood control), supporting (nutrient cycling, soil formation) and cultural (recreation).',
      related: ['natural capital','ecosystem benefits','ecosystem value'],
      suggestions: ['List ecosystem services provided by urban trees','How do green roofs contribute to ecosystem services?','What are regulating services?','How do ecosystem services relate to human comfort?']
    },
    'stormwater': {
      definition: 'Stormwater refers to runoff generated from precipitation events. In urban areas, impervious surfaces create excessive runoff leading to flooding and pollution. Vegetation and green infrastructure mitigate stormwater.',
      related: ['runoff','infiltration','flooding'],
      suggestions: ['How do trees reduce stormwater?','Stormwater management strategies','What is infiltration rate?','What is water management?']
    },
    'heat island': {
      definition: 'Heat islands are urban areas that experience higher temperatures than surrounding rural areas due to human activities, reduced vegetation and heatâ€‘absorbing surfaces. They are addressed through cooling strategies and increased greenery.',
      related: ['UHI','temperature','cooling strategies'],
      suggestions: ['Effects of heat islands?','How to mitigate heat islands?','Difference between UHI and heat island?']
    },
    'growth projection': {
      definition: 'Growth projection in ecology estimates future changes in plant attributes such as trunk diameter, aboveâ€‘ground biomass and annual COâ‚‚ uptake based on models and past measurements.',
      related: ['tree growth','biomass','carbon sequestration'],
      suggestions: ['How to interpret growth projections?','Tree DBH increment estimations','Impact of growth on COâ‚‚ sequestration']
    },
    'sequestration': {
      definition: 'Sequestration is the process by which plants and soils capture and store carbon dioxide from the atmosphere. Effective sequestration reduces atmospheric COâ‚‚ and mitigates climate change.',
      related: ['carbon cycle','photosynthesis','climate change'],
      suggestions: ['How much COâ‚‚ do trees sequester?','Difference between shortâ€‘term and longâ€‘term sequestration?','Methods to increase sequestration?']
    },
    // Newly added ecological terms supporting expanded ecology knowledge.
    'green roof': {
      definition: 'A green roof is a vegetative layer grown on a rooftop. According to the US Environmental Protection Agency, green roofs provide shade, remove heat from the air, and reduce temperatures of the roof surface and surrounding air.',
      related: ['urban cooling','stormwater','biodiversity'],
      suggestions: ['Benefits of green roofs?','Costs of green roofs?','Green roofs vs facades']
    },
    'permeable surfaces': {
      definition: 'Permeable surfaces â€” such as pervious pavements, interlocking pavers or other porous materials â€” allow rain and snowmelt to seep into underlying soils. These surfaces help reduce runoff and filter pollutants.',
      related: ['stormwater','urban drainage','infiltration'],
      suggestions: ['How to increase permeable surfaces?','Benefits of permeable pavement','Difference between permeable and impervious surfaces']
    },
    'tree canopy': {
      definition: 'Tree canopy refers to the part of a city or landscape shaded by trees. The leaves and branches that cover the ground form the tree canopy, providing shade and habitat and influencing urban microclimates.',
      related: ['urban forestry','cooling impact','biodiversity'],
      suggestions: ['Why is tree canopy important?','How to expand tree canopy?','Tree canopy vs NDVI']
    },
    'native species': {
      definition: 'Native species are plant or animal species that occur naturally in a specified geographic area. They have historically existed there and are adapted to local soil and climate conditions.',
      related: ['invasive species','biodiversity','ecosystem health'],
      suggestions: ['Native vs invasive species','Benefits of native species','Examples of native species']
    },
    'invasive species': {
      definition: 'Invasive species are nonâ€‘native species introduced by humans that cause harm to native plants, wildlife or ecosystems. They can disrupt ecological balance and result in environmental or economic damage.',
      related: ['native species','ecosystem health','management'],
      suggestions: ['Examples of invasive species','How to control invasive species?','Impacts of invasive species']
    },
    'natureâ€‘based solutions': {
      definition: 'Natureâ€‘based solutions (NBS) are costâ€‘effective solutions inspired and supported by nature that provide environmental, social and economic benefits. They bring more diverse nature and natural processes into cities and landscapes and help build resilience.',
      related: ['urban resilience','ecosystem services','green infrastructure'],
      suggestions: ['Examples of natureâ€‘based solutions','How do NBS improve resilience?','Natureâ€‘based solutions vs grey infrastructure']
    },
    'urban resilience': {
      definition: 'Urban resilience describes the ability of an urban system and its inhabitants to absorb, adapt to and recover from climateâ€‘related shocks and stresses while safeguarding human wellâ€‘being.',
      related: ['climate adaptation','natureâ€‘based solutions','disaster risk reduction'],
      suggestions: ['How to improve urban resilience?','Examples of urban resilience strategies','Urban resilience vs climate adaptation']
    },
    'meadow': {
      definition: 'A meadow is an open habitat or field vegetated by grasses, herbs and other nonâ€‘woody plants. Meadows may include sparse trees or shrubs but remain open and provide habitat for wildlife and pollinators.',
      related: ['habitats','biodiversity','pollinators'],
      suggestions: ['Difference between meadow and lawn','Benefits of meadows','How to create a meadow']
    },
    'wetland': {
      definition: 'Wetlands are areas where water covers the soil or is present near the surface of the ground. Water saturation shapes the soil and determines the plant and animal communities present, supporting both aquatic and terrestrial species.',
      related: ['water management','biodiversity','ecosystem services'],
      suggestions: ['Importance of wetlands','Wetlands vs ponds','Wetlands conservation']
    },
    'urban forest': {
      definition: 'An urban forest encompasses all trees and shrubs within an urban area, including street trees, trees in yards and protected areas, and the associated vegetation and soils.',
      related: ['tree canopy','urban forestry','ecosystem services'],
      suggestions: ['Benefits of urban forests','How to expand urban forests?','Urban forestry practices']
    },
    'eu biodiversity strategy': {
      definition: 'The EU Biodiversity Strategy for 2030 aims to restore Europeâ€™s biodiversity by 2030 to benefit people, the climate and the economy. It sets goals for protecting and restoring ecosystems and ensuring ecosystem resilience.',
      related: ['green deal','nature restoration law','eu policy'],
      suggestions: ['What are the targets of the EU Biodiversity Strategy?','Impact on municipalities?','Relationship with the Green Deal']
    },
    'green deal': {
      definition: 'The European Green Deal is a roadmap to make the EU economy sustainable by turning climate and environmental challenges into opportunities. It aims to cut greenhouseâ€‘gas emissions by at least 50% (moving towards 55%) by 2030 and make Europe climateâ€‘neutral by 2050.',
      related: ['eu policy','climate neutrality','biodiversity strategy'],
      suggestions: ['What is the Green Deal?','How does the Green Deal affect urban planning?','Relation to the Biodiversity Strategy']
    },
    'nature restoration law': {
      definition: 'The Nature Restoration Law (Nature Restoration Regulation) sets binding targets to restore at least 20% of the EUâ€™s land and sea areas by 2030 and all ecosystems in need of restoration by 2050.',
      related: ['eu policy','biodiversity strategy','restoration'],
      suggestions: ['What does the Nature Restoration Law require?','Who is affected by the law?','Implementation timeline']
    },
    'climate adaptation plan': {
      definition: 'Climate adaptation plans â€” such as those under the EU Adaptation Strategy â€” outline measures to make adaptation smarter, faster and more systemic. They aim to reduce climate risks, secure water resources and integrate resilience and natureâ€‘based solutions.',
      related: ['urban resilience','natureâ€‘based solutions','eu policy'],
      suggestions: ['What is the EU Adaptation Strategy?','How do adaptation plans support climate resilience?','Adaptation vs mitigation']
    },
    'cooling impact': {
      definition: 'Cooling impact refers to the reduction in ambient temperature provided by vegetation, green roofs and other ecological interventions. Shading from trees and evapotranspiration help cool urban areas and reduce the Urban Heat Island effect.',
      related: ['uhi','tree canopy','green roof'],
      suggestions: ['Which interventions provide the greatest cooling?','How to measure cooling impact?','Relation between NDVI and cooling impact']
    },
    'biodiversity benefit': {
      definition: 'Biodiversity benefit denotes the improvement of species richness, habitat connectivity and ecological resilience resulting from vegetation interventions and habitat creation.',
      related: ['biodiversity','green corridor','ecosystem services'],
      suggestions: ['How to maximise biodiversity benefits?','Examples of biodiversityâ€‘friendly projects','Biodiversity vs carbon sequestration']
    },
    'water management': {
      definition: 'Water management involves strategies to control stormwater, infiltration and water quality. Permeable surfaces, wetlands and vegetation help manage water by reducing runoff and filtering pollutants.',
      related: ['stormwater','permeable surfaces','wetlands'],
      suggestions: ['Stormwater management techniques','Why is water management important?','Green vs grey infrastructure for water management']
    },
    'human comfort': {
      definition: 'Human comfort describes how ecological interventions improve human wellâ€‘being. Shade, cooling, recreational spaces and aesthetic values from green infrastructure contribute to comfort and livability.',
      related: ['urban resilience','public health','ecosystem services'],
      suggestions: ['How does greenery improve human comfort?','Why is human comfort considered in ecology planning?','Examples of natureâ€‘based solutions for human comfort']
    }
    ,
    /*
      Layerâ€‘specific definitions to answer questions about the available
      map layers.  These entries reference the information provided in
      the layer info panels so that the assistant can explain what
      each layer represents when a user asks about it.  Additional
      related concepts and suggestion prompts are provided to guide
      further exploration.
    */
    'tree inventory': {
      definition: 'The Tree Inventory layer displays publicly available street tree data. Each point represents a documented tree with attributes like species, height, crown area, aboveâ€‘ground biomass, size class and COâ‚‚ stored. Click a tree to view these details.',
      related: ['trees','species','COâ‚‚ storage','municipal trees'],
      suggestions: ['What information does the tree inventory include?','How do I view tree attributes?','Difference between Tree Inventory and Tree Points?']
    },
    'tree points': {
      definition: 'Tree Points (municipal) show the official municipal tree registry with detailed biological and growth information including species, height, crown area, diameter at breast height (DBH), size class, aboveâ€‘ground biomass, COâ‚‚ stored and growth projections such as future DBH and sequestration rates.',
      related: ['trees','municipal registry','growth projections'],
      suggestions: ['How to access growth projections?','Tree points vs tree inventory','What is DBH?']
    },
    'green spaces': {
      definition: 'Green Spaces are polygons delineating parks, lawns, sports fields and other vegetated areas. They provide habitat and recreation space and are used in corridor connectivity analysis and scenario planning.',
      related: ['greenspace','parks','habitat','corridors'],
      suggestions: ['Why are green spaces important?','How do green spaces connect corridors?','Difference between green spaces and tree points?']
    },
    'buildings': {
      definition: 'The Buildings layer displays detailed Level of DetailÂ 2.2 (LOD2.2) building models with realistic roof and wall geometry. Hidden attributes include building ID, construction year and footprint area. Selecting a building reveals these details.',
      related: ['3D models','urban context','building age'],
      suggestions: ['How to view building attributes?','Why use LOD2.2?','What does the construction year tell us?']
    },
    'wellâ€‘being corridors': {
      definition: 'Wellâ€‘being corridors are lines connecting green spaces that indicate ecological pathways and provide walkable routes for people. Dynamic arrows flow along the lines to visualise movement (e.g. wildlife or pedestrians), illustrating habitat connectivity, planning routes and supporting human wellâ€‘being.',
      related: ['corridors','ecological connectivity','movement flows','well-being'],
      suggestions: ['What is the purpose of wellâ€‘being corridors?','How to improve corridor connectivity?','Why are dynamic arrows used?','How do corridors enhance well-being?']
    },
    'heatmap': {
      definition: 'The Heatmap layer overlays a raster that visualises Urban Heat Island (UHI) intensity based on surface temperature proxies. Cooler and warmer areas are colourâ€‘coded, and combining the heatmap with NDVI highlights heatâ€‘stressed locations.',
      related: ['UHI','temperature','NDVI'],
      suggestions: ['How to interpret the heatmap?','What do the colours mean?','Why combine heatmap with NDVI?']
    }
  };

  // Generic suggestions for forwardâ€‘looking and idea prompts
  const generalSuggestions = [
    'Future plan: plant mixed vegetation for biodiversity',
    'Idea: create wellâ€‘being corridors to connect parks',
    'Future plan: install green facades on priority buildings',
    'Idea: prioritise interventions with MCDA',
    'Future plan: reduce UHI through shading and vegetation'
    ,
    // Additional general suggestions for user followâ€‘up actions
    'Show examples',
    'Apply on map',
    'See costs',
    'Explain more'
  ];

  // Alias mapping between Dutch/German terms and canonical dictionary keys.
  // This allows the assistant to recognise multilingual ecology concepts and synonyms.
  const aliasMap = {
    'vegetatieâ€‘index': 'ndvi',
    'vegetatie index': 'ndvi',
    'vegetationsindex': 'ndvi',
    'stedelijk hitteâ€‘eiland': 'uhi',
    'stedelijk hitte eiland': 'uhi',
    'wÃ¤rmeinsel': 'uhi',
    'biodiversiteit': 'biodiversity',
    'biodiversitÃ¤t': 'biodiversity',
    'groene corridor': 'wellâ€‘being corridor',
    'Ã¶kologischer korridor': 'wellâ€‘being corridor',
    'groen dak': 'green roof',
    'groene daken': 'green roof',
    'grÃ¼ndach': 'green roof',
    'grÃ¼ndÃ¤cher': 'green roof',
    'waterdoorlatend': 'permeable surfaces',
    'waterdoorlatende': 'permeable surfaces',
    'wasserdurchlÃ¤ssig': 'permeable surfaces',
    'boomkroon': 'tree canopy',
    'baumkrone': 'tree canopy',
    'inheemse soorten': 'native species',
    'heimische arten': 'native species',
    'ecosysteemdiensten': 'ecosystem services',
    'Ã¶kosystemleistungen': 'ecosystem services',
    'regenwater': 'stormwater',
    'regenwasser': 'stormwater',
    'natuurâ€‘gebaseerde oplossingen': 'natureâ€‘based solutions',
    'naturbasierte lÃ¶sungen': 'natureâ€‘based solutions',
    'stedelijke veerkracht': 'urban resilience',
    'urbane resilienz': 'urban resilience',
    'grasland': 'meadow',
    'wiese': 'meadow',
    'wetlands': 'wetland',
    'moeras': 'wetland',
    'sumpfgebiet': 'wetland',
    'stadsbos': 'urban forest',
    'stadtwald': 'urban forest',
    'biodiversiteitsstrategie': 'eu biodiversity strategy',
    'biodiversitÃ¤tsstrategie': 'eu biodiversity strategy',
    'groene deal': 'green deal',
    'grÃ¼ner deal': 'green deal',
    'herstelwet': 'nature restoration law',
    'renaturierungsgesetz': 'nature restoration law',
    'adaptatieplan': 'climate adaptation plan',
    'anpassungsplan': 'climate adaptation plan',
    'koelingsimpact': 'cooling impact',
    'kÃ¼hlwirkung': 'cooling impact',
    'biodiversiteitsvoordeel': 'biodiversity benefit',
    'biodiversitÃ¤tsvorteil': 'biodiversity benefit',
    'waterbeheer': 'water management',
    'wassermanagement': 'water management',
    'menselijk comfort': 'human comfort',
    'menschlicher komfort': 'human comfort'
    ,
    // Additional aliases for layerâ€‘related queries
    'boom inventaris': 'tree inventory',
    'boom inventarisatie': 'tree inventory',
    'bomen inventaris': 'tree inventory',
    'tree inventory': 'tree inventory',
    'boom punten': 'tree points',
    'bomen punten': 'tree points',
    'tree points': 'tree points',
    'groene ruimtes': 'green spaces',
    'groene ruimten': 'green spaces',
    'green spaces': 'green spaces',
    'gebouwen': 'buildings',
    'gebÃ¤ude': 'buildings',
    'buildings': 'buildings',
    'corridors': 'wellâ€‘being corridors',
    'groene corridors': 'wellâ€‘being corridors',
    'corridoren': 'wellâ€‘being corridors',
    'green corridors': 'wellâ€‘being corridors',
    'heatmap': 'heatmap',
    'hittekaart': 'heatmap',
    'hitte kaart': 'heatmap'
  };

  /**
   * Given a lowerâ€‘cased query string, return a dictionary response if the query
   * directly references a known ecological term.  Recognises forms like
   * â€œdefine ndviâ€, â€œwhat is uhiâ€, â€œexplain biodiversityâ€ or just â€œndviâ€.
   * Returns null if no match is found.
   */
  function getDictionaryResponse(text){
    const t = String(text || '').trim().toLowerCase();
    if(!t) return null;
    // Remove leading query verbs from multiple languages (e.g., define, beschrijf, what is, was ist, explain, erklÃ¤ren).
    let q = t.replace(/^(define|definieer|beschrijf|beschrijven|what is|wat is|was ist|erklÃ¤re|erklaere|erklÃ¤ren|erklaeren|explain|erkl\u00e4re|erkl\u00e4ren)\s+/i, '').trim();
    // Remove trailing punctuation from query
    q = q.replace(/[?!.]+$/,'');
    // Apply alias mapping to recognise multilingual synonyms
    const canonical = aliasMap[q] || q;
    if(ecoDictionary.hasOwnProperty(canonical)){
      const entry = ecoDictionary[canonical];
      let resp = '';
      if(canonical !== q){
        resp += `I may be interpreting this as ${canonical}. `;
      }
      resp += entry.definition;
      if(entry.related && entry.related.length){
        resp += ' Related concepts: ' + entry.related.join(', ') + '.';
      }
      if(entry.suggestions && entry.suggestions.length){
        resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
      }
      return resp;
    }
    // Fallback: check for dictionary key matches when user includes forms like "define uhi" or ends with term
    for(const key in ecoDictionary){
      if(!ecoDictionary.hasOwnProperty(key)) continue;
      const k = key.toLowerCase();
      if(t === k || t === ('define ' + k) || t === ('what is ' + k) || t === ('explain ' + k) || t.endsWith(' ' + k)){
        const entry = ecoDictionary[key];
        let resp = entry.definition;
        if(entry.related && entry.related.length){
          resp += ' Related concepts: ' + entry.related.join(', ') + '.';
        }
        if(entry.suggestions && entry.suggestions.length){
          resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
        }
        return resp;
      }
    }
    return null;
  }

  /**
   * Update predictive suggestions dropdown based on the current input value.
   * Searches dictionary terms and generic suggestions for matches and renders
   * clickable suggestion items.  If no input or matches exist, hides the list.
   */
  function updateSuggestions(value){
    const suggEl = document.getElementById('assistantSuggestions');
    if(!suggEl) return;
    const v = (value || '').trim().toLowerCase();
    if(!v){
      suggEl.innerHTML = '';
      suggEl.style.display = 'none';
      return;
    }
    const results = [];
    // dictionary term matches
    for(const key in ecoDictionary){
      if(!ecoDictionary.hasOwnProperty(key)) continue;
      if(key.startsWith(v) || key.includes(v)){
        results.push({type:'dict', text: key});
      }
    }
    // generic suggestion matches
    generalSuggestions.forEach(s => {
      const sl = s.toLowerCase();
      if(sl.includes(v)){
        results.push({type:'gen', text: s});
      }
    });
    // Limit to 5 suggestions
    const limited = results.slice(0, 5);
    if(limited.length === 0){
      suggEl.innerHTML = '';
      suggEl.style.display = 'none';
      return;
    }
    suggEl.innerHTML = '';
    limited.forEach(item => {
      const div = document.createElement('div');
      div.className = 'suggestion-item';
      div.textContent = item.text;
      div.addEventListener('click', () => {
        const inputEl = document.getElementById('assistantInput');
        if(inputEl){
          inputEl.value = item.text;
        }
        // hide suggestions
        suggEl.innerHTML = '';
        suggEl.style.display = 'none';
        processInput(item.text);
      });
      suggEl.appendChild(div);
    });
    suggEl.style.display = 'block';
  }

  /**
   * Compute highâ€‘level statistics about the municipal tree dataset.
   * Returns an object with total count, total COâ‚‚ stored, total projected
   * annual sequestration (midâ€‘range), average height, and a map of species
   * counts. If the dataset is not yet loaded, returns null.
   */
  function getMunicipalStats(){
    if(!layers || !layers.trees_muni || !layers.trees_muni.entities) return null;
    const ds = layers.trees_muni;
    const time = (viewer && viewer.clock && viewer.clock.currentTime) || Cesium.JulianDate.now();
    let count = 0;
    let totalCo2 = 0;
    let totalCo2Future = 0;
    let totalHeight = 0;
    const speciesCount = {};
    for(const e of ds.entities.values){
      count++;
      const co2 = safePropNumber(e, TREE_KEYS.co2, time) || 0;
      totalCo2 += co2;
      // midâ€‘range projection for future sequestration (kg/yr)
      const co2Next = safePropNumber(e, TREE_EXTRA_KEYS.co2NextMed, time) || 0;
      totalCo2Future += co2Next;
      const h = safePropNumber(e, TREE_KEYS.height, time);
      if(h !== null && h !== undefined) totalHeight += h;
      const sp = (safePropString(e, TREE_KEYS.species, time) || '').trim();
      if(sp){
        speciesCount[sp] = (speciesCount[sp] || 0) + 1;
      }
    }
    const avgHeight = count > 0 ? (totalHeight / count) : 0;
    return { count, totalCo2, totalCo2Future, speciesCount, avgHeight };
  }
  function addMessage(sender, text){
    const messagesEl = document.getElementById('assistantMessages');
    if(!messagesEl) return;
    const div = document.createElement('div');
    div.className = 'assistant-message ' + (sender === 'user' ? 'user' : 'bot');
    div.textContent = text;
    messagesEl.appendChild(div);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  function updateChips(chips){
    const chipsEl = document.getElementById('assistantChips');
    if(!chipsEl) return;
    chipsEl.innerHTML = '';
    chips.forEach(ch => {
      const chip = document.createElement('div');
      chip.className = 'assistant-chip';
      chip.textContent = ch.label;
      chip.addEventListener('click', () => {
        addMessage('user', ch.label);
        processInput(ch.command || ch.label);
      });
      chipsEl.appendChild(chip);
    });
  }
  function assistantUpdateChips(type){
    if(type === 'tree'){
      updateChips([
        { label: 'Show Growth Projection', command: 'growth projection' },
        { label: 'Why is this area hot?', command: 'why is this area hot' },
        { label: 'Explain NDVI', command: 'explain ndvi' }
      ]);
      return;
    }
    if(type === 'building'){
      updateChips([
        { label: 'Why is this building a priority?', command: 'why is this building a priority' },
        { label: 'Explain MCDA', command: 'explain mcda' },
        { label: 'Explain UHI', command: 'explain uhi' }
      ]);
      return;
    }
    if(type === 'scenario'){
      updateChips([
        { label: 'Explain Scenario Polygon', command: 'explain scenario polygon' },
        { label: 'Explain NDVI', command: 'explain ndvi' },
        { label: 'Explain UHI', command: 'explain uhi' }
      ]);
      return;
    }
    updateChips(defaultChips);
  }
  window.assistantUpdateChips = assistantUpdateChips;
  function processInput(input){
    const msg = input || '';
    const text = msg.trim().toLowerCase();
    if(!text) return;
    // --- Multilingual action commands ---
    // Show/toggle the heatmap when users request "toon hittekaart" (NL) or "zeige hitzekarte" (DE)
    if((text.includes('toon') && (text.includes('hittekaart') || text.includes('hitte kaart'))) ||
       (text.includes('zeige') && (text.includes('hitzekarte') || text.includes('hitze karte')))){
      toggleLayer('heatmap');
      const sw = document.getElementById('sw-heatmap');
      const isOn = sw && sw.classList.contains('active');
      addMessage('bot', 'Heatmap ' + (isOn ? 'enabled' : 'disabled') + '.');
      assistantUpdateChips();
      return;
    }
    // Activate green roof drawing when users ask for green roofs ("groene daken", "grÃ¼ne dÃ¤cher")
    if(((text.includes('toon') || text.includes('zeige')) &&
        ((text.includes('groene') || text.includes('grÃ¼ne') || text.includes('grune')) &&
         (text.includes('dak') || text.includes('dÃ¤cher') || text.includes('dacher') || text.includes('daken'))))){
      const el = document.getElementById('sc-greenroof');
      if(el) selectScenarioType('greenroof', el);
      startPolygonDraw();
      addMessage('bot', 'Green roof drawing mode activated. Click on the map to draw your green roof polygon; rightâ€‘click to finish.');
      assistantUpdateChips('scenario');
      return;
    }
    // Run MCDA when users ask to prioritise buildings ("prioriteer gebouwen", "priorisieren gebÃ¤ude")
    if(((text.includes('prioriteer') || text.includes('prioritiseer') || text.includes('priorisieren') || text.includes('priorisiere')) &&
        (text.includes('gebouw') || text.includes('gebouwen') || text.includes('gebÃ¤ude') || text.includes('gebaeude')))){
      addMessage('bot', 'Running decision support...');
      try{
        openMCDA();
        runMCDA();
      }catch(e){}
      assistantUpdateChips('building');
      return;
    }
    // Start scenario drawing when users say "szenario zeichnen" (DE) or "scenario tekenen" (NL)
    if(((text.includes('szenario') || text.includes('scenario')) &&
        (text.includes('zeichnen') || text.includes('zeichne') || text.includes('teken') || text.includes('tekenen')))){
      // Determine scenario type based on keywords; default to trees
      let scenario = 'trees';
      if(text.includes('gras') || text.includes('grass')) scenario = 'grass';
      if(text.includes('struik') || text.includes('struiken') || text.includes('shrub')) scenario = 'shrubs';
      if(text.includes('gemengd') || text.includes('mixed')) scenario = 'mixed';
      if(text.includes('raingarden') || text.includes('regentuin')) scenario = 'raingarden';
      if(text.includes('permeabel') || text.includes('permeable')) scenario = 'permeable';
      if(text.includes('shading') || text.includes('schaduw')) scenario = 'shading';
      if(text.includes('green roof') || text.includes('groen dak') || text.includes('grÃ¼ne dÃ¤cher')) scenario = 'greenroof';
      const el = document.getElementById('sc-' + scenario);
      if(el) selectScenarioType(scenario, el);
      startPolygonDraw();
      addMessage('bot', 'Drawing mode activated. Click on the map to draw your polygon; rightâ€‘click to finish.');
      assistantUpdateChips('scenario');
      return;
    }
    // Definitions via ecological dictionary
    const dictResp = getDictionaryResponse(text);
    if(dictResp){
      addMessage('bot', dictResp);

      // Enrich with a short Wikipedia snippet when possible
      (async () => {
        const wikiMap = {
          'ndvi': 'Normalized difference vegetation index',
          'uhi': 'Urban heat island',
          'mcda': 'Multi-criteria decision analysis',
          'green corridor': 'Wildlife corridor',
          'wellâ€‘being corridor': 'Wildlife corridor',
          'ecosystem services': 'Ecosystem services',
          'stormwater': 'Stormwater',
          'biodiversity': 'Biodiversity',
          // Additional mappings for expanded dictionary
          'green roof': 'Green roof',
          'permeable surfaces': 'Permeable paving',
          'tree canopy': 'Tree canopy',
          'native species': 'Native species',
          'invasive species': 'Invasive species',
          'natureâ€‘based solutions': 'Nature-based solutions',
          'urban resilience': 'Climate resilience',
          'meadow': 'Meadow',
          'wetland': 'Wetland',
          'urban forest': 'Urban forest',
          'eu biodiversity strategy': 'European Union Biodiversity Strategy for 2030',
          'green deal': 'European Green Deal',
          'nature restoration law': 'Nature Restoration Law',
          'climate adaptation plan': 'Climate change adaptation',
          'cooling impact': 'Urban heat island mitigation',
          'biodiversity benefit': 'Biodiversity',
          'water management': 'Water resource management',
          'human comfort': 'Thermal comfort'
        };
        for(const k in wikiMap){
          if(text.includes(k)){
            const s = await fetchWikiSummary(wikiMap[k]);
            if(s && s.extract){
              const excerpt = s.extract.length > 280 ? (s.extract.slice(0, 280) + 'â€¦') : s.extract;
              addMessage('bot', `Wikipedia (${s.title}): ${excerpt}${s.page ? '\n' + s.page : ''}`);
            }
            break;
          }
        }
      })().catch(()=>{});

      assistantUpdateChips();
      return;
    }
    // Budget / financial tradeâ€‘off queries (e.g., "I have 1000 euro to spend")
    const budgetMatch = text.match(/(\d{2,7})\s*(â‚¬|eur|euro)/i) || (text.includes('budget') ? text.match(/\b(\d{2,7})\b/) : null);
    if(budgetMatch){
      const budget = Number(budgetMatch[1]);
      if(Number.isFinite(budget) && budget > 0){
        const objGuess =
          (text.includes('cool') || text.includes('heat')) ? 'cooling' :
          (text.includes('co2') || text.includes('carbon')) ? 'carbon' :
          (text.includes('storm') || text.includes('water') || text.includes('flood')) ? 'stormwater' :
          (text.includes('bio') || text.includes('habitat') || text.includes('species')) ? 'biodiversity' :
          'balanced';

        const plan = planForBudget(budget, objGuess);
        addMessage('bot', formatPlanText(plan));
        addMessage('bot', "Want alternatives? Try: 'cooling plan for â‚¬1000' or 'biodiversity plan for â‚¬1000'.");
        assistantUpdateChips();
        return;
      }
    }

    // Idea / future planning suggestions
    if(text.includes('plan') || text.includes('idea') || text.includes('future')){
      addMessage('bot', 'Here are some ideas for future ecological planning: plant mixed vegetation for biodiversity, create green corridors to connect parks, install green facades on priority buildings, run MCDA to prioritise interventions and increase shading to reduce UHI.');
      assistantUpdateChips();
      return;
    }
    // Custom queries: municipal tree summary and future prediction
    if((text.includes('tree') && text.includes('summary')) || (text.includes('municipal') && (text.includes('summary') || text.includes('stats')))){
      const stats = getMunicipalStats();
      if(!stats){
        addMessage('bot', 'Municipal tree data is still loading.');
      } else {
        const speciesEntries = Object.entries(stats.speciesCount);
        // Sort species by count descending and pick top 3 for succinctness
        speciesEntries.sort((a, b) => b[1] - a[1]);
        const topSpecies = speciesEntries.slice(0, 3).map(([s, c]) => `${s} (${c})`).join(', ');
        const message = `There are ${stats.count.toLocaleString()} municipal trees storing approximately ${Math.round(stats.totalCo2).toLocaleString()} kg of COâ‚‚. The most common species include ${topSpecies}. The average height is about ${stats.avgHeight.toFixed(1)} m.`;
        addMessage('bot', message);
      }
      assistantUpdateChips();
      return;
    }
    if(text.includes('future') && text.includes('prediction')){
      const stats = getMunicipalStats();
      if(!stats){
        addMessage('bot', 'Municipal tree data is still loading, so I canâ€™t compute future projections yet.');
      } else {
        const yearly = Math.round(stats.totalCo2Future).toLocaleString();
        addMessage('bot', `Based on the growth projections, municipal trees could sequester roughly ${yearly} kg of COâ‚‚ per year (midâ€‘range estimate) as they mature. Continued growth and planting will enhance cooling and biodiversity benefits.`);
      }
      assistantUpdateChips();
      return;
    }
    // Multilingual greetings and farewells.
    // Recognise common Dutch/German greetings like â€œhalloâ€, â€œhoiâ€, â€œgoedemorgenâ€ and
    // â€œguten Morgenâ€ and treat them as English salutations.  This makes the
    // assistant approachable for users greeting in their native language while
    // still replying in English.  Similarly, farewell expressions like
    // â€œtschÃ¼ssâ€, â€œdoeiâ€ or â€œauf wiedersehenâ€ are handled below.
    if(/^(hi|hello|hey|hallo|hoi|guten\s*(morgen|tag|abend)|goed(e|en)?\s*(morgen|middag|avond)|servus|moin)/.test(text)){
      addMessage('bot', 'Hello! How can I assist you with your ecological twin?');
      assistantUpdateChips();
      return;
    }
    if(/\b(bye|goodbye|see\s*you|tschÃ¼ss|tschuss|auf\s*wiedersehen|doei|tot\s*ziens|dag)\b/.test(text)){
      addMessage('bot', 'Goodbye! Have a great day.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('heatmap') && (text.includes('turn on') || text.includes('turn off') || text.includes('toggle') || text.includes('switch'))){
      toggleLayer('heatmap');
      const sw = document.getElementById('sw-heatmap');
      const isOn = sw && sw.classList.contains('active');
      addMessage('bot', 'Heatmap ' + (isOn ? 'enabled' : 'disabled') + '.');
      assistantUpdateChips();
      return;
    }
    if((text.includes('run') && text.includes('mcda')) || (text.includes('decision') && text.includes('support')) || text.includes('prioritis') || text.includes('prioritize')){
      addMessage('bot', 'Running decision support...');
      try{
        openMCDA();
        runMCDA();
      }catch(e){}
      assistantUpdateChips('building');
      return;
    }
    if(text.includes('start') && (text.includes('draw') || text.includes('drawing'))){
      let scenario = 'trees';
      if(text.includes('grass')) scenario = 'grass';
      if(text.includes('shrub')) scenario = 'shrubs';
      if(text.includes('mixed')) scenario = 'mixed';
      const el = document.getElementById('sc-' + scenario);
      if(el) selectScenarioType(scenario, el);
      startPolygonDraw();
      addMessage('bot', 'Drawing mode activated. Click on the map to draw your polygon; rightâ€‘click to finish.');
      assistantUpdateChips('scenario');
      return;
    }
    if(text.includes('plant') && (text.includes('oak') || text.includes('tree'))){
      const grids = document.querySelectorAll('#rightPanel .species-grid');
      const treeGrid = grids[0];
      let elOak = null;
      if(treeGrid){
        treeGrid.querySelectorAll('.species-opt').forEach(opt => {
          if(opt.textContent.toLowerCase().includes('oak')) elOak = opt;
        });
      }
      if(elOak) selectSpecies('oak', elOak);
      togglePlanting();
      addMessage('bot', 'Planting mode activated. Click on the map to place the oak tree.');
      assistantUpdateChips('tree');
      return;
    }
    if((text.includes('apply') && text.includes('ivy')) || (text.includes('ivy') && text.includes('facade'))){
      const grids = document.querySelectorAll('#rightPanel .species-grid');
      const facadeGrid = grids[1];
      let elIvy = null;
      if(facadeGrid){
        facadeGrid.querySelectorAll('.species-opt').forEach(opt => {
          if(opt.textContent.toLowerCase().includes('ivy')) elIvy = opt;
        });
      }
      if(elIvy) selectFacadeType('ivy', elIvy);
      toggleFacading();
      addMessage('bot', 'Facade mode activated. Click on a building to apply the ivy facade.');
      assistantUpdateChips('building');
      return;
    }
    if(text.includes('download') && text.includes('report')){
      addMessage('bot', 'Generating and downloading the PDF report...');
      try{ downloadReport(); }catch(e){}
      assistantUpdateChips();
      return;
    }
    if(text.includes('download') && text.includes('chart')){
      addMessage('bot', 'Downloading the chart...');
      try{ downloadCharts(); }catch(e){}
      assistantUpdateChips();
      return;
    }
    if(text.includes('ndvi')){
      addMessage('bot', 'NDVI (Normalised Difference Vegetation Index) compares nearâ€‘infrared and red reflectance to assess vegetation health. Values range from -1 to +1; healthy vegetation produces higher NDVI values, while low or negative values indicate barren or built surfaces or water.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('uhi') || text.includes('urban heat island') || text.includes('heat island')){
      addMessage('bot', 'Urban Heat Islands are pockets of higher temperature within cities caused by heatâ€‘absorbing materials, reduced vegetation and anthropogenic heat. The UHI heatmap visualises relative surface temperatures; combining it with NDVI highlights hot, stressed areas.');
      assistantUpdateChips();
      return;
    }
    if((text.includes('green') && text.includes('corridor')) || text.includes('corridors')){
      addMessage('bot', 'Green corridors are lines connecting green spaces that indicate ecological connectivity and facilitate wildlife movement. These corridors are visualised in the green corridors layer and considered in the MCDA prioritisation.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('scenario') || text.includes('polygon') || text.includes('grass') || text.includes('shrub') || text.includes('mixed')){
      addMessage('bot', 'Scenario polygons let you draw grass, shrub, tree or mixed vegetation areas. Each type has defined effects on NDVI, cooling per hectare, stormwater infiltration and biodiversity proxy, as specified in the SCENARIO_PARAMS object.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('mcda') || text.includes('decision support')){
      addMessage('bot', 'MCDA (Multiâ€‘Criteria Decision Analysis) ranks buildings based on criteria like UHI, NDVI, corridor proximity, age and footprint area. Adjust the objectives and parameters in the wizard to prioritise interventions.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('why') && text.includes('priority')){
      addMessage('bot', 'Buildings are prioritised when they exhibit high UHI, low NDVI, are near green corridors, are older and have larger footprints. These factors combine into a score used by the MCDA ranking.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('why') && text.includes('hot')){
      addMessage('bot', 'This area is likely hot due to heatâ€‘absorbing surfaces and low vegetation cover. High UHI values combined with low NDVI highlight such stressed areas.');
      assistantUpdateChips();
      return;
    }
    if(text.includes('growth') || text.includes('projection')){
      addMessage('bot', 'Growth projections are available for municipal trees. Select a tree to see estimates of trunk diameter, aboveâ€‘ground biomass and annual COâ‚‚ uptake over future years.');
      assistantUpdateChips();
      return;
    }
    addMessage('bot', 'Let me look that upâ€¦ (Wikipedia)');

    (async () => {
      const title = await wikiOpenSearch(msg);
      if(!title){
        addMessage('bot', 'Sorry â€” I couldn\'t find a relevant Wikipedia page.');
        assistantUpdateChips();
        return;
      }
      const s = await fetchWikiSummary(title);
      if(!s || !s.extract){
        addMessage('bot', `I found "${title}", but couldn\'t fetch a summary.`);
        assistantUpdateChips();
        return;
      }
      const excerpt = s.extract.length > 520 ? (s.extract.slice(0, 520) + 'â€¦') : s.extract;
      addMessage('bot', `Wikipedia (${s.title}): ${excerpt}${s.page ? '\n' + s.page : ''}`);
      assistantUpdateChips();
    })().catch(() => {
      addMessage('bot', 'Sorry, I couldn\'t find an answer.');
      assistantUpdateChips();
    });
  }
  document.addEventListener('DOMContentLoaded', () => {
    const sendBtn = document.getElementById('assistantSend');
    const inputEl = document.getElementById('assistantInput');
    // Toggle and close buttons for assistant
    const toggleBtn = document.getElementById('assistantToggle');
    const container = document.getElementById('assistantContainer');
    const closeBtn = document.getElementById('assistantClose');
    // Wire up send button and input
    if(sendBtn && inputEl){
      sendBtn.addEventListener('click', () => {
        const val = inputEl.value;
        if(val){
          addMessage('user', val);
          processInput(val);
          inputEl.value = '';
        }
      });
      inputEl.addEventListener('keypress', (e) => {
        if(e.key === 'Enter'){
          const val = inputEl.value;
          if(val){
            addMessage('user', val);
            processInput(val);
            inputEl.value = '';
          }
        }
      });
      // Update predictive suggestions as the user types
      inputEl.addEventListener('input', () => {
        updateSuggestions(inputEl.value);
      });
    }
    // Assistant toggle behaviour
    if(toggleBtn && container){
      toggleBtn.addEventListener('click', () => {
        container.classList.toggle('hide');
        // hide suggestions when toggling the assistant
        const sEl = document.getElementById('assistantSuggestions');
        if(sEl){
          sEl.innerHTML = '';
          sEl.style.display = 'none';
        }
      });
    }
    // Close button hides the assistant but leaves the toggle visible
    if(closeBtn && container){
      closeBtn.addEventListener('click', () => {
        container.classList.add('hide');
        // hide suggestions when closing the assistant
        const sEl = document.getElementById('assistantSuggestions');
        if(sEl){
          sEl.innerHTML = '';
          sEl.style.display = 'none';
        }
      });
    }
    // Show suggestions when page loads
    assistantUpdateChips();
  });
})();
</script>

<!-- Weather update script: fetch realâ€‘time weather and update the widget -->
<script>
// Coordinates for Enschede, Netherlands
const WEATHER_LAT = 52.221;
const WEATHER_LON = 6.893;
async function updateWeather(){
  try {
    // Fetch combined current weather, daily extremes and humidity
    const wResp = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${WEATHER_LAT}&longitude=${WEATHER_LON}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,snowfall_sum&hourly=relative_humidity_2m&forecast_hours=1&timezone=Europe/Amsterdam`);
    const wData = await wResp.json();
    // Save the latest weather response so we can compute UHI statistics when showing details.  This
    // ensures that the digital twin analysis has access to the daily min/max temperatures.
    window.latestWeather = wData;
    const tempEl = document.getElementById('weatherTemp');
    const eventEl = document.getElementById('weatherEvent');
    const barEl = document.getElementById('weatherBarFill');
    if(!wData || !tempEl || !eventEl || !barEl) return;
    // Update current temperature
    if(wData.current_weather && typeof wData.current_weather.temperature === 'number'){
      tempEl.innerText = wData.current_weather.temperature.toFixed(1) + 'Â°C';
    }
    // Save current humidity if available (take the first hour)
    if(wData.hourly && Array.isArray(wData.hourly.relative_humidity_2m) && wData.hourly.relative_humidity_2m.length > 0){
      window.currentHumidity = wData.hourly.relative_humidity_2m[0];
    } else {
      window.currentHumidity = null;
    }
    // Determine next snow or heat event within 7 days using daily values
    let nextDays = null;
    let type = '';
    if(wData.daily && Array.isArray(wData.daily.time)){
      const today = new Date();
      today.setHours(0,0,0,0);
      for(let idx = 0; idx < wData.daily.time.length; idx++){
        const dt = new Date(wData.daily.time[idx]);
        const diffDays = Math.round((dt.getTime() - today.getTime()) / (1000*60*60*24));
        if(diffDays < 0) continue;
        const snow = wData.daily.snowfall_sum && wData.daily.snowfall_sum[idx] ? wData.daily.snowfall_sum[idx] : 0;
        const tmax = wData.daily.temperature_2m_max && typeof wData.daily.temperature_2m_max[idx] === 'number' ? wData.daily.temperature_2m_max[idx] : null;
        if(snow > 0){
          nextDays = diffDays;
          type = 'Snowfall';
          break;
        } else if(tmax !== null && tmax >= 30){
          nextDays = diffDays;
          type = 'Heat';
          break;
        }
      }
    }
    if(nextDays !== null && nextDays <= 7){
      const frac = nextDays / 7;
      barEl.style.width = Math.max(0, Math.min(1, frac)) * 100 + '%';
      eventEl.innerText = (type === 'Snowfall' ? 'Next snowfall in ' : 'Next heat in ') + nextDays + ' day' + (nextDays === 1 ? '' : 's');
    } else {
      // No extreme event within 7 days
      barEl.style.width = '0%';
      eventEl.innerText = 'No extreme weather in 7 days';
    }
    // Fetch current air quality values (European AQI and pollutants)
    try{
      const aqResp = await fetch(`https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${WEATHER_LAT}&longitude=${WEATHER_LON}&current=european_aqi,pm2_5,pm10,ozone,nitrogen_dioxide&timezone=Europe/Amsterdam`);
      const aqData = await aqResp.json();
      if(aqData && aqData.current && typeof aqData.current.european_aqi === 'number'){
        window.currentAQI = aqData.current.european_aqi;
      } else {
        window.currentAQI = null;
      }
    }catch(aqErr){
      console.warn('Air quality fetch failed', aqErr);
      window.currentAQI = null;
    }
  }catch(err){
    console.warn('Weather fetch failed', err);
  }
}
// Display detailed weather information in a pop-up
function showWeatherDetails(){
  const modal = document.getElementById('weatherModal');
  const content = document.getElementById('weatherDetailContent');
  if(!modal || !content) return;
  // Build rows for temperature, humidity and air quality
  const temp = document.getElementById('weatherTemp') ? document.getElementById('weatherTemp').innerText : '--Â°C';
  const humidity = (typeof window.currentHumidity === 'number') ? Math.round(window.currentHumidity) + '%' : 'â€”';
  const aqi = (typeof window.currentAQI === 'number') ? Math.round(window.currentAQI) : 'â€”';
  // European AQI ranges: 0-20 good, 20-40 fair, 40-60 moderate, 60-80 poor, 80-100 very poorã€411077823428057â€ L400-L404ã€‘.
  let aqiDesc = '';
  if(typeof window.currentAQI === 'number'){
    const val = window.currentAQI;
    if(val < 20) aqiDesc = 'Good air quality';
    else if(val < 40) aqiDesc = 'Fair air quality';
    else if(val < 60) aqiDesc = 'Moderate air quality';
    else if(val < 80) aqiDesc = 'Poor air quality';
    else if(val <= 100) aqiDesc = 'Very poor air quality';
    else aqiDesc = 'Extremely poor air quality';
  }
  let html = '';
  html += `<div class="pop-row"><span class="pop-label">Temperature</span><span class="pop-val">${temp}</span></div>`;
  html += `<div class="pop-row"><span class="pop-label">Humidity</span><span class="pop-val">${humidity}</span></div>`;
  html += `<div class="pop-row"><span class="pop-label">AQI</span><span class="pop-val">${aqi}</span></div>`;
  // Provide a note about air quality underneath the AQI value.
  html += `<div style="font-size:10px; margin-top:6px; color:rgba(226,232,240,0.75);">${aqiDesc ? aqiDesc + '. ' : ''}Lower values indicate better air quality. Planting more trees and reducing emissions can improve local air quality.</div>`;

  // --------------------------------------------------------------------
  // UHI analysis and digital twin scenario
  // The urban heat island (UHI) effect describes how urban areas are warmer than
  // surrounding rural regions. We approximate the current UHI intensity by
  // comparing the current temperature to the average of today's minimum and
  // maximum forecast temperatures. Research summarised by the US EPA shows that
  // urban areas are typically 0.6â€“3.9Â Â°C warmer than outlying areasã€27550909506927â€ L90-L105ã€‘.
  // Additional greenery can help cool cities. Studies find that a 1Â % increase
  // in urban tree canopy may lower local air temperatures by around 0.04â€“0.57Â Â°Cã€969637698235284â€ L145-L148ã€‘.
  // Largeâ€“scale green roofs can also reduce ambient temperatures by roughly
  // 0.3â€“3Â Â°C, with an average reduction of about 1.34Â Â°Cã€412812815950243â€ L70-L73ã€‘.
  let uhiMessage = '';
  try {
    if (window.latestWeather && window.latestWeather.current_weather && typeof window.latestWeather.current_weather.temperature === 'number') {
      const currentT = window.latestWeather.current_weather.temperature;
      const daily = window.latestWeather.daily;
      let baseline = null;
      // Use the first day's min and max as a simple proxy for rural baseline
      if (daily && Array.isArray(daily.temperature_2m_min) && daily.temperature_2m_min.length > 0) {
        baseline = daily.temperature_2m_min[0];
      }
      if (daily && Array.isArray(daily.temperature_2m_max) && daily.temperature_2m_max.length > 0 && baseline !== null) {
        baseline = (baseline + daily.temperature_2m_max[0]) / 2;
      }
      if (baseline !== null) {
        const uhi = currentT - baseline;
        let level = 'Moderate';
        if (uhi < 2) level = 'Low';
        else if (uhi >= 4) level = 'High';
        // Compose the explanatory message
        uhiMessage += `Urban heat island intensity: approximately ${uhi.toFixed(1)}Â Â°C (${level}).`;
      }
      // Suggest a simple digital twin scenario: increasing tree canopy and green roofs
      const canopyPct = 5; // assume a 5Â % increase in tree canopy
      const canopyReduction = canopyPct * 0.2; // mid-range reduction per 1Â % canopy
      const greenRoofPct = 10; // assume 10Â % roof area converted to green roofs
      const greenReduction = 1.34; // average cooling from large-scale green roofs
      const totalReduction = canopyReduction + greenReduction;
      uhiMessage += ` Adding ${canopyPct}% more tree canopy could lower air temperatures by roughly ${canopyReduction.toFixed(1)}Â Â°C. `;
      uhiMessage += `Installing green roofs on about ${greenRoofPct}% of rooftops may cool the area by another ~${greenReduction.toFixed(2)}Â Â°C. Together, these measures might reduce local temperatures by around ${totalReduction.toFixed(1)}Â Â°C and lessen heat stress.`;
    }
  } catch (e) {
    console.warn('UHI analysis failed', e);
  }
  if (uhiMessage) {
    // Append the UHI message as its own paragraph.  Concatenate the string to
    // avoid nested template literal interpolation issues.
    html += '<div style="margin-top:10px; font-size:10px; line-height:1.4; color:rgba(226,232,240,0.75);">' + uhiMessage + '</div>';
  }
  content.innerHTML = html;
  modal.style.display = 'block';
}
function closeWeatherModal(){
  const modal = document.getElementById('weatherModal');
  if(modal) modal.style.display = 'none';
}
// Start weather updates once the page has loaded
window.addEventListener('load', () => {
  updateWeather();
  setInterval(updateWeather, 3600 * 1000);
});

// -----------------------------------------------------------------------------
// Messaging bridge to parent page (see ecology.html for details)
window.addEventListener('message', (event) => {
  const msg = event.data;
  if (!msg || typeof msg.type !== 'string') return;
  if (msg.type === 'SETTINGS_UPDATE' || msg.type === 'ECO_SETTINGS_UPDATE') {
    const payload = msg.payload || {};
    window.GLOBAL_SETTINGS = payload;
    window.ECO_SETTINGS = payload;
    try { localStorage.setItem('GLOBAL_ECO_SETTINGS', JSON.stringify(payload)); } catch(e) {}
    // Apply incoming weights to MCDA sliders when provided and re-run MCDA
    try {
      if (payload && payload.weights) {
        const w = payload.weights;
        const setSlider = (id, val, labelId) => {
          const elem = document.getElementById(id);
          const lab  = document.getElementById(labelId);
          if (elem && Number.isFinite(val)) {
            elem.value = val;
            if (lab) lab.textContent = Number(val).toFixed(2);
          }
        };
        setSlider('mcdaWeightU',   w.uhi,      'mcdaWeightUVal');
        setSlider('mcdaWeightN',   w.ndvi,     'mcdaWeightNVal');
        setSlider('mcdaWeightC',   w.corridor, 'mcdaWeightCVal');
        setSlider('mcdaWeightA',   w.age,      'mcdaWeightAVal');
        setSlider('mcdaWeightR',   w.area,     'mcdaWeightRVal');
      }
      if (typeof runMCDA === 'function') {
        runMCDA();
      }
    } catch(e){}
  } else if (msg.type === 'SCENARIO_UPDATE') {
    // No scenario toggling implemented for ecology at this time
  }
});
</script>

<!-- Standalone ecology settings management -->
<script>
// -------------------------------------------------------------------------
// Standalone ecology settings management
//
// Provides an inâ€‘app UI for adjusting MCDA weights, cost parameters,
// discount rate, horizon and feasible space limits when running the
// standâ€‘alone ecology digital twin.  Values are loaded from a default
// object or pulled from GLOBAL_ECO_SETTINGS in localStorage.  When the
// user applies the settings the values are persisted to localStorage,
// stored on window.ECO_SETTINGS for other scripts to read, and basic UI
// updates or recomputations can be triggered.  The settings button is
// automatically hidden when the page is embedded inside the Nexus.
(function(){
  let ecologySettings = {
    weights: { uhi: 0.46, ndvi: 0.28, corridor: 0.10, age: 0.08, area: 0.08 },
    costs: { tree: 150, greenRoofPerM2: 80, infiltrationPerM2: 50 },
    discountRate: 0.04,
    horizonYears: 30,
    budgets: { maxRoofPercent: 20, maxTreeArea: 1000 }
  };
  try {
    const stored = localStorage.getItem('GLOBAL_ECO_SETTINGS');
    if (stored) {
      const parsed = JSON.parse(stored);
      if (parsed && typeof parsed === 'object') {
        ecologySettings = Object.assign({}, ecologySettings, parsed);
        if (parsed.weights) ecologySettings.weights = Object.assign({}, ecologySettings.weights, parsed.weights);
        if (parsed.costs) ecologySettings.costs = Object.assign({}, ecologySettings.costs, parsed.costs);
        if (parsed.budgets) ecologySettings.budgets = Object.assign({}, ecologySettings.budgets, parsed.budgets);
      }
    }
  } catch(e) {}
  function openEcoSettings(){
    const s = ecologySettings;
    document.getElementById('eco_weight_u').value   = s.weights.uhi ?? '';
    document.getElementById('eco_weight_n').value   = s.weights.ndvi ?? '';
    document.getElementById('eco_weight_c').value   = s.weights.corridor ?? '';
    document.getElementById('eco_weight_a').value   = s.weights.age ?? '';
    document.getElementById('eco_weight_r').value   = s.weights.area ?? '';
    document.getElementById('eco_discount').value   = ((s.discountRate || 0) * 100).toFixed(2);
    document.getElementById('eco_horizon').value    = s.horizonYears ?? '';
    document.getElementById('eco_max_roof').value   = s.budgets.maxRoofPercent ?? '';
    document.getElementById('eco_max_tree').value   = s.budgets.maxTreeArea ?? '';
    document.getElementById('eco_cost_tree').value  = s.costs.tree ?? '';
    document.getElementById('eco_cost_roof').value  = s.costs.greenRoofPerM2 ?? '';
    document.getElementById('eco_cost_infil').value = s.costs.infiltrationPerM2 ?? '';
    document.getElementById('eco-settings-overlay').classList.add('active');
  }
  function closeEcoSettings(){
    document.getElementById('eco-settings-overlay').classList.remove('active');
  }
  function applyEcoSettingsStandalone(){
    const s = ecologySettings;
    const wU = parseFloat(document.getElementById('eco_weight_u').value);
    const wN = parseFloat(document.getElementById('eco_weight_n').value);
    const wC = parseFloat(document.getElementById('eco_weight_c').value);
    const wA = parseFloat(document.getElementById('eco_weight_a').value);
    const wR = parseFloat(document.getElementById('eco_weight_r').value);
    if(Number.isFinite(wU)) s.weights.uhi = wU;
    if(Number.isFinite(wN)) s.weights.ndvi = wN;
    if(Number.isFinite(wC)) s.weights.corridor = wC;
    if(Number.isFinite(wA)) s.weights.age = wA;
    if(Number.isFinite(wR)) s.weights.area = wR;
    const rIn = parseFloat(document.getElementById('eco_discount').value);
    if(Number.isFinite(rIn)) s.discountRate = rIn / 100;
    const hIn = parseFloat(document.getElementById('eco_horizon').value);
    if(Number.isFinite(hIn)) s.horizonYears = hIn;
    const maxRoof = parseFloat(document.getElementById('eco_max_roof').value);
    if(Number.isFinite(maxRoof)) s.budgets.maxRoofPercent = maxRoof;
    const maxTree = parseFloat(document.getElementById('eco_max_tree').value);
    if(Number.isFinite(maxTree)) s.budgets.maxTreeArea = maxTree;
    const cTree = parseFloat(document.getElementById('eco_cost_tree').value);
    if(Number.isFinite(cTree)) s.costs.tree = cTree;
    const cRoof = parseFloat(document.getElementById('eco_cost_roof').value);
    if(Number.isFinite(cRoof)) s.costs.greenRoofPerM2 = cRoof;
    const cInfil = parseFloat(document.getElementById('eco_cost_infil').value);
    if(Number.isFinite(cInfil)) s.costs.infiltrationPerM2 = cInfil;
    try { localStorage.setItem('GLOBAL_ECO_SETTINGS', JSON.stringify(ecologySettings)); } catch(e) {}
    try { window.ECO_SETTINGS = JSON.parse(JSON.stringify(ecologySettings)); } catch(e) { window.ECO_SETTINGS = ecologySettings; }
    closeEcoSettings();
    try {
      if (typeof updateLeftPanel === 'function') updateLeftPanel();
      if (typeof runMCDA === 'function') runMCDA();
    } catch(e) {}
    // Synchronise weight sliders to new settings
    try {
      const w = ecologySettings.weights || {};
      const setSlider = (id, val, labelId) => {
        const elem = document.getElementById(id);
        const lab  = document.getElementById(labelId);
        if (elem && Number.isFinite(val)) {
          elem.value = val;
          if (lab) lab.textContent = Number(val).toFixed(2);
        }
      };
      setSlider('mcdaWeightU',   w.uhi,      'mcdaWeightUVal');
      setSlider('mcdaWeightN',   w.ndvi,     'mcdaWeightNVal');
      setSlider('mcdaWeightC',   w.corridor, 'mcdaWeightCVal');
      setSlider('mcdaWeightA',   w.age,      'mcdaWeightAVal');
      setSlider('mcdaWeightR',   w.area,     'mcdaWeightRVal');
    } catch(e){}
  }
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('ecoSettingsBtn');
    if (btn) btn.addEventListener('click', (ev) => { ev.stopPropagation(); openEcoSettings(); });
    const applyBtn  = document.getElementById('eco-settings-apply');
    const cancelBtn = document.getElementById('eco-settings-cancel');
    if (applyBtn)  applyBtn.addEventListener('click', applyEcoSettingsStandalone);
    if (cancelBtn) cancelBtn.addEventListener('click', closeEcoSettings);
  });
  window.addEventListener('load', () => {
    try {
      if (window.self !== window.top) {
        const sb = document.getElementById('ecoSettingsBtn');
        if (sb) sb.style.display = 'none';
      }
    } catch (e) {}
  });
  window.openEcoSettings = openEcoSettings;
  window.closeEcoSettings = closeEcoSettings;
  window.applyEcoSettings = applyEcoSettingsStandalone;
})();
</script>

<!-- Small onâ€‘screen hint summarising the camera controls. This helps users understand how to pan, zoom and rotate. -->
<div id="controlsHint" class="hint-pill" style="position: fixed; bottom: 80px; left: 20px; z-index: 600;">
  Leftâ€‘drag: rotate | Scroll: zoom | Rightâ€‘drag: pan
</div>
</body>
</html>
