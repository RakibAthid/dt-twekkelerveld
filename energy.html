<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Twekkelerveld Smart Energy Twin</title>

<!-- CesiumJS -->
<script src="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Cesium.js"></script>
<link href="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Cesium.js" rel="preload" as="script">
<link href="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Widgets/widgets.css" rel="stylesheet"/>

<!-- Charts + PDF -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.1.0/chartjs-plugin-annotation.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<!-- XLSX parser for Excel files (used to read .xlsx energy label files) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
  html, body, #cesiumContainer {
    margin: 0; padding: 0; width: 100%; height: 100%;
    overflow: hidden; font-family: 'Inter', sans-serif;
    background: #000;
  }

  :root {
    --glass-bg: rgba(15, 23, 42, 0.95);
    --glass-border: rgba(255, 255, 255, 0.15);
    --accent-primary: #3b82f6;
    --accent-success: #10b981;
    --accent-warning: #f59e0b;
    --accent-danger: #ef4444;
    --text-main: #f8fafc;
    --text-muted: #94a3b8;
    --section-bg: rgba(255, 255, 255, 0.05);
  }

  #titleBar {
    position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
    padding: 10px 24px;
    background: var(--glass-bg); color: var(--text-main);
    border: 1px solid var(--glass-border); border-radius: 99px;
    font-weight: 600; font-size: 15px; letter-spacing: 0.5px;
    backdrop-filter: blur(12px); pointer-events: auto; z-index: 1000;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    display: flex; align-items: center; gap: 10px;
    user-select: none;
  }
  #titleBar::before {
    content: ''; display: block; width: 8px; height: 8px;
    background: var(--accent-success); border-radius: 50%;
    box-shadow: 0 0 10px var(--accent-success);
  }

  #methodBtn {
    position: absolute; top: 20px; right: 20px; z-index: 1000;
    background: var(--glass-bg); color: var(--text-muted);
    border: 1px solid var(--glass-border); padding: 8px 16px;
    border-radius: 12px; cursor: pointer; font-weight: 500; font-size: 13px;
    transition: all 0.2s; backdrop-filter: blur(12px);
    user-select: none;
  }
  #methodBtn:hover { background: rgba(255,255,255,0.1); color: white; border-color:white; }

  #searchBar {
    position: absolute; top: 20px; left: 20px; z-index: 1000;
    background: var(--glass-bg); padding: 8px; border-radius: 12px;
    border: 1px solid var(--glass-border); display: flex; gap: 8px;
    backdrop-filter: blur(12px); box-shadow: 0 4px 20px rgba(0,0,0,0.2);
  }
  #searchInput {
    background: rgba(255,255,255,0.05); border: 1px solid transparent;
    color: white; padding: 8px 12px; border-radius: 8px;
    outline: none; width: 220px; font-family: inherit; font-size: 13px;
  }
  #searchBtn {
    background: var(--accent-primary); color: white; border: none;
    padding: 8px 16px; border-radius: 8px; cursor: pointer;
    font-weight: 600; font-size: 13px;
  }

  /* LEFT LEGEND */
  #leftLegend {
    
    position: absolute;
    top: 85px;
    left: 20px;
    width: 250px;
    z-index: 980;
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 10px;
    backdrop-filter: blur(14px);
    box-shadow: 0 12px 30px rgba(0,0,0,0.45);
    color: var(--text-main);
  }
  .leg-head {
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:10px;
    margin-bottom: 10px;
  }
  .leg-title {
    font-size: 13px;
    font-weight: 800;
    letter-spacing: 0.3px;
    margin: 0;
  }
  .leg-sub {
    font-size: 11px;
    color: var(--text-muted);
    margin-top: 4px;
    line-height: 1.35;
  }
  .leg-body {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 12px;
    padding: 10px;
  }
  .leg-gradient {
    height: 12px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.18);
    margin: 8px 0 6px;
  }
  .leg-row {
    display:flex;
    justify-content:space-between;
    gap:10px;
    font-size: 11px;
    color: #cbd5e1;
  }
  .leg-note {
    margin-top: 8px;
    font-size: 11px;
    color: var(--text-muted);
    line-height: 1.45;
  }
  .leg-selected {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.10);
    display:flex;
    justify-content:space-between;
    gap:10px;
    align-items:center;
    font-size: 11px;
    color: #cbd5e1;
  }
  .leg-selected b {
    color: #e2e8f0;
    font-size: 12px;
  }

  #hudStats {
    position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; align-items: center;
    background: var(--glass-bg); padding: 15px 30px; border-radius: 16px;
    border: 1px solid var(--glass-border); backdrop-filter: blur(12px);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index: 950;
  }
  .hud-item { text-align: center; min-width: 100px; }
  .hud-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; display: block;}
  .hud-val { font-size: 18px; font-weight: 700; color: var(--text-main); font-feature-settings: "tnum"; }
  .hud-unit { font-size: 12px; color: var(--text-muted); font-weight: 500; }

  .info-icon {
    width: 28px; height: 28px; border-radius: 50%;
    background: rgba(59, 130, 246, 0.2);
    border: 1px solid var(--accent-primary);
    display: flex; justify-content: center; align-items: center; cursor: pointer;
    font-size: 14px; font-weight: bold; color: white;
    margin-left: 15px; transition: all 0.2s;
    box-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
    user-select: none;
  }
  .info-icon:hover { background: var(--accent-primary); transform: scale(1.1); }

  .layer-info {
    width: 22px; height: 22px;
    border-radius: 50%;
    display:flex; align-items:center; justify-content:center;
    font-size: 12px; font-weight: 800;
    color: #e2e8f0;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.06);
    box-shadow: 0 0 12px rgba(59,130,246,0.12);
    user-select: none;
    cursor:pointer;
    flex: 0 0 auto;
  }
  .layer-info:hover { border-color: rgba(255,255,255,0.35); background: rgba(59,130,246,0.18); }

  /* Reset button styling ‚Äì small button next to the title.  Provides a way to return to the study area. */
  #resetViewBtn {
    background: var(--glass-bg);
    color: var(--text-muted);
    border: 1px solid var(--glass-border);
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 10px;
    transition: all 0.2s;
  }
  #resetViewBtn:hover {
    background: rgba(255,255,255,0.1);
    color: white;
    border-color: white;
  }

  #rightPanel {
    position: absolute; top: 85px; right: 20px; width: 360px;
    background: var(--glass-bg); padding: 24px; border-radius: 16px;
    border: 1px solid var(--glass-border); backdrop-filter: blur(16px);
    box-shadow: 0 15px 40px rgba(0,0,0,0.4); z-index: 900;
    max-height: calc(100vh - 120px); overflow-y: auto; color: var(--text-main);
  }
  #rightPanel::-webkit-scrollbar { width: 6px; }
  #rightPanel::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); }
  #rightPanel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }

  h3 { margin: 0 0 16px; font-size: 14px; color: var(--text-main); font-weight: 600; }
  h4 { margin: 24px 0 10px; font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.2px; font-weight: 700; }

  .section-group {
    background: var(--section-bg);
    border: 1px solid rgba(255,255,255,0.05);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 15px;
  }
  .section-label {
    font-size: 11px; font-weight: 700; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;
    margin-bottom: 10px; display: block;
  }

  button.mode-btn {
    width: 100%; padding: 12px 14px; margin-bottom: 6px;
    border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03);
    border-radius: 10px; color: #e2e8f0; text-align: left; cursor: pointer;
    font-size: 13px; font-weight: 500; font-family: 'Inter', sans-serif;
    transition: all 0.2s; display: flex; justify-content: space-between; align-items: center;
  }
  button.mode-btn:hover { background: rgba(255,255,255,0.08); transform: translateX(2px); }
  button.active { background: rgba(59, 130, 246, 0.15); border-color: var(--accent-primary); color: white; font-weight: 600; }

  .indicator-icon { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }
  .layer-right { display:flex; align-items:center; gap:10px; }

  input[type=range] { width: 100%; cursor: pointer; margin: 10px 0; accent-color: var(--accent-primary); }
  #legendGradient { height: 12px; border-radius: 6px; margin: 12px 0 6px; opacity: 1; border: 1px solid rgba(255,255,255,0.2); }
  .flex-between { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-muted); font-weight: 500; }

  #contextGraph {
      width: 100%; height: 60px; margin-bottom: 5px; background: rgba(255,255,255,0.02);
      border-radius: 8px; padding: 5px;
  }

  #infoPanel {
    position: absolute; bottom: 120px; left: 20px; width: 380px;
    background: rgba(15, 23, 42, 0.95); color: var(--text-main);
    padding: 20px; border-radius: 20px; border: 1px solid var(--glass-border);
    backdrop-filter: blur(20px); box-shadow: 0 20px 50px rgba(0,0,0,0.6);
    z-index: 900; display: none; animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
  }
  @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

  #infoPanel h2 { margin: 0; font-size: 18px; font-weight: 700; }
  #infoPanel .sub { color: var(--text-muted); font-size: 12px; margin-bottom: 15px; display: block; }

  .stat-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.08); gap: 10px; }
  .stat-val { font-size: 16px; font-weight: 700; color: var(--accent-primary); font-feature-settings: "tnum"; text-align: right; }
  .stat-label { font-size: 12px; color: #cbd5e1; font-weight: 500; }

  #tradeoffBox {
    margin-top: 15px; background: rgba(59, 130, 246, 0.1);
    border-radius: 12px; padding: 12px; border: 1px solid rgba(59, 130, 246, 0.2);
  }
  .trade-title { font-size: 11px; font-weight: 700; text-transform: uppercase; color: #93c5fd; margin-bottom: 8px; }
  .trade-row { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 12px; }
  .trade-good { color: var(--accent-success); font-weight: 600; }
  .trade-bad { color: #f87171; font-weight: 600; }

  #chartContainer {
    margin-top: 15px; background: rgba(0,0,0,0.2);
    border-radius: 12px; padding: 10px; border: 1px solid rgba(255,255,255,0.05); height: 150px;
  }

  #downloadRow { display: flex; gap: 10px; margin-top: 15px; }
  .action-btn {
    flex: 1; border: none; padding: 10px; border-radius: 8px;
    font-size: 11px; font-weight: 600; cursor: pointer; font-family: 'Inter', sans-serif; transition: filter 0.2s;
    display:flex; justify-content:center; align-items:center; gap:5px;
  }
  .action-btn:hover { filter: brightness(1.1); }
  #btnDownloadPdf { background: var(--accent-success); color: #022c22; }
  #btnClose {
    background: rgba(255,255,255,0.1); color: white; width: 28px; height: 28px;
    border-radius: 50%; border: none; cursor: pointer; font-size: 16px;
    display: flex; align-items: center; justify-content: center; transition: background 0.2s;
  }
  #btnClose:hover { background: rgba(255,255,255,0.2); }

  .modal-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7); backdrop-filter: blur(10px);
    z-index: 2000; display: none; justify-content: center; align-items: center;
  }
  .modal-content {
    background: #0f172a; border: 1px solid var(--glass-border); padding: 30px;
    border-radius: 24px; max-width: 720px; width: 92%; text-align: left;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    animation: fadeIn 0.3s ease-out; position:relative;
    max-height: 85vh; overflow-y: auto;
  }
  .modal-content h1 { margin-top: 0; color: white; font-size: 22px; margin-bottom: 10px; display:flex; align-items:center; gap:10px; }
  .modal-content p { color: #94a3b8; line-height: 1.6; font-size: 14px; margin-bottom: 20px; }
  .modal-btn {
    background: var(--accent-primary); color: white; border: none;
    padding: 12px 30px; border-radius: 99px; font-weight: 600; cursor: pointer;
    font-size: 14px; transition: transform 0.2s; width: 100%; margin-top: 20px;
  }
  .modal-btn:hover { transform: scale(1.02); }
  @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

  .meth-section { margin-bottom: 18px; border-bottom: 1px solid rgba(255,255,255,0.10); padding-bottom: 14px; }
  .meth-section:last-child { border-bottom: none; }
  .meth-header { font-size: 12px; font-weight: 800; color: var(--accent-primary); text-transform: uppercase; margin-bottom: 8px; display:flex; align-items:center; gap:8px; letter-spacing:0.9px; }
  .meth-text { font-size: 13px; color: #cbd5e1; line-height: 1.65; }

  .calc-step {
    background: rgba(255,255,255,0.03); border-left: 3px solid var(--accent-primary);
    padding: 10px; margin: 10px 0; border-radius: 0 8px 8px 0;
  }
  .calc-label { font-size: 11px; font-weight: 800; color: #94a3b8; text-transform: uppercase; margin-bottom: 4px; display:block; letter-spacing:0.8px; }
  .calc-val { font-family: 'Courier New', monospace; font-size: 13px; color: #e2e8f0; }

  .indiv-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 15px; }
  .indiv-btn {
    background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
    color: #cbd5e1; padding: 8px; border-radius: 8px; font-size: 11px; cursor: pointer;
  }
  .indiv-btn:hover { background: rgba(255,255,255,0.1); }
  .indiv-btn.applied { background: rgba(16, 185, 129, 0.2); border-color: var(--accent-success); color: var(--accent-success); }

  #hoverTooltip {
    position: absolute; pointer-events: none; padding: 8px 12px;
    background: rgba(15, 23, 42, 0.95); color: white; border: 1px solid rgba(255,255,255,0.2);
    border-radius: 8px; font-size: 12px; font-weight: 500;
    transform: translate(15px, 15px); display: none; z-index: 2000;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    white-space: pre-line;
  }

  .hint { font-size: 11px; color: #94a3b8; line-height: 1.45; margin-top: 8px; }
  .tiny-input {
    width: 100%;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.12);
    color: #e2e8f0;
    padding: 8px 10px;
    border-radius: 8px;
    outline: none;
    font-size: 12px;
  }
  .tiny-input:focus{ border-color: rgba(59,130,246,0.6); }

  .check-row {
    display:flex; align-items:center; gap:8px; margin-top: 10px;
    font-size:12px; color:#cbd5e1;
  }


  #chatToggle {
    position: absolute;
    bottom: 25px;
    right: 20px;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: var(--accent-primary);
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
    font-size: 20px;
    cursor: pointer;
    z-index: 2100;
    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    transition: transform 0.2s;
  }
  #chatToggle:hover { transform: scale(1.05); }
  #chatPanel {
    position: absolute;
    bottom: 90px;
    right: 20px;
    width: 320px;
    max-height: 450px;
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    display: none;
    flex-direction: column;
    z-index: 2100;
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
    backdrop-filter: blur(20px);
    overflow: hidden;
  }
  #chatHeader {
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding: 10px 14px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    color: var(--text-main);
    font-size: 13px;
    font-weight: 600;
  }
  #chatHeader button {
    background:none;
    border:none;
    color: var(--text-main);
    font-size: 18px;
    cursor:pointer;
  }
  #chatContent {
    flex:1;
    overflow-y:auto;
    padding: 12px;
    color: var(--text-main);
    font-size: 12px;
  }
  .chat-msg {
    margin-bottom: 10px;
    line-height: 1.4;
  }
  .chat-msg.user {
    text-align:right;
  }
  .chat-msg.user span {
    background: var(--accent-primary);
    color:white;
    padding:6px 10px;
    border-radius: 12px;
    display:inline-block;
  }
  .chat-msg.bot span {
    background: rgba(255,255,255,0.08);
    color: var(--text-main);
    padding:6px 10px;
    border-radius: 12px;
    display:inline-block;
  }
  #chatInput {
    display:flex;
    align-items:center;
    gap:8px;
    border-top: 1px solid rgba(255,255,255,0.1);
    padding: 8px;
  }
  #chatText {
    flex:1;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--text-main);
    padding: 8px;
    border-radius: 8px;
    font-size: 12px;
    outline:none;
  }
  #chatSendBtn {
    background: var(--accent-primary);
    color: white;
    border:none;
    padding:8px 14px;
    border-radius: 8px;
    font-size:12px;
    cursor:pointer;
  }
  #chatSendBtn:hover { filter: brightness(1.1); }
  a.bag-link {
    color: var(--accent-primary);
    cursor: pointer;
    text-decoration: underline;
  }


  /*
   * Collapsed panels: simplify the styling for a cleaner, professional look.  When either the
   * legend (left panel) or sidebar (right panel) is collapsed the contents are hidden and the
   * container shrinks to a narrow strip.  We remove the rotated text entirely and rely solely
   * on the toggle arrow to indicate the panel can be expanded.  Increasing the width slightly
   * (45px) improves readability without taking up too much screen space.
   */
  #leftLegend.collapsed {
    width: 45px;
    padding: 8px;
    overflow: hidden;
  }
  #leftLegend.collapsed .leg-body,
  #leftLegend.collapsed .leg-sub,
  #leftLegend.collapsed .layer-info,
  #leftLegend.collapsed .leg-title {
    display: none !important;
  }
  #leftLegend .toggle {
    cursor: pointer;
    user-select: none;
    font-size: 16px;
    margin-left: 4px;
    padding: 2px 4px;
    border-radius: 4px;
    color: var(--accent-primary);
    background: rgba(59, 130, 246, 0.15);
  }

  #rightPanel.collapsed {
    width: 45px;
    padding-top: 30px;
    position: absolute;
  }
  #rightPanel.collapsed .section-group,
  #rightPanel.collapsed h3,
  #rightPanel.collapsed h4,
  #rightPanel.collapsed .hint,
  #rightPanel.collapsed #lod2LegendNumbers {
    display: none !important;
  }
  /* In collapsed mode the first heading should also disappear */
  #rightPanel.collapsed h3:first-of-type {
    display: none !important;
  }
  #rightPanel .toggle {
    cursor: pointer;
    user-select: none;
    font-size: 14px;
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 1;
    color: var(--accent-primary);
  }

  /* Improve collapsed behaviour: hide text completely instead of rotating
     and adjust panel widths for a cleaner collapsed state.  Keep the width
     consistent with the primary collapsed definition above (45px). */
  #leftLegend.collapsed {
    width: 45px;
  }
  #leftLegend.collapsed .leg-title {
    display: none !important;
  }

  #rightPanel.collapsed {
    width: 45px;
  }
  #rightPanel.collapsed h3,
  #rightPanel.collapsed h4 {
    display: none !important;
  }
  #rightPanel.collapsed h3:first-of-type {
    display: none !important;
  }
  /* Hide section labels and the energy segment chart when the sidebar is collapsed to prevent misaligned content.
     Without these rules the "Energy segment overview" title and chart remain visible in collapsed mode and
     overlap other elements.  Hiding them ensures a clean, narrow strip containing only the toggle arrow. */
  #rightPanel.collapsed .section-label,
  #rightPanel.collapsed #energySegChartContainer {
    display: none !important;
  }
</style>
</head>

<body>
<div id="cesiumContainer"></div>

<div id="overviewModal" class="modal-overlay" style="display:flex;">
  <div class="modal-content" style="text-align:center; max-width:560px;">
    <div style="width:50px; height:50px; background:var(--accent-primary); border-radius:50%; margin:0 auto 15px; display:flex; align-items:center; justify-content:center; font-size:24px;">‚ö°</div>
                     <h1>Twekkelerveld Smart Energy Twin</h1>
    <p>
      The Twekkelerveld district comprises approximately <b>1‚ÄØ465 residential buildings</b>. For most properties a
      <b>certified energy label (A‚ÄìG)</b> has been issued; for the remainder, proxy estimates are derived from
      construction year and typology. In this scale, a label of <b>A</b> denotes a highly efficient building whereas a
      <b>G</b> signifies poor performance. 3D models use realistic roof and fa√ßade colours to evoke the Dutch
      architectural context.<br><br>
      <b>Level of Detail&nbsp;1 ‚Äì Neighbourhood Energy Map</b><br>
      This mode visualises aggregated indicators across the neighbourhood: <em>energy use intensity</em> (kWh per m¬≤),
      <em>solar electricity potential</em>, <em>annual carbon emissions</em> and a discrete <em>energy label</em> map. Colours
      dynamically adjust to the selected indicator and scenario to aid intuitive comparison.<br><br>
      <b>Level of Detail&nbsp;2.2 ‚Äì Building Prototype View</b><br>
      Selecting a building in 3D reveals detailed annual energy estimates, roof irradiation and shading conditions and
      ‚Äúwhat‚Äëif‚Äù simulations. You can explore the impact of upgrades such as insulation, heat pumps and additional
      solar panels at the individual building level, supported by certified label information where available.
    </p>
    <button class="modal-btn" onclick="document.getElementById('overviewModal').style.display='none'">Start Exploring</button>
  </div>
</div>

<!-- ENERGY OVERVIEW -->
<div id="methodologyModal" class="modal-overlay" onclick="if(event.target===this) this.style.display='none'">
  <div class="modal-content">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:18px;">
      <h1><span style="color:var(--accent-warning)">üìä</span> Energy Overview</h1>
      <button onclick="document.getElementById('methodologyModal').style.display='none'"
        style="background:none; border:none; color:white; font-size:24px; cursor:pointer;">√ó</button>
    </div>

    <div class="meth-section">
      <div class="meth-header">How to read colours (LOD 1)</div>
      <div class="meth-text">
        In LOD 1, each building is coloured by the <b>selected layer</b>. The legend (left) shows the <b>minimum and maximum</b> values in the neighbourhood for the active layer and scenario.
        <div class="calc-step">
          <span class="calc-label">Reading the map</span>
          <span class="calc-val">Min ‚Üí one end of the gradient, Max ‚Üí the other end (values in-between follow the gradient)</span>
        </div>
        When you click a building, the legend shows the <b>selected building value</b> for the current layer.
      </div>
    </div>

    <div class="meth-section">
      <div class="meth-header">Energy use per floor area (LOD 1)</div>
      <div class="meth-text">
        This shows yearly energy use per square meter of floor area (how ‚Äúintensive‚Äù the building is).
        <div class="calc-step">
          <span class="calc-label">Unit</span>
          <span class="calc-val">kilowatt-hours per square meter per year (kWh per m¬≤ per year)</span>
        </div>
        <div class="calc-step">
          <span class="calc-label">Data-driven baseline</span>
          <span class="calc-val">Baseline EUI uses field: EUI_age_kwh_m2 (age-class adjusted intensity)</span>
        </div>
      </div>
    </div>

    <div class="meth-section">
      <div class="meth-header">Solar electricity potential (LOD 1)</div>
      <div class="meth-text">
        This shows how much electricity a building could generate from solar panels over a year (from the building dataset).
        <div class="calc-step">
          <span class="calc-label">Unit</span>
          <span class="calc-val">kilowatt-hours per year (kWh per year)</span>
        </div>
      </div>
    </div>

    <div class="meth-section">
      <div class="meth-header">Carbon emissions (LOD 1)</div>
      <div class="meth-text">
        This uses baseline CO‚ÇÇ fields when available (data-driven), and uses building-specific implied emission factors when simulating scenarios.
        <div class="calc-step">
          <span class="calc-label">Unit</span>
          <span class="calc-val">kilograms of CO‚ÇÇ per year (kg CO‚ÇÇ per year)</span>
        </div>
      </div>
    </div>

    <div class="meth-section">
      <div class="meth-header">Building energy estimate (LOD 2.2)</div>
      <div class="meth-text">
        In LOD 2.2, selecting a building shows <b>EnergyEst</b> loaded from<b>Twekkelerveld_bag_pand_FIXED.csv</b> (BAG/pand identifier join; spatial fallback if needed).
        <div class="calc-step">
          <span class="calc-label">Unit</span>
          <span class="calc-val">as stored in the CSV (EnergyEst column)</span>
        </div>
      </div>
    </div>

    <div class="meth-section">
      <div class="meth-header">Roof sunlight and shade (LOD 2.2)</div>
      <div class="meth-text">
        Roof sunlight and shade are sampled from <b>georeferenced PNG rasters</b> (PNG + PGW world file).  Each pixel
        in these rasters stores a value between <b>0</b> (dark) and <b>255</b> (bright).  To compute real
        sunlight values in physical units, we linearly scale the pixel between a
        predefined minimum and maximum sunlight: when the pixel is <code>0</code> you get the minimum, when it is
        <code>255</code> you get the maximum, and intermediate values fall proportionally in-between (for example,
        a pixel value of <b>128</b> will be roughly halfway between the minimum and maximum).  Shade values are
        interpreted similarly: dividing the pixel by 255 yields a fraction from 0&nbsp;(<i>no shade</i>) to
        1&nbsp;(<i>fully shaded</i>).  If a raster stores shade as the opposite of sunlight, this fraction is
        inverted by subtracting it from 1.
        <div class="calc-step">
          <span class="calc-label">Sunlight scaling example</span>
          <span class="calc-val">Sunlight&nbsp;(kWh/m¬≤) ‚âà Min&nbsp;+&nbsp;(Max&nbsp;‚àí&nbsp;Min) √ó (pixel&nbsp;/&nbsp;255)</span>
        </div>
        <div class="calc-step">
          <span class="calc-label">Shade fraction example</span>
          <span class="calc-val">Shade&nbsp;‚âà&nbsp;pixel&nbsp;/&nbsp;255 (or 1&nbsp;‚àí&nbsp;pixel&nbsp;/&nbsp;255 if inverted)</span>
        </div>
      </div>
    </div>

    <div class="meth-section">
      <div class="meth-header">Solar output what-if (LOD 2.2)</div>
      <div class="meth-text">
        Solar output is computed from roof sunlight, building footprint area, and user settings.
        <div class="calc-step">
          <span class="calc-label">Solar output</span>
          <span class="calc-val">Solar (kWh/yr) = Sunlight √ó Area √ó Coverage √ó Efficiency √ó ShadeFactor</span>
        </div>
        <div class="calc-step">
          <span class="calc-label">ShadeFactor</span>
          <span class="calc-val">ShadeFactor = 1 ‚àí Shade √ó (1 ‚àí Mitigation)</span>
        </div>
      </div>
    </div>

    <button class="modal-btn" onclick="document.getElementById('methodologyModal').style.display='none'">Close</button>
  </div>
</div>

<!-- Reusable info modal -->
<div id="dynamicHelpModal" class="modal-overlay" onclick="this.style.display='none'">
  <div class="modal-content" onclick="event.stopPropagation()" style="max-width:720px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <h1 style="margin:0; font-size:18px;">Layer Info</h1>
      <button onclick="document.getElementById('dynamicHelpModal').style.display='none'"
        style="background:none; border:none; color:white; font-size:20px; cursor:pointer;">√ó</button>
    </div>
    <p style="font-size:12px; color:#94a3b8; margin-bottom:15px;" id="logicSub"></p>
    <div id="dynamicHelpContent"></div>
  </div>
</div>

<div id="titleBar" onclick="document.getElementById('overviewModal').style.display='flex'">
  Twekkelerveld Smart Energy Twin
  <!-- Added reset view button to recenter the map when users get lost -->
  <button id="resetViewBtn" title="Reset view to study area"
          onclick="event.stopPropagation(); resetCameraView();">‚Ü∫</button>
</div>
<div id="methodBtn" onclick="document.getElementById('methodologyModal').style.display='flex'">Energy Overview</div>
<div id="hoverTooltip"></div>

<div id="searchBar">
  <input id="searchInput" type="text" placeholder="Search BAG ID or Year..." />
  <button id="searchBtn" onclick="searchLocation()">Search</button>
</div>

<!-- LEFT LEGEND -->
<div id="leftLegend">
  <div class="leg-head">
    <div>
      <div class="leg-title" id="legTitle">Legend</div>
      <div class="leg-sub" id="legSub">Select a layer to see the colour meaning.</div>
    </div>
    <div class="layer-info" onclick="openLegendHelp(event)" title="What does this legend mean?">i</div>
    <!-- Toggle to collapse/expand legend -->
    <div id="legToggle" class="toggle" title="Collapse legend">¬´</div>
  </div>
  <div class="leg-body">
    <div id="legGradient" class="leg-gradient" style="background:linear-gradient(90deg, #10b981, #ef4444);"></div>
    <div class="leg-row">
      <span id="legMinLabel">Low</span>
      <span id="legMaxLabel">High</span>
    </div>
    <div class="leg-note" id="legNote">
      Colours represent the current layer values across the neighbourhood.
    </div>

    <div class="leg-selected">
      <span>Selected:</span>
      <b id="legSelectedVal">‚Äî</b>
    </div>
  </div>
</div>

<div id="hudStats">
  <div class="hud-item">
    <span class="hud-label">Used (Month)</span>
    <span class="hud-val" id="aggEUI">0</span> <span class="hud-unit">MWh</span>
  </div>
  <div style="width:1px; height:30px; background:rgba(255,255,255,0.1);"></div>
  <div class="hud-item">
    <span class="hud-label">Solar (Month)</span>
    <span class="hud-val" id="aggPV" style="color:var(--accent-success)">0</span> <span class="hud-unit">MWh</span>
  </div>
  <div style="width:1px; height:30px; background:rgba(255,255,255,0.1);"></div>
  <div class="hud-item">
    <span class="hud-label">Grid (Net)</span>
    <span class="hud-val" id="aggNet">0</span> <span class="hud-unit">MWh</span>
  </div>

  <div class="info-icon" onclick="openDynamicHelp()" title="Calculation notes">i</div>
</div>

<div id="rightPanel">
  <!-- Toggle to collapse/expand the sidebar -->
  <div id="rightToggle" class="toggle" title="Collapse sidebar">¬ª</div>
  <h3>Visual Mode</h3>
  <!-- Energy label meta: shows coverage and refresh time -->
  <div id="labelMeta" style="font-size:11px; color: var(--text-muted); margin-bottom: 10px; line-height:1.4;"
       title="Labels missing for some buildings ‚Üí shown as no‚Äëdata">
    Energy label coverage: <span id="labelCoverageTxt">0 / 0</span><br>
    Last refreshed: <span id="labelRefreshedTxt">‚Äî</span>
  </div>
  <div class="section-group">
    <button id="viewData" class="mode-btn active" onclick="toggleView('data')">
      <span>Neighbourhood Energy Map (LOD 1)</span>
      <div class="indicator-icon" style="background:white;"></div>
    </button>
    <button id="viewReal" class="mode-btn" onclick="toggleView('real')">
      <span>Building Prototype View (LOD 2.2)</span>
      <div class="indicator-icon" style="background:linear-gradient(45deg, #4ade80, #3b82f6);"></div>
    </button>
  </div>

  <!-- LOD 1 ONLY -->
  <div id="lod1ControlsWrap">
    <h3>Neighbourhood Layers (LOD 1)</h3>
    <div class="section-group">
      <button id="btnEUI" class="mode-btn active" onclick="setIndicator('EUI')">
        <span>Energy use per m¬≤</span>
        <div class="layer-right">
          <div class="indicator-icon" style="background:#fb923c; box-shadow:0 0 10px #fb923c;"></div>
          <div class="layer-info" onclick="openLayerInfo(event,'lod1_eui')" title="What is this?">i</div>
        </div>
      </button>
      <button id="btnPV" class="mode-btn" onclick="setIndicator('PV')">
        <span>Solar electricity potential</span>
        <div class="layer-right">
          <div class="indicator-icon" style="background:#4ade80; box-shadow:0 0 10px #4ade80;"></div>
          <div class="layer-info" onclick="openLayerInfo(event,'lod1_pv')" title="What is this?">i</div>
        </div>
      </button>
      <button id="btnCO2" class="mode-btn" onclick="setIndicator('CO2')">
        <span>Carbon emissions</span>
        <div class="layer-right">
          <div class="indicator-icon" style="background:#f87171; box-shadow:0 0 10px #f87171;"></div>
          <div class="layer-info" onclick="openLayerInfo(event,'lod1_co2')" title="What is this?">i</div>
        </div>
      </button>

      <!-- Layer: Certified energy label (A‚ÄìG).  This button activates a discrete
           colour scheme based on the certified energy label of each building.  If
           no certified label is available the building falls back to a neutral
           colour.  Clicking the info icon opens an explanation of the energy
           label integration and matching rules. -->
      <button id="btnLabel" class="mode-btn" onclick="setIndicator('Label')">
        <span>Certified energy label (A‚ÄìG)</span>
        <div class="layer-right">
          <div class="indicator-icon"
               style="background:linear-gradient(90deg, #1a9850, #66bd63, #a6d96a, #d9ef8b, #fee08b, #fdae61, #f46d43); box-shadow:0 0 10px #f46d43;"></div>
          <div class="layer-info" onclick="openLayerInfo(event,'lod1_label')" title="What is this?">i</div>
        </div>
      </button>
      <!-- Certified filter: show only buildings with an official energy label -->
      <label class="check-row" style="margin-top:8px;">
        <input type="checkbox" id="showCertified" onchange="toggleCertifiedOnly(this.checked)">
        Show certified only
      </label>
    </div>

    <h3>Scenarios (LOD 1)</h3>
    <span class="section-label">1. Current Status</span>
    <div class="section-group">
      <button id="scenBase" class="mode-btn active" onclick="setScenario('baseline')">
        <span>Current (Baseline)</span>
        <div class="layer-right"><div class="layer-info" onclick="openLayerInfo(event,'scen_baseline')">i</div></div>
      </button>
    </div>

    <span class="section-label">2. Future Simulations</span>
    <div class="section-group">
      <button id="scenPV" class="mode-btn" onclick="setScenario('addPV')">
        <span>More solar panels (+50%)</span>
        <div class="layer-right"><div class="layer-info" onclick="openLayerInfo(event,'scen_addpv')">i</div></div>
      </button>
      <button id="scenIns" class="mode-btn" onclick="setScenario('insulate')">
        <span>Better insulation</span>
        <div class="layer-right"><div class="layer-info" onclick="openLayerInfo(event,'scen_insulate')">i</div></div>
      </button>
      <button id="scenHP" class="mode-btn" onclick="setScenario('heatPump')">
        <span>Heat pump transition</span>
        <div class="layer-right"><div class="layer-info" onclick="openLayerInfo(event,'scen_hp')">i</div></div>
      </button>
      <button id="scenP2P" class="mode-btn" onclick="setScenario('p2p')">
        <span>Local energy sharing</span>
        <div class="layer-right">
          <div class="indicator-icon" style="background:linear-gradient(90deg, #f87171, #60a5fa)"></div>
          <div class="layer-info" onclick="openLayerInfo(event,'scen_p2p')">i</div>
        </div>
      </button>
    </div>

    <!-- 3. Energy segment overview: summarises how many buildings fall into the low, medium and high energy
         consumption clusters.  This replaces the targeted policy section and provides a simple
         bar chart that reflects the consumption profiles of the district.  The chart is populated
         dynamically after the entities are loaded and clustered. -->
    <span class="section-label">3. Energy segment overview</span>
    <div id="energySegChartContainer" class="section-group">
      <h4 style="margin:0 0 8px 0; font-size:13px; font-weight:600; color:var(--text-main);">Energy consumption segments</h4>
      <canvas id="energySegChart" height="140"></canvas>
    </div>

  </div>

  <!-- LOD 2.2 -->
  <!-- Wrap all prototype/LOD2-specific controls inside a container so we can toggle visibility -->
  <div id="lod2ControlsWrap" style="display:none;">
  <h3>Prototype Layers (LOD 2.2)</h3>
  <div class="section-group">
    <button id="lod2L_buildings" class="mode-btn active" onclick="toggleLod2Layer('buildings')">
      <span>3D buildings</span>
      <div class="layer-right">
        <div class="indicator-icon" style="background:#e2e8f0;"></div>
        <div class="layer-info" onclick="openLayerInfo(event,'lod2_buildings')" title="What is this?">i</div>
      </div>
    </button>

    <button id="lod2L_energy" class="mode-btn active" onclick="toggleLod2Layer('energy')">
      <span>Building energy estimate</span>
      <div class="layer-right">
        <div class="indicator-icon" style="background:#60a5fa; box-shadow:0 0 10px #60a5fa;"></div>
        <div class="layer-info" onclick="openLayerInfo(event,'lod2_energy')" title="What is this?">i</div>
      </div>
    </button>

    <button id="lod2L_irr" class="mode-btn" onclick="toggleLod2Layer('irr')">
      <span>Solar raster (ground plane)</span>
      <div class="layer-right">
        <div class="indicator-icon" style="background:#22c55e; box-shadow:0 0 10px #22c55e;"></div>
        <div class="layer-info" onclick="openLayerInfo(event,'lod2_irr')" title="What is this?">i</div>
      </div>
    </button>

    <button id="lod2L_shadow" class="mode-btn" onclick="toggleLod2Layer('shadow')">
      <span>Shade raster (ground plane)</span>
      <div class="layer-right">
        <div class="indicator-icon" style="background:#a855f7; box-shadow:0 0 10px #a855f7;"></div>
        <div class="layer-info" onclick="openLayerInfo(event,'lod2_shadow')" title="What is this?">i</div>
      </div>
    </button>

    <div class="hint" style="margin-top:10px;">
      <b>Selection logic:</b><br>
      ‚Ä¢ Click roof ‚Üí building card values (energy estimate + roof conditions)<br>
      ‚Ä¢ Click ground ‚Üí sample sunlight and shade rasters at that location
    </div>

    <div class="hint" id="lod2LegendNumbers" style="margin-top:8px; color:#cbd5e1;">
      Classification bands are computed from the energy estimate distribution.
    </div>
    </div>

  <!-- Sunlight scaling controls removed based on stakeholder feedback. The irradiance values are now interpreted internally with default scaling. -->

  <h4>Solar what-if controls</h4>
  <div class="section-group">
    <div class="flex-between"><span>Energy savings from insulation</span>
      <span id="retroVal" style="color:var(--accent-primary);font-weight:700;">0%</span>
    </div>
    <input id="retroSlider" type="range" min="0" max="35" value="0"
      oninput="prototypeRetrofit=this.value/100; document.getElementById('retroVal').innerText=this.value+'%'; refreshPrototypePanel();" />

    <div style="height:10px"></div>

    <div class="flex-between"><span>Roof covered by panels</span>
      <span id="pvAdoptVal" style="color:var(--accent-primary);font-weight:700;">50%</span>
    </div>
    <input id="pvAdoptSlider" type="range" min="0" max="100" value="50"
      oninput="prototypePVCoverage=this.value/100; document.getElementById('pvAdoptVal').innerText=this.value+'%'; refreshPrototypePanel();" />

    <div style="height:10px"></div>

    <div class="flex-between"><span>Solar panel efficiency</span>
      <span id="pvEffVal" style="color:var(--accent-primary);font-weight:700;">16%</span>
    </div>
    <input id="pvEffSlider" type="range" min="10" max="22" value="16"
      oninput="prototypePVEff = this.value/100; document.getElementById('pvEffVal').innerText=this.value+'%'; refreshPrototypePanel();" />

    <div style="height:10px"></div>

    <div class="flex-between"><span>Shade reduction</span>
      <span id="shadowMitVal" style="color:var(--accent-primary);font-weight:700;">0%</span>
    </div>
    <input id="shadowMitSlider" type="range" min="0" max="100" value="0"
      oninput="prototypeShadowMitigation=this.value/100; document.getElementById('shadowMitVal').innerText=this.value+'%'; applyPrototypeShadowVis(); refreshPrototypePanel();" />

    <label class="check-row">
      <input type="checkbox" id="applyShadowToPV" checked onchange="prototypeApplyShadowToPV=this.checked; refreshPrototypePanel();" />
      Apply shade effect to solar output
    </label>

    <div class="hint">
      Solar output uses roof sunlight and roof area. Open the (i) buttons to see formulas and unit definitions.
    </div>
    </div>

  <!-- Seasonal context removed: hide chart and month slider -->
  <h4 style="display:none;">Seasonal Context <span class="layer-info" title="This chart shows how monthly solar potential and energy use vary over the year. Use the slider below to select a month.">i</span></h4>
  <div id="contextGraph" style="display:none;"><canvas id="seasonCanvas"></canvas></div>

  <div style="margin-bottom:20px; display:none;">
    <div class="flex-between"><span>Month</span> <span id="monthName" style="color:var(--accent-primary)">June 2024</span></div>
    <input id="monthSlider" type="range" min="0" max="11" step="1" value="5" oninput="setMonth(this.value)" />
  </div>

  <!-- End of prototype/LOD2 controls wrapper -->
  </div>

  <!-- Removed filter UI: hide threshold slider and legend -->
  <h4 style="display:none;">Filter</h4>
  <div class="flex-between" style="margin-bottom:5px; display:none;">
    <span>Hide small values</span> <span id="threshVal" style="color:var(--accent-primary); font-weight:700;">0</span>
  </div>
  <input type="range" min="0" max="100" value="0" style="width:100%; display:none;" oninput="updateVis()" id="slider">
  <div id="legendGradient" style="display:none;"></div>
  <div class="flex-between" style="display:none;">
    <span id="legendMin">Low</span> <span id="legendMax">High</span>
  </div>
</div>

<div id="infoPanel">
  <div style="display:flex; justify-content:space-between; align-items:start;">
    <div>
      <h2 id="infoId">ID: -</h2>
      <span id="infoAddr" class="sub">Select a building</span>
    </div>
    <button id="btnClose" onclick="closeInfo()">√ó</button>
  </div>

  <div class="indiv-actions" id="indivActions">
    <button id="btnIndivPV" class="indiv-btn" onclick="toggleIndividualUpgrade('PV')">+ Add solar panels</button>
    <button id="btnIndivRetro" class="indiv-btn" onclick="toggleIndividualUpgrade('Retrofit')">+ Add insulation</button>
  </div>

  <div id="dynamicStats"></div>

  <div id="tradeoffBox" style="display:none;">
    <div class="trade-title">Financial overview</div>
    <div class="trade-row"><span>Capex (upfront)</span> <span id="tradeCost" class="trade-bad">-</span></div>
    <div class="trade-row"><span>Opex baseline (annual)</span> <span id="tradeOpexBase" class="trade-bad">-</span></div>
    <div class="trade-row"><span>Opex new (annual)</span> <span id="tradeOpexNew" class="trade-good">-</span></div>
    <div class="trade-row"><span>Annual savings</span> <span id="tradeSave" class="trade-good">-</span></div>
    <div class="trade-row"><span>Break-even time</span> <span id="tradePay" style="color:white; font-weight:600;">-</span></div>
    <div id="tradeNote" style="margin-top:8px; font-size:11px; color:#93c5fd; font-style:italic; border-top:1px solid rgba(255,255,255,0.1); padding-top:6px;"></div>
  </div>

  <div id="chartContainer">
    <canvas id="buildingChart"></canvas>
  </div>

  <div id="downloadRow">
    <button id="btnDownloadPdf" class="action-btn" onclick="generatePDF()">üìÑ Download PDF Report</button>
  </div>
</div>

<!-- AI Chat Toggle and Panel -->
<div id="chatToggle" title="Ask the AI Assistant">ü§ñ</div>
<div id="chatPanel">
  <div id="chatHeader">
    <span>AI Assistant (suggestions only)</span>
    <button onclick="toggleChat(false)">√ó</button>
  </div>
  <div id="chatContent"></div>
  <!-- Disclaimer clarifying that the assistant provides suggestions only and does not make decisions -->
  <div id="chatDisclaimer" style="font-size:10px; color: var(--text-muted); margin: 4px 8px;">
    Note: this assistant provides suggestions only. Final decisions should be made by you.
  </div>
  <div id="chatInput">
    <input id="chatText" type="text" placeholder="Ask a question..." />
    <button id="chatSendBtn">Send</button>
  </div>
</div>

<script>
/* ------------------------------------------------------------
  Run via local server (Live Server).
------------------------------------------------------------ */

// =============================
// 0) FILES 
// =============================
// Updated shadow raster filenames to use the new dataset. Changing these names ensures
// the application loads the updated ground‚Äëplane shadow raster when toggled.
const LOCAL_SHADOW_PNG = "Aggregated Shadow Raster_updated.png";
const LOCAL_SHADOW_PGW = "Aggregated Shadow Raster_updated.pgw";

const LOCAL_IRR_PNG    = "Roof Irradiance Raster(kWh).png";
const LOCAL_IRR_PGW    = "Roof Irradiance Raster(kWh).pgw";


const IRR_SCALE_JSON   = null;

// ‚úÖ EnergyEst MUST be loaded from your BAG-PAND fixed table (EnergyEst column)
const CSV_CANDIDATES = [
  "Twekkelerveld_bag_pand_FIXED.csv",
  "twekkelerveld_bag_pand_FIXED.csv",
  "Twekkelerveld_bag_pand_Fixed.csv"
];
let CSV_FILE_ACTUAL = null;

// LOD 1 footprint file
const GEOJSON_FILE = "twekkelerveld_buildings_energy_ageEUI_wgs84_201225.geojson";

// =============================
// 1) CONFIG
// =============================
const PARAMS = {
  // Fallback only; scenarios use building-specific implied factors when possible.
  co2: { elec: 0.268, gas: 2.134 },
  prices: { elecImport: 0.30, gas: 1.45, feedIn: 0.05, p2p: 0.15 },
  costs: { pvPerWp: 1.13, hybridPump: 6000, allElectric: 14000, insulationSqM: 50 }
};

const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const solarCurve = [0.02, 0.05, 0.09, 0.13, 0.15, 0.16, 0.15, 0.13, 0.08, 0.04, 0.02, 0.01];
const heatCurve  = [0.18, 0.16, 0.13, 0.07, 0.03, 0.01, 0.00, 0.01, 0.02, 0.07, 0.12, 0.17];

const bounds = {
  EUI:{min:Infinity,max:-Infinity},
  PV:{min:Infinity,max:-Infinity},
  CO2:{min:Infinity,max:-Infinity}
};

// =============================
// 2) CESIUM SETUP
// =============================
Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1NmE1ZGMwYy0xNTQxLTRmMzgtYWM3NS0wYWUzMjk3MjNmYTAiLCJpZCI6MzYwODkxLCJpYXQiOjE3NjM0ODU3MTF9.D_qofjwKf6t1mnUO06Hkz-t7xr2UrPHklhG3a5Lfz8E";

const viewer = new Cesium.Viewer("cesiumContainer", {
  terrain: Cesium.Terrain.fromWorldTerrain(),
  animation: false, timeline: false, baseLayerPicker: false,
  selectionIndicator: true, infoBox: false, navigationHelpButton: false,
  sceneModePicker: false, homeButton: false,
  shadows: true,
  contextOptions: { webgl: { alpha: true, antialias: true, preserveDrawingBuffer: true } }
});
viewer.scene.requestRenderMode = true;
viewer.scene.maximumRenderTimeChange = Infinity;
viewer.scene.globe.enableLighting = true;
viewer.scene.light.intensity = 2.0;

viewer.camera.setView({
  // Set a lower altitude and steeper downward pitch so that the scene starts directly on
  // the neighbourhood.  A pitch of -1.2 (‚âà‚Äë69¬∞) provides a more top‚Äëdown view.
  destination: Cesium.Cartesian3.fromDegrees(6.89366, 52.22632, 1000),
  orientation: {
    heading: 0.0,
    pitch: -1.2,
    roll: 0.0
  }
});

// Reset camera to the initial study area view when the reset button is clicked.
function resetCameraView(){
  // Fly the camera back to the original neighbourhood location.  Use a brief duration
  // for a smooth transition rather than an instant jump.
  // Fly the camera back to the study area.  When entity data has loaded, reuse the
  // bounding extent of those entities for a more accurate reset.  Otherwise fall back
  // to the original coordinates.
  if (Array.isArray(myEntities) && myEntities.length > 0) {
    viewer.flyTo(myEntities, {
      duration: 1.5,
      offset: new Cesium.HeadingPitchRange(0, -1.2, 1000)
    });
  } else {
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(6.89366, 52.22632, 1000),
      orientation: {
        heading: 0.0,
        pitch: -1.2,
        roll: 0.0
      },
      duration: 1.5
    });
  }
}

const BASE_SHADOW_DARKNESS = 0.3;
viewer.shadowMap.darkness = BASE_SHADOW_DARKNESS;

// =============================
// 3) GLOBAL STATE
// =============================
let myEntities = [];
let entByBagId = new Map();


let chatSuggestionsShown = false;
let energyEstMap = new Map();

// Discrete colour scheme for certified energy labels A through G.  These
// colours are inspired by EU energy certificates: green hues for A/B,
// yellow/orange for C/D/E and red/orange for F/G.  The legend and
// updateVis() reference this map.  Unknown or proxy labels fall back to
// a neutral grey colour.
const LABEL_COLOR_MAP = {
  A: '#1a9850', // deep green
  B: '#66bd63', // medium green
  C: '#a6d96a', // light green
  D: '#d9ef8b', // yellowish
  E: '#fee08b', // light orange
  F: '#fdae61', // orange
  G: '#f46d43'  // red
};

// ------------------------------------------------------------
// Energy label integration (ground truth layer)
//
// These variables and functions load an optional energy label
// dataset (CSV or JSON) from the same folder as the HTML.  A
// record maps a BAG Pand ID to a letter (A‚ÄìG).  Buildings are
// assigned a LabelLetter and LabelGroup (AB, CD or EG) and
// annotated with a provenance source (Certified vs Proxy).  The
// label coverage and last refresh date are displayed in the UI.
// A checkbox in the sidebar allows filtering to certified
// buildings only.  If no file exists the loader silently
// resolves without throwing.

//
// Candidate sources for energy label data.  To support the different
// naming conventions seen in my dataset, I try multiple files and
// formats.  The loader will iterate through this list and parse the
// first file that successfully loads.  Supported types include
// JSON, CSV and XLSX spreadsheets.  If no candidate is found the
// label integration will simply fall back to proxy values.  One can
// add or remove entries here if one's file names change.  Each
// candidate defines both a URL (relative to this HTML file) and the
// expected type.
const LABEL_SOURCES = [
  { url: "energy_labels_meta.json",       type: "json" },
  { url: "energy_labels_meta",            type: "json" },
  { url: "energy_labels_twekkelerveld.csv", type: "csv" },
  { url: "energy_labels_twekkelerveld.xlsx", type: "xlsx" },
  { url: "energy_labels_twekkelerveld",    type: "csv" }
];
let labelMap = new Map();
let labelCoverageCount = 0;
let labelTotalCount = 0;
let labelLastRefreshed = null;
let showCertifiedOnly = false;

async function loadEnergyLabels(){
  // Reset any existing state before loading.  This ensures that repeated
  // calls do not append duplicate values or stale metadata.
  labelMap.clear();
  labelLastRefreshed = null;
  labelCoverageCount = 0;
  labelTotalCount = 0;

  try {
    let loaded = false;
    // First attempt to load actual label data from spreadsheets or CSV.  Skip
    // meta files here; they will be loaded separately after data is parsed.  The
    // candidate list may include multiple formats (csv, xlsx) so iterate until
    // one succeeds.
    for (const cand of LABEL_SOURCES) {
      // Skip meta candidates during data pass
      if (/meta/i.test(cand.url)) continue;
      try {
        const res = await fetch(encodeURI(cand.url), { cache: "no-store" });
        if (!res.ok) continue;
        const ext = (cand.url.split('.').pop() || cand.type || '').toLowerCase();
        const type = cand.type || (ext === 'json' ? 'json' : (ext === 'csv' ? 'csv' : ((ext === 'xlsx' || ext === 'xls') ? 'xlsx' : 'text')));
        // Parse JSON arrays containing id + label pairs
        if (type === 'json') {
          const text = await res.text();
          let obj;
          try { obj = JSON.parse(text); } catch (err) { obj = null; }
          if (obj) {
            if (Array.isArray(obj)) {
              obj.forEach(rec => {
                const id = normalizeBagId(rec.id || rec.bag_id || rec.BAGID || rec.BAG || rec.PandID || rec.identificatie);
                const letterRaw = rec.label || rec.Label || rec.energy_label || rec.energylabel || rec.class;
                const letter = letterRaw ? String(letterRaw).trim().toUpperCase() : '';
                if (id && letter) { labelMap.set(id, letter); }
              });
            } else if (obj && obj.labels) {
              const arr = obj.labels;
              if (Array.isArray(arr)) {
                arr.forEach(rec => {
                  const id = normalizeBagId(rec.id || rec.bag_id || rec.BAGID || rec.PandID || rec.identificatie);
                  const letterRaw = rec.label || rec.energy_label;
                  const letter = letterRaw ? String(letterRaw).trim().toUpperCase() : '';
                  if (id && letter) { labelMap.set(id, letter); }
                });
              }
            }
            loaded = labelMap.size > 0;
            if (loaded) break;
          }
        } else if (type === 'csv' || type === 'text') {
          const text = await res.text();
          const lines = text.split(/\r?\n/).filter(l => l.trim().length);
          if (lines.length > 1) {
            const delim = detectDelimiter(lines[0]);
            const headers = parseCsvLine(lines[0], delim).map(h => h.trim());
            let idIdx = -1;
            let labelIdx = -1;
            const normHeaders = headers.map(h => normalizeHeader(h));
            for (let i = 0; i < normHeaders.length; i++) {
              const h = normHeaders[i];
              if (['id','bag_id','bagid','pandid','identificatie'].includes(h)) idIdx = i;
              if (['label','energielabel','energylabel','labelletter','class','grade'].includes(h)) labelIdx = i;
            }
            for (let i = 1; i < lines.length; i++) {
              const cols = parseCsvLine(lines[i], delim);
              const id = normalizeBagId(cols[idIdx]);
              const letterRaw = cols[labelIdx];
              const letter = letterRaw ? String(letterRaw).trim().toUpperCase() : '';
              if (id && letter) { labelMap.set(id, letter); }
            }
            loaded = labelMap.size > 0;
            if (loaded) break;
          }
        } else if (type === 'xlsx') {
          const ab = await res.arrayBuffer();
          const wb = XLSX.read(ab, { type: 'array' });
          const sheetName = wb.SheetNames && wb.SheetNames.length ? wb.SheetNames[0] : null;
          if (sheetName) {
            const sheet = wb.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
            if (rows.length > 1) {
              const headers = rows[0].map(h => String(h || '').trim());
              let idIdx = -1;
              let labelIdx = -1;
              const normHeaders = headers.map(h => normalizeHeader(h));
              for (let i = 0; i < normHeaders.length; i++) {
                const h = normHeaders[i];
                if (['id','bag_id','bagid','pandid','identificatie'].includes(h)) idIdx = i;
                if (['label','energielabel','energylabel','labelletter','class','grade'].includes(h)) labelIdx = i;
              }
              for (let i = 1; i < rows.length; i++) {
                const cols = rows[i];
                const id = normalizeBagId(cols[idIdx]);
                const letterRaw = cols[labelIdx];
                const letter = letterRaw ? String(letterRaw).trim().toUpperCase() : '';
                if (id && letter) { labelMap.set(id, letter); }
              }
              loaded = labelMap.size > 0;
              if (loaded) break;
            }
          }
        }
      } catch (err) {
        // swallow errors and continue to next candidate
        continue;
      }
    }
    if (!loaded) {
      console.warn('No energy label data file found (csv/xlsx)');
    }
    // Next attempt to load a meta file for last-refreshed date.  Do not parse
    // labels from meta files.  If multiple meta files exist the first with a
    // valid date will be used.
    for (const cand of LABEL_SOURCES) {
      if (!/meta/i.test(cand.url)) continue;
      try {
        const res = await fetch(encodeURI(cand.url), { cache: "no-store" });
        if (!res.ok) continue;
        const text = await res.text();
        let obj;
        try { obj = JSON.parse(text); } catch (err) { obj = null; }
        if (obj) {
          if (Array.isArray(obj) && obj.length > 0) {
            const first = obj[0];
            const dt = first.last_update || first.lastRefreshed || first.last_refreshed;
            if (dt) { labelLastRefreshed = dt; break; }
          } else {
            const dt = obj.last_update || obj.lastRefreshed || obj.last_refreshed;
            if (dt) { labelLastRefreshed = dt; break; }
          }
        }
      } catch (err) {
        continue;
      }
    }
    // Assign labels to entities and compute how many buildings matched.  The
    // matched count reflects the number of buildings with a certified label in
    // the uploaded dataset, not the number of distinct label rows.  Each
    // building gets a LabelLetter, LabelGroup (AB / CD / EG) and ProvSource
    // annotation.  Buildings without a matching ID are marked as proxies.
    let matchedCount = 0;
    labelTotalCount = myEntities ? myEntities.length : 0;
    if (myEntities) {
      for (const e of myEntities) {
        const b = e._b;
        if (!b) continue;
        const id = normalizeBagId(b.ID);
        const letter = id ? labelMap.get(id) : null;
        if (letter) {
          b.LabelLetter = letter;
          const up = letter.toUpperCase();
          if (['A','B'].includes(up)) b.LabelGroup = 'AB';
          else if (['C','D'].includes(up)) b.LabelGroup = 'CD';
          else b.LabelGroup = 'EG';
          b.ProvSource = 'Certified';
          matchedCount++;
        } else {
          b.LabelGroup = null;
          b.ProvSource = 'Proxy';
        }
      }
    }
    labelCoverageCount = matchedCount;
    // Update coverage and last refresh in the UI.  If no meta date was
    // available, fall back to today‚Äôs date for clarity.
    const covEl = document.getElementById('labelCoverageTxt');
    const refEl = document.getElementById('labelRefreshedTxt');
    if (covEl) covEl.innerText = `${labelCoverageCount.toLocaleString()} / ${labelTotalCount.toLocaleString()}`;
    if (refEl) {
      const ref = labelLastRefreshed || new Date().toISOString().split('T')[0];
      refEl.innerText = ref;
    }
    // Refresh visual state when labels loaded
    updateVis();
  } catch (e) {
    console.error('Energy labels load failed:', e);
  }
}

window.toggleCertifiedOnly = function(state){
  showCertifiedOnly = !!state;
  updateVis();
};

// Update the current month and refresh seasonal context and stats
window.setMonth = function(val){
  currentMonth = Number(val);
  const monthNameEl = document.getElementById('monthName');
  if(monthNameEl){
    // Used 2026 (current year) to avoid confusion; adjust if needed
    monthNameEl.innerText = months[currentMonth] + ' 2026';
  }
  // Move the vertical annotation line on the seasonal chart
  if(seasonChart && seasonChart.options && seasonChart.options.plugins && seasonChart.options.plugins.annotation && seasonChart.options.plugins.annotation.annotations && seasonChart.options.plugins.annotation.annotations.line1){
    const line = seasonChart.options.plugins.annotation.annotations.line1;
    line.xMin = currentMonth;
    line.xMax = currentMonth;
    seasonChart.update();
  }
  updateVis();
  if(selectedEnt) renderInfo(selectedEnt);
};

let activeInd = "EUI";
let activeScen = "baseline";
let currentMonth = 5;
let selectedEnt = null;

let myChart = null;
let seasonChart = null;

// LOD2
let lod2Tileset = null;
let lod2SelectedFeature = null;
let lod2SelectedPrevColor = null;
let lod2TileHooked = false;

// local rasters
let shadowRaster = null;
let irrRaster = null;

// thresholds
let ENERGYEST_P33 = null;
let ENERGYEST_P66 = null;

// LOD 2.2 what-if
let prototypePVCoverage = 0.50;
let prototypeShadowMitigation = 0.0;
let prototypeRetrofit = 0.0;
let prototypePVEff = 0.16;
let prototypeApplyShadowToPV = true;
let prototypeInvertShadow = false;

// Sunlight scaling (kWh per m¬≤ per year)
let IRR_MIN_REAL = 800;
let IRR_MAX_REAL = 1200;

let lastPrototypeCarto = null;
let lastPrototypeNote = "";

// LOD 2.2 layer switches
// For improved visibility of the LOD¬†2.2 buildings we disable the energy‚Äêbased
// colouring by default.  
let L2_SHOW_BUILDINGS = true;
let L2_SHOW_ENERGY_STYLE = false;
let L2_SHOW_IRR_OVERLAY = false;
let L2_SHOW_SHADOW_OVERLAY = false;

// =============================
// 4) UI: per-layer info (plain language)
// =============================
window.openLayerInfo = function(ev, key){
  if(ev) { ev.stopPropagation(); ev.preventDefault(); }
  const elSub = document.getElementById('logicSub');
  const elBody = document.getElementById('dynamicHelpContent');
  const data = LAYER_INFO[key] || { sub:"Layer Info", html:"" };
  elSub.innerText = data.sub || "Layer Info";
  elBody.innerHTML = data.html || "";
  document.getElementById('dynamicHelpModal').style.display = 'flex';
};

window.openLegendHelp = function(ev){
  if(ev) { ev.stopPropagation(); ev.preventDefault(); }
  const inLod2 = document.getElementById('viewReal').classList.contains('active');
  if(inLod2){
    openLayerInfo(null, 'lod2_energy');
  } else {
    if(activeScen === 'p2p') openLayerInfo(null, 'scen_p2p');
    else if(activeInd === 'EUI') openLayerInfo(null, 'lod1_eui');
    else if(activeInd === 'PV') openLayerInfo(null, 'lod1_pv');
    else if(activeInd === 'Label') openLayerInfo(null, 'lod1_label');
    else openLayerInfo(null, 'lod1_co2');
  }
};

const LAYER_INFO = {
  lod1_eui: {
    sub: "LOD 1 ‚Ä¢ Energy use per m¬≤",
    html: `
      <div class="calc-step"><span class="calc-label">Baseline field</span>
        <span class="calc-val">EUI_age_kwh_m2 (your GeoJSON age-class adjusted intensity)</span>
      </div>
      <div class="calc-step"><span class="calc-label">Unit</span>
        <span class="calc-val">kWh per m¬≤ per year</span>
      </div>
      <div class="calc-step"><span class="calc-label">Scenario behaviour</span>
        <span class="calc-val">PV scenario uses EUI_net_pv_50 if available; other scenarios adjust gas/electricity using your building‚Äôs implied factors</span>
      </div>
    `
  },
  lod1_pv: {
    sub: "LOD 1 ‚Ä¢ Solar electricity potential",
    html: `
      <div class="calc-step"><span class="calc-label">Field</span>
        <span class="calc-val">pv_kwh_pot (your GeoJSON)</span>
      </div>
      <div class="calc-step"><span class="calc-label">Unit</span>
        <span class="calc-val">kWh per year</span>
      </div>
    `
  },
  lod1_co2: {
    sub: "LOD 1 ‚Ä¢ Carbon emissions",
    html: `
      <div class="calc-step"><span class="calc-label">Baseline fields</span>
        <span class="calc-val">co2_total_base_kg (preferred) ‚Üí else co2_kg</span>
      </div>
      <div class="calc-step"><span class="calc-label">Implied emission factors (data-driven)</span>
        <span class="calc-val">EF_elec = co2_elec_base_kg / el_kwh, EF_gas = co2_gas_kg / gas_m3 (fallback only if missing)</span>
      </div>
    `
  },

  // Layer information: Certified energy label.  Explains the source of the
  // labels, the categorical nature of the metric and how buildings are
  // classified.  Proxy values are used where no certified label is available.
  lod1_label: {
    sub: "LOD 1 ‚Ä¢ Certified energy label (A‚ÄìG)",
    html: `
      <div class="calc-step"><span class="calc-label">Source</span>
        <span class="calc-val">Uploaded energy label spreadsheet or CSV containing BAG Pand ID (e.g. \`identificatie\`) and label letter</span>
      </div>
      <div class="calc-step"><span class="calc-label">Unit</span>
        <span class="calc-val">Categorical (A‚ÄìG)</span>
      </div>
      <div class="calc-step"><span class="calc-label">Meaning</span>
        <span class="calc-val">A = most energy‚Äëefficient, G = least efficient.  Where no certified label is available a proxy estimate is used based on building age and type.</span>
      </div>
    `
  },
  scen_baseline: {
    sub:"Scenario ‚Ä¢ Current (Baseline)",
    html:`<div class="calc-step"><span class="calc-label">Meaning</span><span class="calc-val">Uses your GeoJSON baseline fields (EUI_age_kwh_m2, pv_kwh_pot, co2_total_base_kg)</span></div>`
  },
  scen_addpv: {
    sub:"Scenario ‚Ä¢ More solar panels (+50%)",
    html:`<div class="calc-step"><span class="calc-label">Meaning</span><span class="calc-val">EUI uses your GeoJSON EUI_net_pv_50 if present; CO‚ÇÇ is reduced using implied electricity factor and PV self-consumption capped by el_kwh</span></div>`
  },
  scen_insulate: {
    sub:"Scenario ‚Ä¢ Better insulation",
    html:`<div class="calc-step"><span class="calc-label">Meaning</span><span class="calc-val">Gas demand is reduced using a data-driven saving rate based on age_mult_norm (older buildings ‚Üí higher savings potential)</span></div>`
  },
  scen_hp: {
    sub:"Scenario ‚Ä¢ Heat pump transition",
    html: `
      <div class="calc-step"><span class="calc-label">Meaning</span>
        <span class="calc-val">Gas heating is converted to electricity with COP derived from age_mult_norm (older buildings ‚Üí lower COP)</span>
      </div>
    `
  },
  scen_p2p: {
    sub:"Scenario ‚Ä¢ Local energy sharing",
    html: `
      <div class="calc-step"><span class="calc-label">Meaning</span>
        <span class="calc-val">Balance = PV generation (scenario) ‚àí monthly consumption. Red=deficit, Blue=surplus</span>
      </div>
    `
  },
  lod2_buildings: { sub:"LOD 2.2 ‚Ä¢ 3D buildings", html:`<div class="calc-step"><span class="calc-label">Meaning</span><span class="calc-val">3D model used for selection and roof interaction</span></div>` },
  lod2_energy: {
    sub:"LOD 2.2 ‚Ä¢ Building energy estimate",
    html: `
      <div class="calc-step"><span class="calc-label">Source</span><span class="calc-val">Twekkelerveld_bag_pand_FIXED.csv ‚Üí EnergyEst</span></div>
      <div class="calc-step"><span class="calc-label">How it connects</span><span class="calc-val">BAG ID match (or spatial match to LOD 1 footprint)</span></div>
      <div class="calc-step"><span class="calc-label">Classes</span><span class="calc-val">LOW / MID / HIGH from neighbourhood percentiles</span></div>
    `
  },
  lod2_irr: {
    sub:"LOD 2.2 ‚Ä¢ Solar raster (ground plane)",
    html: `
      <div class="calc-step"><span class="calc-label">Meaning</span><span class="calc-val">Pixel values represent relative sunlight on the roof surface; higher values indicate more sunlight.</span></div>
      <div class="calc-step"><span class="calc-label">Value range</span><span class="calc-val">0‚Äì255 (higher¬†=¬†more sunlight)</span></div>
    `
  },
  lod2_shadow: {
    sub:"LOD 2.2 ‚Ä¢ Shade raster (ground plane)",
    html: `
      <div class="calc-step"><span class="calc-label">Meaning</span><span class="calc-val">Pixel values represent relative shading on the roof; higher values indicate more shade.</span></div>
      <div class="calc-step"><span class="calc-label">Value range</span><span class="calc-val">0‚Äì255 (higher¬†=¬†more shade)</span></div>
      <div class="calc-step"><span class="calc-label">Solar impact</span><span class="calc-val">Shade reduction controls how shade affects solar output.</span></div>
    `
  }
};

function openDynamicHelp(){
  const inLod2View = document.getElementById('viewReal').classList.contains('active');
  if(inLod2View) openLayerInfo(null, 'lod2_energy');
  else {
    if(activeScen === 'p2p') openLayerInfo(null,'scen_p2p');
    else if(activeInd === 'EUI') openLayerInfo(null, 'lod1_eui');
    else if(activeInd === 'PV') openLayerInfo(null, 'lod1_pv');
    else if(activeInd === 'Label') openLayerInfo(null, 'lod1_label');
    else openLayerInfo(null, 'lod1_co2');
  }
}

// =============================
// 5) HELPERS (robust property reads)
// =============================
function safeNum(x){
  if(x === null || x === undefined) return NaN;
  const s = String(x).trim().replace(",", ".");
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function normalizeBagId(v){
  if(v === null || v === undefined) return "";
  let s = String(v).trim();

  s = s.replace(/^pand\//i,'');
  s = s.replace(/^NL\.IMBAG\.Pand\./i,'');
  s = s.replace(/^NL\.IMBAG\.PAND\./i,'');

  // scientific notation handling
  if(/e\+?/i.test(s)){
    const n = Number(s);
    if(Number.isFinite(n)) s = String(Math.round(n));
  }

  let digits = (s.match(/\d+/g) || []).join('');
  if(!digits) return "";

  if (digits.length > 16) {
    while (digits.length > 16 && digits.endsWith('0')) {
      digits = digits.slice(0, -1);
    }
    if (digits.length > 16) digits = digits.slice(0, 16);
  }
  return (digits.length < 16 && digits.length >= 14) ? digits.padStart(16, '0') : digits;
}

function propVal(props, key){
  if(!props || !key) return undefined;
  const v = props[key];
  if(v === undefined || v === null) return undefined;
  try{
    if(typeof v === "object" && typeof v.getValue === "function") return v.getValue();
    return v;
  }catch(e){
    return undefined;
  }
}
function numProp(props, key){
  const v = propVal(props, key);
  const n = (typeof v === "number") ? v : safeNum(v);
  return Number.isFinite(n) ? n : NaN;
}
function strProp(props, key){
  const v = propVal(props, key);
  if(v === undefined || v === null) return "N/A";
  const s = String(v).trim();
  return s.length ? s : "N/A";
}

// Floor area selector (avoid tiny areas)
function pickFloorAreaM2(p){
  const candidates = [
    "oppervlakte_sum",
    "oppervlakte_max",
    "vbo_\noppervlakte",
    "vbo_oppervlakte",
    "oppervlakte_min"
  ];
  for(const k of candidates){
    const v = numProp(p, k);
    if(Number.isFinite(v) && v > 10) return v;
  }
  return 0;
}

function detectDelimiter(headerLine){
  const candidates = [",",";","\t","|"];
  let best = ",", bestCount = -1;
  for(const d of candidates){
    const c = headerLine.split(d).length;
    if(c > bestCount){ bestCount = c; best = d; }
  }
  return best;
}
function parseCsvLine(line, delim){
  const out = [];
  let cur = "";
  let inQuotes = false;
  for(let i=0;i<line.length;i++){
    const ch = line[i];
    if(ch === '"'){
      if(inQuotes && line[i+1] === '"'){ cur += '"'; i++; }
      else inQuotes = !inQuotes;
    } else if(ch === delim && !inQuotes){
      out.push(cur); cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out;
}
function normalizeHeader(h){
  return String(h || "")
    .toLowerCase()
    .replace(/\uFEFF/g, "")
    .replace(/[\r\n\t]/g, "")
    .replace(/\s+/g, "")
    .replace(/[^a-z0-9_]/g, "");
}

async function fetchFirstAvailableText(urls){
  let lastErr = null;
  for(const u of urls){
    try{
      const res = await fetch(encodeURI(u), { cache: "no-store" });
      if(res.ok){
        return { url: u, text: await res.text() };
      }
      lastErr = new Error(`HTTP ${res.status} for ${u}`);
    }catch(e){
      lastErr = e;
    }
  }
  throw lastErr || new Error("Table not found");
}

function computeQuantile(sortedVals, p){
  if(!sortedVals.length) return null;
  const idx = Math.floor(p * (sortedVals.length - 1));
  return sortedVals[Math.max(0, Math.min(sortedVals.length - 1, idx))];
}

async function loadIrradianceScaleJson(){
  if(!IRR_SCALE_JSON) return;
  try{
    const res = await fetch(encodeURI(IRR_SCALE_JSON), { cache: "no-store" });
    if(!res.ok) return;
    const js = await res.json();
    if(Number.isFinite(js.min)) IRR_MIN_REAL = Number(js.min);
    if(Number.isFinite(js.max)) IRR_MAX_REAL = Number(js.max);
    const minEl = document.getElementById('irrMin');
    const maxEl = document.getElementById('irrMax');
    if(minEl) minEl.value = String(IRR_MIN_REAL);
    if(maxEl) maxEl.value = String(IRR_MAX_REAL);
  }catch(e){}
}


async function loadEnergyEstCSV(){
  try{
    const { url, text } = await fetchFirstAvailableText(CSV_CANDIDATES);
    CSV_FILE_ACTUAL = url;

    const lines = text.split(/\r?\n/).filter(l => l.trim().length);
    if(lines.length < 2) throw new Error("Table has no rows");

    const delim = detectDelimiter(lines[0]);
    const headers = parseCsvLine(lines[0], delim).map(h => h.trim());
    const H = headers.map(normalizeHeader);

    // Prioritize "identificatie" (full NL.IMBAG.Pand...) over scientific notation id columns
    const idCandidates = [
      "identificatie", "bag_id", "bagid", "rdf_seealso", "rdfseealso", "pand_id", "pandid", "gml_id", "feature_id", "id"
    ];
    const estCandidates = [
      "energyest", "energy_est", "energyestimate", "energy_estimation", "energyestimation"
    ];

    let idIdx = -1;
    for(const c of idCandidates){
      const idx = H.indexOf(c);
      if(idx !== -1){ idIdx = idx; break; }
    }
    let eIdx = -1;
    for(const c of estCandidates){
      const idx = H.indexOf(c);
      if(idx !== -1){ eIdx = idx; break; }
    }

    if(idIdx === -1) throw new Error("Missing ID column (expected identificatie / bag_id / rdf_seealso etc.)");
    if(eIdx  === -1) throw new Error("Missing EnergyEst column (expected EnergyEst)");

    energyEstMap.clear();
    const values = [];

    for(let i=1;i<lines.length;i++){
      const cols = parseCsvLine(lines[i], delim);
      const id = normalizeBagId(cols[idIdx]);
      const val = safeNum(cols[eIdx]);
      if(id && Number.isFinite(val)){
        energyEstMap.set(id, val);
        values.push(val);
      }
    }

    values.sort((a,b)=>a-b);
    ENERGYEST_P33 = computeQuantile(values, 0.333);
    ENERGYEST_P66 = computeQuantile(values, 0.666);

    const leg = document.getElementById("lod2LegendNumbers");
    if(leg && ENERGYEST_P33 !== null && ENERGYEST_P66 !== null){
      leg.innerText =
        `Energy estimate bands (EnergyEst): LOW < ${Math.round(ENERGYEST_P33).toLocaleString()} ‚Ä¢ MID ${Math.round(ENERGYEST_P33).toLocaleString()}‚Äì${Math.round(ENERGYEST_P66).toLocaleString()} ‚Ä¢ HIGH > ${Math.round(ENERGYEST_P66).toLocaleString()}`;
    }

    if(myEntities && myEntities.length){
      for(const e of myEntities){
        const b = e._b;
        if(!b) continue;
        if(b.ID){
          const v = energyEstMap.get(normalizeBagId(b.ID));
          if(v !== undefined) b.EnergyEST = v;
        }
      }
    }

    if(lod2Tileset){
      setupLod2EnergyStyling();
      viewer.scene.requestRender();
    }
  }catch(err){
    console.error("EnergyEst load failed:", err);
  }
}

// =============================
// 6) LOCAL RASTER LOADER + SAMPLER
// =============================
async function loadImage(url){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error("Failed to load image: " + url));
    img.src = encodeURI(url);
  });
}
async function loadText(url){
  const res = await fetch(encodeURI(url), { cache:"no-store" });
  if(!res.ok) throw new Error("Failed to load: " + url);
  return await res.text();
}
function parsePGW(txt){
  const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  if(lines.length < 6) throw new Error("PGW invalid (needs 6 lines)");
  const A = Number(lines[0]);
  const D = Number(lines[1]);
  const B = Number(lines[2]);
  const E = Number(lines[3]);
  const C = Number(lines[4]);
  const F = Number(lines[5]);
  if(!Number.isFinite(A)||!Number.isFinite(B)||!Number.isFinite(C)||!Number.isFinite(D)||!Number.isFinite(E)||!Number.isFinite(F)){
    throw new Error("PGW parse failed (non-numeric)");
  }
  return { A,B,C,D,E,F };
}
function looksLikeDegrees(x, y){
  return Math.abs(x) <= 180 && Math.abs(y) <= 90;
}

class RasterSampler {
  constructor(name, pngUrl, pgwUrl){
    this.name = name;
    this.pngUrl = pngUrl;
    this.pgwUrl = pgwUrl;
    this.ready = false;
    this.imgW = 0;
    this.imgH = 0;
    this.data = null;
    this.pgw = null;
    this.coordType = "degrees";
    this.bounds = null;
    this.rectangleDegrees = null;
    this.imageryLayer = null;
  }

  async load(){
    const [img, pgwTxt] = await Promise.all([ loadImage(this.pngUrl), loadText(this.pgwUrl) ]);
    this.pgw = parsePGW(pgwTxt);

    this.imgW = img.width;
    this.imgH = img.height;

    const canvas = document.createElement("canvas");
    canvas.width = this.imgW;
    canvas.height = this.imgH;
    const ctx = canvas.getContext("2d", { willReadFrequently:true });
    ctx.drawImage(img, 0, 0);
    this.data = ctx.getImageData(0,0,this.imgW,this.imgH).data;

    const A = this.pgw.A;
    const E = this.pgw.E;
    const C = this.pgw.C;
    const F = this.pgw.F;

    const left   = C - (A/2);
    const right  = C + A*(this.imgW - 0.5);
    const top    = F + (E/2);
    const bottom = F + E*(this.imgH - 0.5);

    this.bounds = { left, right, top, bottom };

    if(looksLikeDegrees(C, F) && looksLikeDegrees(left, top) && looksLikeDegrees(right, bottom)){
      this.coordType = "degrees";
      const west  = Math.min(left, right);
      const east  = Math.max(left, right);
      const south = Math.min(bottom, top);
      const north = Math.max(bottom, top);
      this.rectangleDegrees = Cesium.Rectangle.fromDegrees(west, south, east, north);
    } else {
      this.coordType = "webmerc";
      const proj = new Cesium.WebMercatorProjection(viewer.scene.globe.ellipsoid);

      const westM  = Math.min(left, right);
      const eastM  = Math.max(left, right);
      const southM = Math.min(bottom, top);
      const northM = Math.max(bottom, top);

      const nw = proj.unproject(new Cesium.Cartesian3(westM,  northM, 0));
      const se = proj.unproject(new Cesium.Cartesian3(eastM,  southM, 0));

      const westDeg  = Cesium.Math.toDegrees(nw.longitude);
      const northDeg = Cesium.Math.toDegrees(nw.latitude);
      const eastDeg  = Cesium.Math.toDegrees(se.longitude);
      const southDeg = Cesium.Math.toDegrees(se.latitude);

      this.rectangleDegrees = Cesium.Rectangle.fromDegrees(
        Math.min(westDeg, eastDeg),
        Math.min(southDeg, northDeg),
        Math.max(westDeg, eastDeg),
        Math.max(southDeg, northDeg)
      );
    }

    const provider = new Cesium.SingleTileImageryProvider({
      url: encodeURI(this.pngUrl),
      rectangle: this.rectangleDegrees
    });
    this.imageryLayer = viewer.imageryLayers.addImageryProvider(provider);
    this.imageryLayer.alpha = 0.65;
    this.imageryLayer.show = false;

    viewer.imageryLayers.raiseToTop(this.imageryLayer);

    this.ready = true;
  }

  sampleFromCartographic(carto){
    if(!this.ready || !carto) return null;

    let x, y;
    if(this.coordType === "degrees"){
      x = Cesium.Math.toDegrees(carto.longitude);
      y = Cesium.Math.toDegrees(carto.latitude);
    } else {
      const proj = new Cesium.WebMercatorProjection(viewer.scene.globe.ellipsoid);
      const p = proj.project(carto);
      x = p.x; y = p.y;
    }

    const { left, right, top, bottom } = this.bounds;
    const minX = Math.min(left, right);
    const maxX = Math.max(left, right);
    const minY = Math.min(bottom, top);
    const maxY = Math.max(bottom, top);

    if(x < minX || x > maxX || y < minY || y > maxY) return null;

    const A = this.pgw.A;
    const E = this.pgw.E;

    const col = Math.floor((x - (left - A/2)) / A);
    const row = Math.floor(((top - (Math.abs(E)/2)) - y) / Math.abs(E));

    if(col < 0 || col >= this.imgW || row < 0 || row >= this.imgH) return null;

    const idx = (row * this.imgW + col) * 4;
    const r = this.data[idx], g = this.data[idx+1], b = this.data[idx+2], a = this.data[idx+3];
    if(a === 0) return null;

    const value = (r === g && g === b) ? r : Math.round(0.2126*r + 0.7152*g + 0.0722*b);
    return { value, row, col };
  }
}

async function loadLocalRasters(){
  try{
    shadowRaster = new RasterSampler("Shade", LOCAL_SHADOW_PNG, LOCAL_SHADOW_PGW);
    irrRaster    = new RasterSampler("Sunlight", LOCAL_IRR_PNG, LOCAL_IRR_PGW);
    await Promise.all([shadowRaster.load(), irrRaster.load()]);
  }catch(err){
    console.error("Raster load failed:", err);
  }
}

// =============================
// 7) LOD2.2 MODEL
// =============================
const LOD2_ASSET_ID = 4261194;

(async function loadLOD22(){
  try {
    lod2Tileset = await Cesium.Cesium3DTileset.fromIonAssetId(LOD2_ASSET_ID, {
      maximumScreenSpaceError: 16,
      dynamicScreenSpaceError: true
    });

    viewer.scene.primitives.add(lod2Tileset);
    lod2Tileset.show = false;

  
    lod2Tileset.style = new Cesium.Cesium3DTileStyle({
  
      color: "rgba(255,255,255,0.95)"
    });

  
    try {
      lod2Tileset.colorBlendMode = Cesium.Cesium3DTileColorBlendMode.MIX;
      lod2Tileset.colorBlendAmount = 0.75;
    } catch(e) {
      
    }

    setupLod2EnergyStyling();
    viewer.scene.requestRender();
  } catch(e) {
    console.error("LOD 2.2 load failed:", e);
  }
})();

function energyClassFromEst(est){

  if(!Number.isFinite(est)) return -1;
  if(ENERGYEST_P33 === null || ENERGYEST_P66 === null){
    if(est < 1000) return 0;
    if(est < 5000) return 1;
    return 2;
  }
  if(est >= ENERGYEST_P66) return 2;
  if(est >= ENERGYEST_P33) return 1;
  return 0;
}

function getBagIdFromLod2Pick(pick){
  if(!pick || !pick.getProperty) return "";
  const keys = ["identificatie","bag_id","BAG_ID","bagId","rdf_seealso","rdfseealso","pand_id","pandId","id","ID","feature_id","gml_id"];
  for(const k of keys){
    const v = pick.getProperty(k);
    const norm = normalizeBagId(v);
    if(norm) return norm;
  }
  return "";
}

function setupLod2EnergyStyling(){
  if(!lod2Tileset) return;

  if(!L2_SHOW_ENERGY_STYLE){
  
    lod2Tileset.style = new Cesium.Cesium3DTileStyle({
     
      color: "rgba(255,255,255,0.95)"
    });
    viewer.scene.requestRender();
    return;
  }

  lod2Tileset.style = new Cesium.Cesium3DTileStyle({
    color: {
      conditions: [
        ["${_dt_class} >= 2", "color('#b91c1c', 0.95)"],
        ["${_dt_class} >= 1", "color('#d97706', 0.95)"],
        ["${_dt_class} >= 0", "color('#15803d', 0.95)"],
        ["true",                                       "color('rgba(255,255,255,0.9)')"]
      ]
    }
  });

  if(!lod2TileHooked){
    lod2TileHooked = true;
    lod2Tileset.tileVisible.addEventListener(function(tile){
      try{
        if(!energyEstMap || energyEstMap.size === 0) return;
        const content = tile.content;
        const len = content.featuresLength;
        for(let i=0;i<len;i++){
          const f = content.getFeature(i);
          if(f.getProperty("_dt_done") === 1) continue;

          const bag = getBagIdFromLod2Pick(f);
          const est = bag ? energyEstMap.get(bag) : undefined;

          if(est !== undefined){
            f.setProperty("_dt_energyEst", est);
            f.setProperty("_dt_class", energyClassFromEst(est));
          } else {
            f.setProperty("_dt_class", -1);
          }
          f.setProperty("_dt_done", 1);
        }
      }catch(e){}
    });
  }
}

function clearLod2Highlight(){
  try{
    if(lod2SelectedFeature && lod2SelectedPrevColor){
      lod2SelectedFeature.color = lod2SelectedPrevColor;
    }
  }catch(e){}
  lod2SelectedFeature = null;
  lod2SelectedPrevColor = null;
}
function applyLod2Highlight(pick){
  clearLod2Highlight();
  if(pick && pick.color){
    lod2SelectedFeature = pick;
    lod2SelectedPrevColor = pick.color.clone ? pick.color.clone() : pick.color;
    pick.color = Cesium.Color.fromCssColorString('#3b82f6').withAlpha(0.95);
  }
}

// =============================
// 8) BOOT
// =============================
(async function boot(){
  await Promise.all([loadIrradianceScaleJson(), loadEnergyEstCSV(), loadLocalRasters()]);
  await loadGeoJSONLOD1();
  // After geometry is loaded, load energy labels to assign certified classifications
  await loadEnergyLabels();
})();

// =============================
// 9) GEOMETRY HELPERS
// =============================
function computeAreaAndCentroidFromCarto(cartoPositions){
  if(!cartoPositions || cartoPositions.length < 3) return { areaM2: 0, centroid: null };

  const proj = new Cesium.WebMercatorProjection(viewer.scene.globe.ellipsoid);
  const pts = cartoPositions.map(c => {
    const p = proj.project(c);
    return { x: p.x, y: p.y, lon: c.longitude, lat: c.latitude };
  });

  let area2 = 0;
  let cx = 0;
  let cy = 0;

  for(let i=0, j=pts.length-1; i<pts.length; j=i++){
    const p1 = pts[j];
    const p2 = pts[i];
    const cross = (p1.x * p2.y) - (p2.x * p1.y);
    area2 += cross;
    cx += (p1.x + p2.x) * cross;
    cy += (p1.y + p2.y) * cross;
  }

  const area = Math.abs(area2) / 2;
  if(Math.abs(area2) < 1e-9) {
    let lon = 0, lat = 0;
    for(const c of cartoPositions){ lon += c.longitude; lat += c.latitude; }
    lon /= cartoPositions.length; lat /= cartoPositions.length;
    return { areaM2: area, centroid: new Cesium.Cartographic(lon, lat, 0) };
  }

  cx = cx / (3 * area2);
  cy = cy / (3 * area2);
  const centroidCarto = proj.unproject(new Cesium.Cartesian3(cx, cy, 0));

  return { areaM2: area, centroid: centroidCarto };
}

// =============================
// 10) LOAD GEOJSON LOD1 (data-driven baseline)
// =============================
async function loadGeoJSONLOD1(){
  try{
    const ds = await Cesium.GeoJsonDataSource.load(GEOJSON_FILE, { clampToGround: true });
    const ents = ds.entities.values;

    ents.forEach(function(e) {
      let hierarchy = null;
      if (e.polygon && e.polygon.hierarchy) hierarchy = e.polygon.hierarchy.getValue();
      else if (e._children && e._children.length > 0) {
        const c = e._children.find(child => child.polygon && child.polygon.hierarchy);
        if(c) hierarchy = c.polygon.hierarchy.getValue();
      }
      if (!hierarchy || !e.properties) return;

      const p = e.properties;

      // Year: prefer bouwjaar_x then bouwjaar then bouwjaar_num
      let year = 1980;
      const y1 = numProp(p, "bouwjaar_x");
      const y2 = numProp(p, "bouwjaar");
      const y3 = numProp(p, "bouwjaar_num");
      const yPick = Number.isFinite(y1) ? y1 : (Number.isFinite(y2) ? y2 : y3);
      if(Number.isFinite(yPick)) year = Math.round(yPick);

      let h = 8;
      const h1 = numProp(p, "pandhoogte");
      const h2 = numProp(p, "height");
      const hPick = Number.isFinite(h1) ? h1 : h2;
      if(Number.isFinite(hPick)) h = hPick;
      if(h < 3) h = 6;

      const bagRaw1 = strProp(p, "bag_id");
      const bagRaw2 = strProp(p, "identificatie");
      const bagRaw3 = strProp(p, "rdf_seealso");
      const bagRaw = (bagRaw1 !== "N/A") ? bagRaw1 : ((bagRaw2 !== "N/A") ? bagRaw2 : bagRaw3);
      const bagNorm = normalizeBagId(bagRaw);

      // Baseline consumption (from GeoJSON)
      const gasM3 = numProp(p, "gas_m3");
      const elKwh = numProp(p, "el_kwh");
      const totKwh = numProp(p, "tot_kwh");

      // Baseline PV potential + used PV (from GeoJSON)
      const pvPot = numProp(p, "pv_kwh_pot");
      const pvUsed = numProp(p, "pv_kwh_used"); // may be 0 if not installed

      // Baseline CO2 (from GeoJSON; preferred)
      const co2Base1 = numProp(p, "co2_total_base_kg");
      const co2Base2 = numProp(p, "co2_kg");
      const co2Base = Number.isFinite(co2Base1) ? co2Base1 : (Number.isFinite(co2Base2) ? co2Base2 : NaN);

      const co2ElecBase = numProp(p, "co2_elec_base_kg");
      const co2Gas      = numProp(p, "co2_gas_kg");

      // Implied emission factors (data-driven when possible)
      const efElec = (Number.isFinite(co2ElecBase) && Number.isFinite(elKwh) && elKwh > 0) ? (co2ElecBase / elKwh) : PARAMS.co2.elec;
      const efGas  = (Number.isFinite(co2Gas)      && Number.isFinite(gasM3) && gasM3 > 0) ? (co2Gas / gasM3)      : PARAMS.co2.gas;

      // Baseline EUI: MUST use your age-class adjusted field
      const euiAge = numProp(p, "EUI_age_kwh_m2");
      const euiRaw = (Number.isFinite(totKwh) && pickFloorAreaM2(p) > 0) ? (totKwh / pickFloorAreaM2(p)) : numProp(p, "EUI_kwh_m2");
      const euiBase = Number.isFinite(euiAge) ? euiAge : (Number.isFinite(euiRaw) ? euiRaw : 0);

      // PV net EUI fields (use if present)
      const euiNetPv50 = numProp(p, "EUI_net_pv_50");
      const euiNetPv100 = numProp(p, "EUI_net_pv_100");
      const euiNetPvKwhM2 = numProp(p, "EUI_net_pv_kwh_m2");

      // Age multiplier norm (0..1 usually)
      const ageNorm = numProp(p, "age_mult_norm");
      const ageNormClamped = Number.isFinite(ageNorm) ? clamp01(ageNorm) : 0.5;

      // EnergyEST from CSV (mandatory); fallback to GeoJSON EnergyEst only if CSV missing for that id
      const fromCSV = bagNorm ? energyEstMap.get(bagNorm) : undefined;
      const fromGeo = numProp(p, "EnergyEst");
      const energyEST = (fromCSV !== undefined) ? fromCSV : (Number.isFinite(fromGeo) ? fromGeo : NaN);

      const floorAreaM2 = pickFloorAreaM2(p);

      const newEnt = viewer.entities.add({
        polygon: {
          hierarchy: hierarchy,
          height: 0,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          extrudedHeightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
          extrudedHeight: h,
          material: Cesium.Color.fromCssColorString("#8b6b4a").withAlpha(1.0),
          arcType: Cesium.ArcType.GEODESIC,
          outline: false
        }
      });

      try{
        newEnt._polyCartoPositions = hierarchy.positions.map(pos => Cesium.Cartographic.fromCartesian(pos));
      }catch(ex){
        newEnt._polyCartoPositions = null;
      }

      let footprintAreaM2 = 0;
      let centroidCarto = null;
      if(newEnt._polyCartoPositions && newEnt._polyCartoPositions.length >= 3){
        const ac = computeAreaAndCentroidFromCarto(newEnt._polyCartoPositions);
        footprintAreaM2 = ac.areaM2;
        centroidCarto = ac.centroid;
      }

      newEnt._b = {
        ID: bagNorm || bagRaw || "N/A",
        Year: year,
        Usage: strProp(p,"gebruiksdoel"),
        Area: floorAreaM2,
        FootprintAreaM2: footprintAreaM2,
        CentroidCarto: centroidCarto,
        RealHeight: h,

        // Baseline (data)
        AbsGas: Number.isFinite(gasM3) ? gasM3 : 0,
        AbsEl:  Number.isFinite(elKwh) ? elKwh : 0,
        AbsEnergy: Number.isFinite(totKwh) ? totKwh : ((Number.isFinite(gasM3)?gasM3:0)*9.77 + (Number.isFinite(elKwh)?elKwh:0)),

        PV_POT: Number.isFinite(pvPot) ? pvPot : 0,
        PV_USED: Number.isFinite(pvUsed) ? pvUsed : 0,

        EUI_BASE: euiBase,
        EUI_NETPV_50: Number.isFinite(euiNetPv50) ? euiNetPv50 : NaN,
        EUI_NETPV_100: Number.isFinite(euiNetPv100) ? euiNetPv100 : NaN,
        EUI_NETPV: Number.isFinite(euiNetPvKwhM2) ? euiNetPvKwhM2 : NaN,

        CO2_BASE: Number.isFinite(co2Base) ? co2Base : ((Number.isFinite(gasM3)?gasM3:0)*efGas + (Number.isFinite(elKwh)?elKwh:0)*efElec),
        CO2_ELEC_BASE: Number.isFinite(co2ElecBase) ? co2ElecBase : ((Number.isFinite(elKwh)?elKwh:0)*efElec),
        CO2_GAS_BASE: Number.isFinite(co2Gas) ? co2Gas : ((Number.isFinite(gasM3)?gasM3:0)*efGas),

        EF_ELEC: efElec,
        EF_GAS: efGas,

        AGE_NORM: ageNormClamped,

        EnergyEST: energyEST,

        customPV: false,
        customRetro: false
      };

      if(bagNorm) entByBagId.set(bagNorm, newEnt);

      // Baseline bounds use baseline fields (data-driven)
      bounds.EUI.min = Math.min(bounds.EUI.min, newEnt._b.EUI_BASE);
      bounds.EUI.max = Math.max(bounds.EUI.max, newEnt._b.EUI_BASE);
      bounds.PV.min  = Math.min(bounds.PV.min,  newEnt._b.PV_POT);
      bounds.PV.max  = Math.max(bounds.PV.max,  newEnt._b.PV_POT);
      bounds.CO2.min = Math.min(bounds.CO2.min, newEnt._b.CO2_BASE);
      bounds.CO2.max = Math.max(bounds.CO2.max, newEnt._b.CO2_BASE);

      myEntities.push(newEnt);
    });

    for(const k of ["EUI","PV","CO2"]){
      if(!Number.isFinite(bounds[k].min)) bounds[k].min = 0;
      if(!Number.isFinite(bounds[k].max)) bounds[k].max = 0;
    }

    initSeasonChart();
    updateEnvironment();
    // compute clustering on energy values to segment buildings and refresh the energy segment chart
    computeEnergyClusters();
    // After clustering, populate the energy segment chart to summarise the distribution
    updateEnergySegChart();
    if (myEntities.length > 0) {
      // Fly to the loaded entities with a steeper pitch so that the scene initially
      // focuses directly on the neighbourhood instead of a distant horizon.  A
      // shorter range (1000m) brings the camera closer and delivers a clearer
      // top‚Äëdown view.
      viewer.flyTo(myEntities, { duration: 3.0, offset: new Cesium.HeadingPitchRange(0, -1.2, 1000) });
    }

    setupInteraction();
    updateVis();
    updateLeftLegend();
  }catch(err){
    console.error("GeoJSON Error:", err);
  }
}

// =============================
// 11) MODE SWITCH
// =============================
window.toggleView = function(viewMode) {
  document.getElementById('viewData').classList.remove('active');
  document.getElementById('viewReal').classList.remove('active');

  clearLod2Highlight();

  if (viewMode === 'data') {
    // When switching to LOD1 (data) view, hide the prototype control panel
    const lod2Wrap = document.getElementById('lod2ControlsWrap');
    if(lod2Wrap) lod2Wrap.style.display = 'none';
    document.getElementById('viewData').classList.add('active');
    document.getElementById('lod1ControlsWrap').style.display = '';

    if (lod2Tileset) lod2Tileset.show = false;
    myEntities.forEach(e => e.show = true);

    viewer.shadowMap.darkness = BASE_SHADOW_DARKNESS;
    // Ensure that raster overlays (sunlight/shade) are hidden when leaving the
    // prototype view.  applyLod2Overlays() checks the view mode and toggles
    // imagery layers accordingly.
    applyLod2Overlays();
    updateVis();
  } else {
    // When switching to LOD2 (real) view, show the prototype control panel and hide LOD1 controls
    const lod2Wrap = document.getElementById('lod2ControlsWrap');
    if(lod2Wrap) lod2Wrap.style.display = '';
    document.getElementById('viewReal').classList.add('active');
    document.getElementById('lod1ControlsWrap').style.display = 'none';
    myEntities.forEach(e => e.show = false);

    if (lod2Tileset) lod2Tileset.show = L2_SHOW_BUILDINGS;
    closeInfo();

    applyPrototypeShadowVis();
    applyLod2Overlays();
    setupLod2EnergyStyling();
  }

  updateLeftLegend();
  viewer.scene.requestRender();
};

// =============================
// 12) LOD2 layer toggles
// =============================
window.toggleLod2Layer = function(layerKey){
  if(layerKey === 'buildings'){
    L2_SHOW_BUILDINGS = !L2_SHOW_BUILDINGS;
    const btn = document.getElementById('lod2L_buildings');
    btn.classList.toggle('active', L2_SHOW_BUILDINGS);
    if(lod2Tileset) lod2Tileset.show = (document.getElementById('viewReal').classList.contains('active') && L2_SHOW_BUILDINGS);
  }
  if(layerKey === 'energy'){
    L2_SHOW_ENERGY_STYLE = !L2_SHOW_ENERGY_STYLE;
    const btn = document.getElementById('lod2L_energy');
    btn.classList.toggle('active', L2_SHOW_ENERGY_STYLE);
    if(lod2Tileset && document.getElementById('viewReal').classList.contains('active')){
      setupLod2EnergyStyling();
    }
  }
  if(layerKey === 'irr'){
    L2_SHOW_IRR_OVERLAY = !L2_SHOW_IRR_OVERLAY;
    const btn = document.getElementById('lod2L_irr');
    btn.classList.toggle('active', L2_SHOW_IRR_OVERLAY);
    applyLod2Overlays();
  }
  if(layerKey === 'shadow'){
    L2_SHOW_SHADOW_OVERLAY = !L2_SHOW_SHADOW_OVERLAY;
    const btn = document.getElementById('lod2L_shadow');
    btn.classList.toggle('active', L2_SHOW_SHADOW_OVERLAY);
    applyLod2Overlays();
  }
  updateLeftLegend();
  viewer.scene.requestRender();
};

function applyLod2Overlays(){
  const inLod2 = document.getElementById('viewReal').classList.contains('active');
  if(irrRaster && irrRaster.imageryLayer) irrRaster.imageryLayer.show = (inLod2 && L2_SHOW_IRR_OVERLAY);
  if(shadowRaster && shadowRaster.imageryLayer) shadowRaster.imageryLayer.show = (inLod2 && L2_SHOW_SHADOW_OVERLAY);
}

// =======================================
//  Energy segment chart (dynamic)
//
//  This chart summarises the number of buildings falling into each energy consumption
//  segment (Low, Medium, High).  It replaces the hard‚Äëcoded targeted policy chart.  The
//  function should be called after entities are loaded and the clustering has been
//  computed.  It destroys any previous chart instance to avoid memory leaks.
let energySegChart = null;
function updateEnergySegChart() {
  const chartElem = document.getElementById('energySegChart');
  if(!chartElem || !myEntities || myEntities.length === 0) return;
  const ctx = chartElem.getContext('2d');
  // Count entities by cluster label.  Default counts are zero in case some
  // clusters have no members.
  const counts = { Low: 0, Medium: 0, High: 0 };
  for (const e of myEntities) {
    const b = e._b || {};
    const lbl = b.ClusterLabel;
    if(lbl && Object.prototype.hasOwnProperty.call(counts, lbl)) {
      counts[lbl] += 1;
    }
  }
  const labels = Object.keys(counts);
  const data = labels.map(l => counts[l]);
  // Destroy any existing chart before creating a new one
  if (energySegChart) {
    try { energySegChart.destroy(); } catch(ex) { /* ignore */ }
  }
  energySegChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'Number of buildings',
        data: data,
        backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],
        borderColor: ['#10b981', '#f59e0b', '#ef4444'],
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: {
          beginAtZero: true,
          ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--text-main') },
          grid: { color: 'rgba(255,255,255,0.1)' }
        },
        x: {
          ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--text-main') },
          grid: { color: 'rgba(255,255,255,0.1)' }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: { enabled: true }
      }
    }
  });
}



function toggleChat(force){
  const panel = document.getElementById('chatPanel');
  if(force === false){ panel.style.display = 'none'; return; }
  const currentlyVisible = (panel.style.display === 'flex' || panel.style.display === 'block');
  panel.style.display = currentlyVisible ? 'none' : 'flex';
  // When opening the chat for the first time, show example questions.  We use
  // a guard to ensure the suggestions only appear once per page load.
  if(!currentlyVisible && !chatSuggestionsShown){
    const chatContent = document.getElementById('chatContent');
    if(chatContent && chatContent.childElementCount === 0){
      addChatMessage('bot',
        'Here are some example questions you can ask:\n' +
        '‚Ä¢ Which houses have the highest energy consumption?\n' +
        '‚Ä¢ Which buildings are best suited for solar panels?\n' +
        '‚Ä¢ How much will I save if I invest ‚Ç¨5‚ÄØ000?\n' +
        '‚Ä¢ What happens if I add solar panels and improve insulation?');
      chatSuggestionsShown = true;
    }
  }
}
// attach click event to toggle button
document.getElementById('chatToggle').addEventListener('click', () => toggleChat());
// send message on button click and Enter key
document.getElementById('chatSendBtn').addEventListener('click', handleChatSubmit);
document.getElementById('chatText').addEventListener('keypress', function(e){
  if(e.key === 'Enter'){ e.preventDefault(); handleChatSubmit(); }
});

// Panel toggles
{
  const legToggleEl = document.getElementById('legToggle');
  if(legToggleEl){
    legToggleEl.addEventListener('click', () => {
      const legend = document.getElementById('leftLegend');
      if(!legend) return;
      const collapsed = legend.classList.toggle('collapsed');
      if(legToggleEl) legToggleEl.innerText = collapsed ? '¬ª' : '¬´';
    });
  }
  const rightToggleEl = document.getElementById('rightToggle');
  if(rightToggleEl){
    rightToggleEl.addEventListener('click', () => {
      const panel = document.getElementById('rightPanel');
      if(!panel) return;
      const collapsed = panel.classList.toggle('collapsed');
      if(rightToggleEl) rightToggleEl.innerText = collapsed ? '¬´' : '¬ª';
    });
  }
}

function addChatMessage(sender, text){
  const content = document.getElementById('chatContent');
  const msg = document.createElement('div');
  msg.className = 'chat-msg ' + (sender === 'user' ? 'user' : 'bot');
  msg.innerHTML = '<span>' + text + '</span>';
  content.appendChild(msg);
  // auto-scroll to bottom
  content.scrollTop = content.scrollHeight;
}

function handleChatSubmit(){
  const inputEl = document.getElementById('chatText');
  const q = inputEl.value.trim();
  if(!q) return;
  addChatMessage('user', q);
  inputEl.value = '';
  handleChatQuery(q.toLowerCase());
}

// Parse user query and respond accordingly
async function handleChatQuery(q){
  // If myEntities is still empty, some queries may yield limited data. We allow high-level responses
  // and provide a loading message in the fallback if necessary.
  // ------------------------------------------------------------
  // Simple greetings and politeness
  // Recognise a few common salutations and thanks and respond.  We check
  // short queries only to avoid matching parts of longer phrases (e.g. "highest" contains "hi").
  const clean = q.replace(/[^a-z0-9\s]/gi, '').trim();
  const tokens = clean.split(/\s+/).filter(t => t.length);
  // Recognise greetings across English, Dutch and German.  We keep
  // conditions short to avoid matching substrings in longer words
  // (‚Äúhighest‚Äù contains ‚Äúhi‚Äù).
  if(tokens.length <= 3){
    const tset = new Set(tokens.map(t => t.toLowerCase()));
    // Dutch greetings: hoi/hallo; German greetings: hallo, guten tag
    if(tset.has('hoi')){
      addChatMessage('bot', 'Hoi! üëã Hoe kan ik je helpen?');
      return;
    }
    if(tset.has('hallo')){
      // respond in German/Dutch neutral style
      addChatMessage('bot', 'Hallo! üëã Wie kann ich helfen?');
      return;
    }
    if((tset.has('guten') && tset.has('tag')) || tset.has('servus') || tset.has('moin')){
      addChatMessage('bot', 'Hallo! üëã Wie kann ich helfen?');
      return;
    }
    if(tset.has('hi') || tset.has('hello') || tset.has('hey')){
      addChatMessage('bot', 'Hi there! üëã How can I assist you with your energy questions?');
      return;
    }
  }
  if(clean.startsWith('thank you') || clean.startsWith('thanks') || clean === 'thankyou'){
    addChatMessage('bot', 'You\'re welcome! üòä');
    return;
  }

  // ------------------------------------------------------------
  // Definition‚Äëstyle queries (e.g. "what is", "who is", "explain", etc.)
  // If the question appears to ask for a definition or explanation,
  // prioritise the Wikipedia lookup before energy‚Äëspecific patterns.
  {
    const defRegex = /^(\s*(what|who|wat|wie|was|wer)\b)|\bexplain\b|tell\s+me\s+about/i;
    if(defRegex.test(q)){
      const handledDef = await handleGeneralWikiQuery(q);
      if(handledDef) return;
      // fall through if not handled
    }
  }

  // ------------------------------------------------------------
  // Finance/law/budget keywords ‚Äì prioritise general answers before
  // energy‚Äëspecific logic. This catches questions about inflation,
  // compound interest, bonds, ETFs, stocks, EU laws like GDPR and
  // AI Act, budget templates (50/30/20) and statements starting
  // with "I have" or mentioning monthly income. When matched the
  // query is delegated to the general handler.
  {
    /*
      Finance and law keywords: questions about regulations, inflation, investment
      vehicles, or budgeting frameworks should generally be answered by the
      general knowledge (Wikipedia) handler.  We explicitly removed the
      `(i\s+have\s+\d)` pattern from this regex so that ‚ÄúI have ‚Ä¶‚Äù queries
      can be treated as budget‚Äërelated and handled locally (see below).
    */
    const keywordRegex = /(50\s*\/\s*30\s*\/\s*20)|(budget\s*(template|rule))|(monthly\s*income)|(inflation)|(compound\s+interest)|(bond\b)|(\betf\b)|(\bstocks?\b)|(gdpr)|(ai\s+act)|(directive\b)|(regulation\b)|(privacy)|(data\s*protection)/i;
    if(keywordRegex.test(q)){
      const handledKw = await handleGeneralWikiQuery(q);
      if(handledKw) return;
    }
  }

  // ------------------------------------------------------------
  // Budget-based suggestions and investment advice
  // If the user mentions a budget or investment along with a number, suggest what they could install
  {
    const budgetRegex1 = /(?:budget|invest|spend|allocate|investment)[^\d‚Ç¨]*([0-9]+(?:[\.,][0-9]+)?)/;
    const budgetRegex2 = /‚Ç¨\s*([0-9]+(?:[\.,][0-9]+)?)/;
    let match = clean.match(budgetRegex1);
    if(!match) match = clean.match(budgetRegex2);
    // also support phrases like "I have 2000", "Ik heb 2000", "Ich habe 2000".  We
    // intentionally use the original query (q) here to preserve accents and spacing.
    if(!match){
      const budgetRegex3 = /\b(?:i\s+have|ik\s+heb|ich\s+habe)\s*([0-9]+(?:[\.,][0-9]+)?)/i;
      const m3 = q.match(budgetRegex3);
      if(m3 && m3[1]){
        match = [null, m3[1]];
      }
    }
    if(match){
      let raw = match[1].replace(/,/g, '.');
      const budget = parseFloat(raw);
      if(Number.isFinite(budget) && budget > 0){
        const costPerWp = PARAMS.costs.pvPerWp || 1.13;
        const totalWp = budget / costPerWp;
        const annualKwh = totalWp * 0.9;
        const annualSavings = annualKwh * (PARAMS.prices.elecImport || 0.30);
        const payback = annualSavings > 0 ? (budget / annualSavings).toFixed(1) : 'N/A';
        const costPerM2 = PARAMS.costs.insulationSqM || 50;
        const insulArea = budget / costPerM2;
        const msgParts = [];
        msgParts.push(`With your budget of ‚Ç¨${Math.round(budget).toLocaleString()}, you could install roughly ${(totalWp/1000).toFixed(1)} kWp of solar panels producing about ${Math.round(annualKwh).toLocaleString()} kWh/year.`);
        msgParts.push(`At a grid price of ‚Ç¨${(PARAMS.prices.elecImport || 0.30).toFixed(2)}/kWh this could save you around ‚Ç¨${Math.round(annualSavings).toLocaleString()} per year, giving a payback time of about ${payback} years.`);
        msgParts.push(`Alternatively, at about ‚Ç¨${costPerM2}/m¬≤ you could insulate roughly ${insulArea.toFixed(1)} m¬≤ of your building to reduce heating demand.`);
        addChatMessage('bot', msgParts.join(' '));
        return;
      }
    }
  }

  // ------------------------------------------------------------
  // What-if scenarios combining solar and insulation
  // Detect questions asking about adding solar panels together with insulation (e.g. "what happens if I add solar panels and improve insulation")
  if((clean.includes('solar') || clean.includes('panels')) && clean.includes('insulat') && clean.includes('if')){
    if(selectedEnt){
      const b = selectedEnt._b || {};
      let baseline;
      if(b.ID){
        const est = energyEstMap.get(normalizeBagId(b.ID));
        if(Number.isFinite(est)) baseline = est;
      }
      if(!Number.isFinite(baseline)){
        const gas = Number.isFinite(b.AbsGas) ? b.AbsGas : 0;
        const elec = Number.isFinite(b.AbsEl) ? b.AbsEl : 0;
        baseline = (gas * 9.77) + elec;
      }
      const pvPot = getVal(selectedEnt, 'PV', 'baseline') || 0;
      const insRate = insulationSavingRate(b);
      const afterIns = baseline * (1 - insRate);
      const offsetPV = Math.min(pvPot, afterIns);
      const newEnergy = afterIns - offsetPV;
      const savingsEl = offsetPV * (PARAMS.prices.elecImport || 0.30);
      const savingsIns = (baseline - afterIns) * (PARAMS.prices.elecImport || 0.30);
      const totalSavings = savingsEl + savingsIns;
      const co2SavedPV = offsetPV * (PARAMS.co2.elec || 0.268);
      const co2SavedIns = (baseline - afterIns) * (PARAMS.co2.elec || 0.268);
      const totalCO2 = co2SavedPV + co2SavedIns;
      const percReduction = baseline > 0 ? (100 * (baseline - newEnergy) / baseline) : 0;
      const resp = [];
      resp.push(`Combining solar panels and insulation on this building could reduce annual energy use from ${Math.round(baseline).toLocaleString()} kWh to ${Math.round(newEnergy).toLocaleString()} kWh (${percReduction.toFixed(1)}% reduction).`);
      resp.push(`Total CO‚ÇÇ reduction would be roughly ${Math.round(totalCO2).toLocaleString()} kg/year.`);
      resp.push(`Estimated annual savings are about ‚Ç¨${Math.round(totalSavings).toLocaleString()}.`);
      addChatMessage('bot', resp.join(' '));
    } else {
      addChatMessage('bot', 'Combining solar panels and improved insulation reduces both your consumption and your dependence on the grid. Select a building on the map for a personalised what‚Äëif analysis.');
    }
    return;
  }

  // ------------------------------------------------------------
  // CO2 savings and reduction targets
  // Queries asking how much CO‚ÇÇ could be saved or reduced
  if((clean.includes('co2') || clean.includes('carbon')) && (clean.includes('save') || clean.includes('saving') || clean.includes('reduce'))){
    // Use the original query (with symbols) to detect percentage targets. Using q instead of clean preserves the % sign.
    const percMatch = q.match(/(\d+)\s*%/);
    if(percMatch && percMatch[1]){
      const targetPct = parseFloat(percMatch[1]) / 100;
      if(selectedEnt){
        const b = selectedEnt._b || {};
        let baseline;
        if(b.ID){
          const est = energyEstMap.get(normalizeBagId(b.ID));
          if(Number.isFinite(est)) baseline = est;
        }
        if(!Number.isFinite(baseline)){
          const gas = Number.isFinite(b.AbsGas) ? b.AbsGas : 0;
          const elec = Number.isFinite(b.AbsEl) ? b.AbsEl : 0;
          baseline = (gas * 9.77) + elec;
        }
        const baselineCO2 = baseline * (PARAMS.co2.elec || 0.268);
        const desiredCO2 = baselineCO2 * (1 - targetPct);
        const reductionKg = baselineCO2 - desiredCO2;
        const neededKwh = reductionKg / (PARAMS.co2.elec || 0.268);
        const pvPot = getVal(selectedEnt, 'PV', 'baseline') || 0;
        if(neededKwh <= pvPot){
          const pctRoof = (neededKwh / pvPot) * 100;
          addChatMessage('bot', `To reduce CO‚ÇÇ emissions by ${percMatch[1]}%, you would need to generate approximately ${Math.round(neededKwh).toLocaleString()} kWh of solar electricity each year, which corresponds to about ${pctRoof.toFixed(0)}% of this roof's solar potential. Adding insulation can further lower your energy demand and required PV coverage.`);
        } else {
          addChatMessage('bot', `To reduce CO‚ÇÇ emissions by ${percMatch[1]}%, you would need roughly ${Math.round(neededKwh).toLocaleString()} kWh of renewable energy per year, which exceeds this building's solar potential of ${Math.round(pvPot).toLocaleString()} kWh. Consider combining full rooftop solar with deep insulation and a heat pump to meet the target.`);
        }
      } else {
        addChatMessage('bot', 'To meet a CO‚ÇÇ reduction goal, install enough solar panels or reduce energy use through insulation and efficient heating. Select a building for a detailed calculation.');
      }
      return;
    } else {
      if(selectedEnt){
        const pvPot = getVal(selectedEnt, 'PV', 'baseline') || 0;
        const co2Saved = pvPot * (PARAMS.co2.elec || 0.268);
        const trees = co2Saved / 21.0;
        addChatMessage('bot', `Installing solar panels on this building could reduce CO‚ÇÇ emissions by about ${Math.round(co2Saved).toLocaleString()} kg each year, which is equivalent to planting roughly ${Math.round(trees)} trees annually.`);
      } else {
        addChatMessage('bot', 'Installing solar panels typically cuts emissions by replacing grid electricity. Select a building to see how much CO‚ÇÇ you could save.');
      }
      return;
    }
  }

  // ------------------------------------------------------------
  // Layer and scenario toggles via natural language
  // Recognise requests to switch indicator layer, scenario or view.  We use
    // fairly broad keyword matching so users can say things like
    // "show me the solar map" or "activate heat pump scenario" and the
    // appropriate function will be called.  Targeted policies based on
    // energy‚Äëlabel groups have been removed from the UI, so those phrases are
    // no longer recognised.  Overlay toggles apply only in LOD 2.2.
  {
    const lq = clean;
    // indicator layers
    if(((lq.includes('energy') && lq.includes('use')) || (lq.includes('consumption') && lq.includes('layer')) || lq.includes('eui'))){
      setIndicator('EUI');
      addChatMessage('bot','Switched to energy use layer.');
      return;
    }
    if((lq.includes('solar') || lq.includes('pv') || lq.includes('sunlight')) && (lq.includes('layer') || lq.includes('map') || lq.includes('view'))){
      setIndicator('PV');
      addChatMessage('bot','Switched to solar potential layer.');
      return;
    }
    if((lq.includes('carbon') || lq.includes('co2') || lq.includes('emission')) && (lq.includes('layer') || lq.includes('map') || lq.includes('view'))){
      setIndicator('CO2');
      addChatMessage('bot','Switched to carbon emission layer.');
      return;
    }
    // scenario toggles
    if(lq.includes('baseline')){ setScenario('baseline'); addChatMessage('bot','Set scenario to baseline.'); return; }
    if((lq.includes('more solar') || (lq.includes('solar') && lq.includes('scenario')) || lq.includes('pv scenario') || lq.includes('add pv'))){ setScenario('addPV'); addChatMessage('bot','Activated the more-solar-panels scenario.'); return; }
    if(lq.includes('insulate') || lq.includes('insulation')){ setScenario('insulate'); addChatMessage('bot','Activated the better-insulation scenario.'); return; }
    if(lq.includes('heat pump') || lq.includes('heatpump')){ setScenario('heatPump'); addChatMessage('bot','Activated the heat pump transition scenario.'); return; }
    if(lq.includes('p2p') || lq.includes('energy sharing') || lq.includes('peer to peer')){ setScenario('p2p'); addChatMessage('bot','Activated the local energy sharing scenario.'); return; }
    // targeted scenarios have been removed ‚Äì ignore any attempts to activate them via chat
    // view toggles
    if((lq.includes('3d') || lq.includes('prototype') || lq.includes('lod 2') || (lq.includes('building') && lq.includes('view')))){
      toggleView('real');
      addChatMessage('bot','Switched to the 3D building view (LOD‚ÄØ2.2).');
      return;
    }
    if((lq.includes('map view') || lq.includes('neighbourhood') || lq.includes('lod 1') || (lq.includes('neighborhood') && lq.includes('view')))){
      toggleView('data');
      addChatMessage('bot','Switched to the neighbourhood energy map (LOD‚ÄØ1).');
      return;
    }
    // LOD2 overlay toggles (only meaningful when in the 3D view)
    if((lq.includes('sunlight overlay') || (lq.includes('sunlight') && lq.includes('overlay')) || (lq.includes('irradiance') && lq.includes('layer')))){
      toggleLod2Layer('irr');
      addChatMessage('bot','Toggled the roof sunlight overlay.');
      return;
    }
    if((lq.includes('shade overlay') || (lq.includes('shade') && lq.includes('overlay')) || (lq.includes('shadow') && lq.includes('overlay')))){
      toggleLod2Layer('shadow');
      addChatMessage('bot','Toggled the roof shade overlay.');
      return;
    }
  }

  // ------------------------------------------------------------
  // Upgrade efficiency feedback and tradeoff summaries
  if((clean.includes('tradeoff') || clean.includes('trade-off') || (clean.includes('cost') && clean.includes('benefit')) || clean.includes('summary')) && clean.includes('building')){
    if(selectedEnt){
      const eco = calculateTradeoffs(selectedEnt);
      const b = selectedEnt._b || {};
      const parts = [];
      parts.push(`For building ${b.ID || ''}, the selected upgrade(s) have an upfront cost of around ‚Ç¨${Math.round(eco.cost).toLocaleString()}.`);
      parts.push(`Annual operational costs drop from ‚Ç¨${Math.round(eco.baseTotal).toLocaleString()}/yr to ‚Ç¨${Math.round(eco.newTotal).toLocaleString()}/yr, saving about ‚Ç¨${Math.round(eco.savings).toLocaleString()} each year.`);
      parts.push(`The expected payback time is ${eco.payback} years.`);
      if(eco.note) parts.push(`Note: ${eco.note}.`);
      addChatMessage('bot', parts.join(' '));
    } else {
      addChatMessage('bot', 'Select a building first by clicking on it, then ask for a tradeoff summary.');
    }
    return;
  }

  // ------------------------------------------------------------
  // Investment calculations based on user-provided amounts or queries like "How much will I save if I install solar panels?"
  // Recognise English and non‚ÄëEnglish phrases asking how much money can be saved
  // by installing solar panels.  Besides ‚Äúhow much ‚Ä¶ save ‚Ä¶ install/solar‚Äù, we
  // also match Dutch (‚Äúhoeveel ‚Ä¶ bespaar ‚Ä¶ zonne‚Äù), German (‚Äúwieviel ‚Ä¶ spare ‚Ä¶ solar‚Äù)
  // and variations like ‚Äúbesparen‚Äù, ‚Äúspaar‚Äù, ‚Äúeinsparen‚Äù.  This broadens
  // language coverage without requiring an external translation API.
  if((clean.includes('how much') || clean.includes('hoeveel') || clean.includes('wieviel')) &&
     (clean.includes('save') || clean.includes('bespaar') || clean.includes('spaar') || clean.includes('einspar')) &&
     (clean.includes('install') || clean.includes('solar') || clean.includes('zonne') || clean.includes('panels'))){
    const numMatch = clean.match(/(\d+(?:[\.,]\d+)?)/);
    const amount = numMatch ? parseFloat(numMatch[1].replace(/,/g, '.')) : null;
    if(amount && amount > 0){
      const costPerWp = PARAMS.costs.pvPerWp || 1.13;
      const totalWp = amount / costPerWp;
      const annualKwh = totalWp * 0.9;
      const annualSavings = annualKwh * (PARAMS.prices.elecImport || 0.30);
      const payback = annualSavings > 0 ? (amount / annualSavings).toFixed(1) : 'N/A';
      addChatMessage('bot', `Investing ‚Ç¨${Math.round(amount).toLocaleString()} in solar panels (~${(totalWp/1000).toFixed(1)} kWp) would produce around ${Math.round(annualKwh).toLocaleString()} kWh/year and save roughly ‚Ç¨${Math.round(annualSavings).toLocaleString()} per year (payback ~${payback} years).`);
    } else if(selectedEnt){
      const pvPot = getVal(selectedEnt, 'PV', 'baseline') || 0;
      const annualSavings = pvPot * (PARAMS.prices.elecImport || 0.30);
      const costPerWp = PARAMS.costs.pvPerWp || 1.13;
      const requiredBudget = (pvPot / 0.9) * costPerWp;
      addChatMessage('bot', `Maximising this roof's solar potential (~${Math.round(pvPot).toLocaleString()} kWh/year) would save about ‚Ç¨${Math.round(annualSavings).toLocaleString()} each year. This would require an investment of roughly ‚Ç¨${Math.round(requiredBudget).toLocaleString()}.`);
    } else {
      addChatMessage('bot', 'Select a building or provide an investment amount to estimate your savings.');
    }
    return;
  }

  // ------------------------------------------------------------
  // Downloadable report generation via chat
  if((clean.includes('download') || clean.includes('export')) && clean.includes('report')){
    if(selectedEnt){
      generatePDF();
      addChatMessage('bot', 'Generating your energy report PDF... Check your downloads shortly.');
    } else {
      addChatMessage('bot', 'Please select a building on the map before generating a report.');
    }
    return;
  }

  // ------------------------------------------------------------
  // Seasonal energy and solar optimisation suggestions
  if(clean.includes('season') || clean.includes('winter') || clean.includes('summer') || clean.includes('maximise solar') || clean.includes('maximize solar') || clean.includes('solar production')){
    if(clean.includes('winter') || clean.includes('season')){
      addChatMessage('bot', 'Energy demand for heating peaks in winter while solar output peaks in summer. Improving insulation and installing a heat pump reduces winter demand, while adding solar panels lets you make the most of the summer sun.');
    } else if(clean.includes('maximise') || clean.includes('maximize') || clean.includes('solar production')){
      addChatMessage('bot', 'To maximise solar energy production, ensure panels cover as much of the roof as possible, minimise shading (trim overhanging trees), and orient panels towards the south with an optimal tilt. Increasing panel efficiency or adding more panels will further boost production.');
    } else {
      addChatMessage('bot', 'Seasonal variations affect both energy use and solar generation. Insulation helps in winter, while solar panels produce more in summer.');
    }
    return;
  }

  // ------------------------------------------------------------
  // Adjust prototype parameters like roof coverage via chat
  {
    // Detect queries like "set roof coverage to 80%" or "coverage 70" and update the prototype PV coverage.
    const coverMatch = q.match(/coverage[^\d]*?(\d+)(?:\s*%|\b)/);
    if(coverMatch && coverMatch[1]){
      const coverage = parseFloat(coverMatch[1]) / 100;
      if(!isNaN(coverage) && coverage > 0 && coverage <= 1){
        prototypePVCoverage = coverage;
        if(selectedEnt){
          lastPrototypeNote = 'AI Assistant';
          renderInfoPrototype(selectedEnt);
        }
        addChatMessage('bot', `Roof solar coverage set to ${(coverage*100).toFixed(0)}%.`);
      } else {
        addChatMessage('bot', 'Please provide a coverage percentage between 1 and 100.');
      }
      return;
    }
  }

  // ------------------------------------------------------------
  // End of new patterns ‚Äì fall through to existing patterns below

  // energy use ‚Äì highest consumption across languages
  {
    const highestEnergy = clean.includes('highest energy') || clean.includes('high energy') ||
      (clean.includes('highest') && clean.includes('consumption')) || clean.includes('energy consumption') ||
      clean.includes('energieverbruik') || clean.includes('energieverbrauch') ||
      ((clean.includes('hoogste') || clean.includes('meest')) && clean.includes('energie'));
    if(highestEnergy){
      const sorted = myEntities.slice().sort((a,b) => {
        const va = getVal(a, 'EUI', activeScen);
        const vb = getVal(b, 'EUI', activeScen);
        return vb - va;
      });
      const top = sorted.slice(0, 5);
      if(top.length === 0){
        addChatMessage('bot', 'No buildings found in the current view.');
        return;
      }
      highlightEntities(top);
      const list = top.map(e => {
        const id = normalizeBagId(e._b.ID);
        return '<a href="#" class="bag-link" data-bag="' + id + '">' + id + '</a>';
      }).join(', ');
      addChatMessage('bot', 'These are the top buildings by energy use per m¬≤: ' + list + '. Click a BAG ID to zoom.');
      return;
    }
  }
  // solar potential ‚Äì best suited for panels across languages
  {
    const solarQuery = clean.includes('solar') || clean.includes('panels') || clean.includes('best suited') ||
      clean.includes('zonne') || clean.includes('panel') || clean.includes('zonnepanelen') ||
      ((clean.includes('hoogste') || clean.includes('meest')) && (clean.includes('zonne') || clean.includes('solar')));
    if(solarQuery){
      const sorted = myEntities.slice().sort((a,b) => {
        const va = getVal(a, 'PV', activeScen);
        const vb = getVal(b, 'PV', activeScen);
        return vb - va;
      });
      const top = sorted.slice(0, 5);
      if(top.length === 0){
        addChatMessage('bot', 'No buildings found in the current view.');
        return;
      }
      highlightEntities(top);
      const list = top.map(e => {
        const id = normalizeBagId(e._b.ID);
        return '<a href="#" class="bag-link" data-bag="' + id + '">' + id + '</a>';
      }).join(', ');
      addChatMessage('bot', 'Buildings with highest solar potential: ' + list + '. Click a BAG ID to zoom.');
      return;
    }
  }
  // carbon emissions ‚Äì highest emitters across languages
  {
    const carbonQuery = clean.includes('carbon') || clean.includes('co2') || clean.includes('emissions') ||
      clean.includes('koolstof') || clean.includes('emissies') || clean.includes('emissionen');
    if(carbonQuery){
      const sorted = myEntities.slice().sort((a,b) => {
        const va = getVal(a, 'CO2', activeScen);
        const vb = getVal(b, 'CO2', activeScen);
        return vb - va;
      });
      const top = sorted.slice(0, 5);
      if(top.length === 0){
        addChatMessage('bot', 'No buildings found in the current view.');
        return;
      }
      highlightEntities(top);
      const list = top.map(e => {
        const id = normalizeBagId(e._b.ID);
        return '<a href="#" class="bag-link" data-bag="' + id + '">' + id + '</a>';
      }).join(', ');
      addChatMessage('bot', 'Buildings with highest estimated carbon emissions: ' + list + '. Click a BAG ID to zoom.');
      return;
    }
  }
  // carbon emissions for currently selected building
  if((q.includes('co2') || q.includes('carbon')) && (q.includes('this') || q.includes('building'))){
    if(selectedEnt){
      const val = Math.round(getVal(selectedEnt, 'CO2', activeScen)).toLocaleString();
      addChatMessage('bot', 'This building emits approximately ' + val + ' kg CO‚ÇÇ per year under the selected scenario.');
    } else {
      addChatMessage('bot', 'Please select a building first by clicking on it in the map.');
    }
    return;
  }
  // energy saving opportunities for selected building
  if(q.includes('saving') || q.includes('energy-saving') || q.includes('opportunity') || q.includes('improvement')){
    if(selectedEnt){
      const b = selectedEnt._b;
      const suggestions = [];
      if(!b.customPV) suggestions.push('add solar panels');
      if(!b.customRetro) suggestions.push('improve insulation');
      if(suggestions.length === 0){
        addChatMessage('bot', 'All upgrades have already been applied to this building.');
      } else {
        addChatMessage('bot', 'For this building you could ' + suggestions.join(' and ') + '. Activate upgrades via the info panel.');
      }
    } else {
      addChatMessage('bot', 'Please select a building first by clicking on it in the map.');
    }
    return;
  }
  // ------------------------------------------------------------
  // General knowledge, finance and law: if none of the patterns above matched
  // try to answer via Wikipedia or simple rule‚Äëbased logic. This call will
  // attempt to search multiple Wikipedia languages, return an English
  // summary and relevant follow‚Äëups. For finance and law questions it
  // also appends a disclaimer. If no result is found, then fall back
  // to the generic energy help message.
  try {
    const handled = await handleGeneralWikiQuery(q);
    if(handled) return;
  } catch (e) {
    console.error('Wiki search failed', e);
  }
  // fallback guidance
  if(!myEntities || myEntities.length === 0){
    addChatMessage('bot', 'Data is still loading. Please try again shortly.');
  } else {
    addChatMessage('bot', 'Sorry, I didn\'t understand. Try asking: ‚ÄúWhich houses have the highest energy consumption?‚Äù or ‚ÄúWhich buildings are best suited for solar panels?‚Äù.');
  }
}

// Utility to fly to a list of entities
function highlightEntities(arr){
  if(!Array.isArray(arr) || arr.length === 0) return;
  clearLod2Highlight();
  selectedEnt = null;
  viewer.flyTo(arr, { duration: 3.0, offset: new Cesium.HeadingPitchRange(0, -0.7, 400) });
  viewer.scene.requestRender();
}

// Click handler for bag links in the chat messages
document.getElementById('chatContent').addEventListener('click', function(ev){
  const link = ev.target;
  if(link && link.classList && link.classList.contains('bag-link')){
    ev.preventDefault();
    const bag = link.getAttribute('data-bag');
    const ent = entByBagId.get(normalizeBagId(bag));
    if(ent){
      viewer.flyTo(ent, { offset: new Cesium.HeadingPitchRange(0, -0.8, 200), duration: 2 });
      selectedEnt = ent;
      if(document.getElementById('viewReal').classList.contains('active')){
        lastPrototypeNote = 'AI Assistant';
        renderInfoPrototype(ent);
      } else {
        renderInfo(ent);
        document.getElementById('infoPanel').style.display = 'block';
      }
      updateLeftLegend();
      viewer.scene.requestRender();
    }
  }
});

/*
  -----------------------------------------------------------------
  Wikipedia and General Knowledge Assistant
  
  These helper functions implement a lightweight multilingual
  Wikipedia search directly from the client. When the user asks
  a general question that doesn‚Äôt match energy‚Äëspecific patterns,
  the assistant will search the Dutch, German and English
  Wikipedias for the best match, jump to the English article,
  and return a concise summary with follow‚Äëup links. It also
  handles simple finance and EU law queries with rule‚Äëbased
  answers and appends appropriate legal/financial
  disclaimers. Multi‚Äëtopic queries (e.g. ‚Äúsolar and nuclear
  energy‚Äù) are split and processed separately.
*/

// Escape HTML to prevent injection in chat messages
function escapeHtml(str){
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#039;');
}

// Remove common filler words from the beginning of the query in
// English, Dutch and German (e.g. "what is", "wat is", "wer ist")
function removeFillerWords(q){
  const patterns = [
    /^\s*(wat\s+is|wat\s+zijn|wie\s+is|wie\s+zijn|wat\s+was|wie\s+was)\s+/i,
    /^\s*(was\s+ist|was\s+sind|wer\s+ist|wer\s+sind)\s+/i,
    /^\s*(what\s+is|what\s+are|who\s+is|who\s+are|tell\s+me\s+about)\s+/i
  ];
  let s = q.trim();
  for(const p of patterns){
    if(p.test(s)){
      s = s.replace(p, '');
      break;
    }
  }
  return s;
}

// Split queries on conjunctions "and", "en", "und" to support
// multi‚Äëtopic lookup. Returns an array of trimmed topics.
function splitMultiTopics(q){
  const lower = q.toLowerCase();
  // Use a regex that matches the language specific "and"
  const parts = lower.split(/\s+(and|en|und)\s+/i);
  const topics = [];
  for(let i=0; i<parts.length; i+=2){
    const t = parts[i].trim();
    if(t) topics.push(t);
  }
  return topics;
}

// Search Wikipedia across multiple languages. Returns the language
// and search results with the highest total hits, preferring
// English when available. Uses the MediaWiki API.
async function searchAcrossLanguages(query){
  const langs = ['en','nl','de'];
  const results = [];
  for(const lang of langs){
    try {
      const url = `https://${lang}.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=10&format=json&origin=*`;
      const resp = await fetch(url);
      const data = await resp.json();
      if(data.query && data.query.search && data.query.search.length){
        const hits = data.query.searchinfo && data.query.searchinfo.totalhits ? data.query.searchinfo.totalhits : data.query.search.length;
        results.push({ lang, search: data.query.search, hits });
      }
    } catch (e){
      console.error('Wiki search error for', lang, e);
    }
  }
  if(!results.length) return null;
  // Prefer English if available
  let choice = results.find(r => r.lang === 'en');
  if(!choice){
    // Else choose the language with the most hits
    choice = results.reduce((max, cur) => cur.hits > max.hits ? cur : max, results[0]);
  }
  return choice;
}

// Get the English title for a given page from another language.
// Uses the langlinks property to fetch the en link; returns
// null if no English article exists.
async function getEnglishTitleFromLang(title, lang){
  try {
    if(lang === 'en') return title;
    const url = `https://${lang}.wikipedia.org/w/api.php?action=query&prop=langlinks&titles=${encodeURIComponent(title)}&lllang=en&format=json&origin=*`;
    const resp = await fetch(url);
    const data = await resp.json();
    const pages = data.query && data.query.pages;
    if(pages){
      for(const id in pages){
        const page = pages[id];
        if(page.langlinks && page.langlinks.length){
          return page.langlinks[0]['*'];
        }
      }
    }
  } catch(e){ console.error('langlinks error', e); }
  return null;
}

// Fetch summary for an English Wikipedia page. Returns JSON
// containing title, extract, type and URLs.
async function fetchSummary(title){
  try {
    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(title)}`;
    const resp = await fetch(url);
    if(resp.ok){
      return await resp.json();
    }
  } catch(e){ console.error('summary fetch error', e); }
  return null;
}

// Fetch full extract (first sections) for a page to show more details.
async function fetchPageExtract(title){
  try {
    const url = `https://en.wikipedia.org/w/api.php?action=query&prop=extracts&explaintext=true&titles=${encodeURIComponent(title)}&format=json&origin=*`;
    const resp = await fetch(url);
    const data = await resp.json();
    const pages = data.query && data.query.pages;
    if(pages){
      for(const id in pages){
        const text = pages[id].extract;
        if(text){
          // return first few paragraphs
          const parts = text.split(/\n\n+/);
          let summary = parts.slice(0,3).join('\n\n');
          // limit to 800 characters
          if(summary.length > 800){ summary = summary.slice(0,800) + '‚Ä¶'; }
          return summary;
        }
      }
    }
  } catch(e){ console.error('extract fetch error', e); }
  return null;
}

// Fetch related topics for a given page title. Returns an array
// of related page titles.
async function fetchRelatedTitles(title){
  try {
    const url = `https://en.wikipedia.org/api/rest_v1/page/related/${encodeURIComponent(title)}`;
    const resp = await fetch(url);
    if(resp.ok){
      const data = await resp.json();
      if(data.pages && Array.isArray(data.pages)){
        return data.pages.slice(0,5).map(p => p.title);
      }
    }
  } catch(e){ console.error('related fetch error', e); }
  return [];
}

// Fetch top search suggestions (disambiguation) for a term in English.
async function fetchSearchSuggestions(term){
  try {
    const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(term)}&srlimit=5&format=json&origin=*`;
    const resp = await fetch(url);
    const data = await resp.json();
    if(data.query && data.query.search && data.query.search.length){
      return data.query.search.map(s => s.title);
    }
  } catch(e){ console.error('search suggestions error', e); }
  return [];
}

// Fetch a short summary for a query using DuckDuckGo's Instant Answer API.  This
// serves as a lightweight alternative to a Google search and returns a
// plain‚Äëtext abstract when available.  If no abstract exists the
// function returns null.  Due to CORS restrictions this may fail; any
// network errors are caught silently.  See https://api.duckduckgo.com/api for details.
async function fetchDuckDuckGoSummary(query){
  try{
    const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1`;
    const resp = await fetch(url);
    if(!resp.ok) return null;
    const data = await resp.json();
    if(data && data.AbstractText){
      return data.AbstractText;
    }
    // Fallback: if the top related topic has a text
    if(data && data.RelatedTopics && data.RelatedTopics.length){
      for(const topic of data.RelatedTopics){
        if(topic.Text){ return topic.Text; }
      }
    }
  } catch(e){ /* ignore fetch errors */ }
  return null;
}

// Build a summary for a single topic using Wikipedia. Returns an
// HTML string or null if nothing found.
async function processSingleWikipediaQuery(topic){
  const trimmed = topic.trim();
  if(!trimmed) return null;
  const choice = await searchAcrossLanguages(trimmed);
  if(!choice) return null;
  const lang = choice.lang;
  const first = choice.search[0];
  let englishTitle = first.title;
  if(lang !== 'en'){
    const en = await getEnglishTitleFromLang(first.title, lang);
    if(en) englishTitle = en;
  }
  // Fetch English summary
  const summary = await fetchSummary(englishTitle);
  if(!summary) return null;
  let html = '';
  // Title with language badge
  html += `<b>${escapeHtml(summary.title)}</b>`;
  html += ' <span style="background:rgba(59,130,246,0.2);color:var(--accent-primary);font-size:10px;border-radius:4px;padding:2px 6px;">EN</span><br>';
  // If disambiguation, list options
  if(summary.type === 'disambiguation'){
    html += escapeHtml(summary.extract || 'This term may refer to multiple topics.') + '<br>';
    const options = await fetchSearchSuggestions(trimmed);
    if(options && options.length){
      html += 'Multiple topics found. Please choose one:<br>';
      options.forEach(opt => {
        const encoded = encodeURIComponent(opt);
        html += `<a href="#" class="wiki-action" data-action="suggest" data-title="${encoded}">${escapeHtml(opt)}</a><br>`;
      });
    }
    return html;
  }
  // Normal summary
  html += escapeHtml(summary.extract || '') + '<br>';
  const pageUrl = summary.content_urls && summary.content_urls.desktop && summary.content_urls.desktop.page ? summary.content_urls.desktop.page : `https://en.wikipedia.org/wiki/${encodeURIComponent(summary.title)}`;
  // Follow up actions
  html += `<a href="${pageUrl}" target="_blank" style="color:var(--accent-primary);text-decoration:underline;" class="wiki-action" data-action="open" data-title="${encodeURIComponent(summary.title)}">Open Wikipedia page</a>`;
  html += ' ‚Ä¢ ';
  html += `<a href="#" class="wiki-action" data-action="details" data-title="${encodeURIComponent(summary.title)}">Show more details</a>`;
  html += ' ‚Ä¢ ';
  html += `<a href="#" class="wiki-action" data-action="related" data-title="${encodeURIComponent(summary.title)}">Related topics</a>`;
  return html;
}

// Handle general queries via Wikipedia or rule‚Äëbased finance/law logic.
// Returns true if a response has been generated, false otherwise.
async function handleGeneralWikiQuery(originalQ){
  const q = originalQ.trim();
  if(!q) return false;
  // Finance queries for "I have X" patterns (general planning)
  {
    // match statements like "I have 1000 euro" or "I have ‚Ç¨5000" (case insensitive)
    const moneyRegex = /\b(?:i have|i\'ve got|ik heb|ich habe)\s+([^‚Ç¨\s]+)\s*(‚Ç¨|eur|euro|euros)?/i;
    const match = q.match(moneyRegex);
    if(match){
      let raw = match[1].replace(/,/g,'.');
      const amount = parseFloat(raw);
      if(Number.isFinite(amount) && amount > 0){
        // Simple financial planning based on common rules
        const parts = [];
        parts.push(`With ‚Ç¨${Math.round(amount).toLocaleString()}, here are some common steps people consider:`);
        parts.push(`‚Ä¢ <b>Emergency fund:</b> keep 3‚Äì6 months of essential expenses in a readily available savings account for unexpected events.`);
        parts.push(`‚Ä¢ <b>Pay off high‚Äëinterest debt:</b> reducing debt often yields a guaranteed return equivalent to the interest rate.`);
        parts.push(`‚Ä¢ <b>Short‚Äëterm savings:</b> set aside money for upcoming goals like travel, education or home improvements (low‚Äërisk accounts).`);
        parts.push(`‚Ä¢ <b>Long‚Äëterm investing:</b> invest according to your risk tolerance. <i>Low risk:</i> savings accounts, government bonds; <i>medium risk:</i> balanced funds, bond/stock mixes; <i>high risk:</i> stock index funds, ETFs.`);
        parts.push(`<i>Disclaimer: This information is for general education and should not be taken as financial advice.</i>`);
        addChatMessage('bot', parts.join('<br>'));
        return true;
      }
    }
  }
  // Budget template generator: detect requests for 50/30/20 rule or budget allocation
  {
    const budgetRegex = /(50\s*\/\s*30\s*\/\s*20|budget\s*(template|rule))/i;
    if(budgetRegex.test(q)){
      // detect monthly income if provided
      const incomeMatch = q.match(/\b(?:income|salary|monthly)\s*([0-9]+(?:[\.,][0-9]+)?)/i);
      let income = incomeMatch ? parseFloat(incomeMatch[1].replace(/,/g,'.')) : null;
      let txt = '';
      if(Number.isFinite(income) && income > 0){
        const needs = income * 0.50;
        const wants = income * 0.30;
        const savings = income * 0.20;
        txt += `According to the 50/30/20 budgeting rule, ‚Ç¨${income.toLocaleString()} per month would be allocated roughly like this:<br>`;
        txt += `‚Ä¢ Needs (50%): ‚Ç¨${needs.toFixed(2).toLocaleString()} for housing, groceries, utilities and insurance.<br>`;
        txt += `‚Ä¢ Wants (30%): ‚Ç¨${wants.toFixed(2).toLocaleString()} for discretionary spending such as dining, hobbies or subscriptions.<br>`;
        txt += `‚Ä¢ Savings/Investing (20%): ‚Ç¨${savings.toFixed(2).toLocaleString()} for building an emergency fund and long‚Äëterm investing.`;
      } else {
        txt += `The 50/30/20 rule suggests splitting your take‚Äëhome income into three categories:<br>`;
        txt += `‚Ä¢ 50% for needs (housing, food, utilities);<br>`;
        txt += `‚Ä¢ 30% for wants (lifestyle and discretionary spending);<br>`;
        txt += `‚Ä¢ 20% for savings and investing.`;
      }
      txt += `<br><i>Disclaimer: This information is for general guidance and should not be considered financial advice.</i>`;
      addChatMessage('bot', txt);
      return true;
    }
  }
  // Simple finance definitions (inflation, compound interest, bond, ETF, stock)
  {
    const lower = q.toLowerCase();
    const financeTerms = ['inflation','compound interest','bond','etf','stock','stocks','dividend'];
    for(const term of financeTerms){
      if(lower.includes(term)){
        // Use Wikipedia for definitions; mark as finance for disclaimer
        const cleaned = removeFillerWords(q);
        const topics = splitMultiTopics(cleaned);
        const responses = [];
        for(const t of topics){
          const res = await processSingleWikipediaQuery(t);
          if(res) responses.push(res);
        }
        if(responses.length){
          let msg = responses.join('<br><br>');
          msg += '<br><i>Disclaimer: This information is for general education and should not be taken as financial advice.</i>';
          addChatMessage('bot', msg);
          return true;
        }
        break;
      }
    }
  }
  // EU law and policy definitions (GDPR, AI Act, directive vs regulation)
  {
    const lower = q.toLowerCase();
    const lawTerms = ['gdpr','ai act','directive','regulation','privacy','data protection'];
    for(const term of lawTerms){
      if(lower.includes(term)){
        // "Is this law about me?" helper: if the user asks if a law applies to them, provide general applicability details
        const aboutMeRegex = /(apply\s+to\s+me|applies\s+to\s+me|about\s+me|for\s+me|applicable\s+to\s+me)/i;
        if(aboutMeRegex.test(q)){
          let msg = '';
          if(lower.includes('gdpr')){
            msg = 'The General Data Protection Regulation (GDPR) applies to organisations that process personal data of individuals residing in the EU, regardless of where the organisation is based. It generally does not apply to the purely personal or household activities of individuals. The GDPR came into force on 25 May 2018.';
          } else if(lower.includes('ai act')){
            msg = 'The EU AI Act is a proposed regulation intended to govern the development and use of artificial intelligence systems. It is expected to apply to providers and users of AI systems in the EU, including those offering AI services to EU users from abroad. It will not apply to purely private, non‚Äëprofessional uses of AI. As of 2026 the AI Act has not yet been formally enacted; it is expected to enter into force around 2025.';
          } else if(lower.includes('directive') || lower.includes('regulation')){
            msg = 'In EU law, a regulation is binding in its entirety and directly applicable in all member states, whereas a directive sets out goals that member states must achieve through their own national laws. Whether a particular directive or regulation applies to you depends on your role (e.g. consumer, organisation) and the subject matter of the law. For example, consumer‚Äëprotection directives apply to businesses selling goods or services to EU consumers, while individuals acting in a private capacity are usually not directly subject to them.';
          } else if(lower.includes('privacy') || lower.includes('data protection')){
            msg = 'EU data‚Äëprotection and privacy laws generally apply to entities that collect, store or process personal data of EU residents. They do not typically apply to personal or household activities carried out by individuals. Major EU data‚Äëprotection rules, such as the GDPR, have been in force since May 2018.';
          }
          if(msg){
            msg += '<br><i>Disclaimer: This information is provided for general education and does not constitute legal advice.</i>';
            addChatMessage('bot', msg);
            return true;
          }
        }
        // Otherwise fetch a summary from Wikipedia and append a legal disclaimer
        const cleaned = removeFillerWords(q);
        const topics = splitMultiTopics(cleaned);
        const responses = [];
        for(const t of topics){
          const res = await processSingleWikipediaQuery(t);
          if(res) responses.push(res);
        }
        if(responses.length){
          let msg = responses.join('<br><br>');
          msg += '<br><i>Disclaimer: This information is provided for general education and does not constitute legal advice.</i>';
          addChatMessage('bot', msg);
          return true;
        }
        break;
      }
    }
  }
  // General Wikipedia lookup for any other query
  {
    const cleaned = removeFillerWords(q);
    const topics = splitMultiTopics(cleaned);
    const responses = [];
    for(const t of topics){
      const res = await processSingleWikipediaQuery(t);
      if(res) responses.push(res);
    }
    if(responses.length){
      addChatMessage('bot', responses.join('<br><br>'));
      return true;
    }
    // No Wikipedia result: try a fallback via DuckDuckGo Instant Answer
    const ddg = await fetchDuckDuckGoSummary(cleaned);
    if(ddg){
      addChatMessage('bot', escapeHtml(ddg));
      return true;
    }
  }
  return false;
}

// Event delegation for Wikipedia action links inside chat messages.
document.getElementById('chatContent').addEventListener('click', async function(ev){
  const el = ev.target;
  if(el && el.classList && el.classList.contains('wiki-action')){
    ev.preventDefault();
    const action = el.getAttribute('data-action');
    const encodedTitle = el.getAttribute('data-title');
    const title = decodeURIComponent(encodedTitle || '');
    if(!title) return;
    if(action === 'details'){
      // Show more details (longer extract)
      const text = await fetchPageExtract(title);
      if(text){
        addChatMessage('bot', `${escapeHtml(title)} ‚Äì more details:<br>${escapeHtml(text)}`);
      } else {
        addChatMessage('bot', 'Sorry, I couldn\'t retrieve more details for this topic.');
      }
    } else if(action === 'related'){
      const rel = await fetchRelatedTitles(title);
      if(rel && rel.length){
        let msg = `Topics related to <b>${escapeHtml(title)}</b>:<br>`;
        rel.forEach(r => {
          const enc = encodeURIComponent(r);
          msg += `<a href="#" class="wiki-action" data-action="suggest" data-title="${enc}">${escapeHtml(r)}</a><br>`;
        });
        addChatMessage('bot', msg);
      } else {
        addChatMessage('bot', 'No related topics found.');
      }
    } else if(action === 'suggest'){
      // user clicked on a suggested disambiguation or related topic; perform a new lookup
      const newRes = await processSingleWikipediaQuery(title);
      if(newRes){
        addChatMessage('bot', newRes);
      } else {
        addChatMessage('bot', 'No information found for ' + escapeHtml(title) + '.');
      }
    } else {
      // 'open' action uses actual link; do nothing special here
    }
  }
});

// =============================
// 13) CLICK POSITION
// =============================
function getClickCartographic(screenPos){
  let cartesian = viewer.scene.pickPosition(screenPos);
  if(!Cesium.defined(cartesian)){
    const ray = viewer.camera.getPickRay(screenPos);
    cartesian = viewer.scene.globe.pick(ray, viewer.scene);
  }
  if(!Cesium.defined(cartesian)) return null;
  return Cesium.Cartographic.fromCartesian(cartesian);
}

// =============================
// 14) SPATIAL FALLBACK
// =============================
function isPointInPolygon(point, polygonPositions) {
  let inside = false;
  for (let i = 0, j = polygonPositions.length - 1; i < polygonPositions.length; j = i++) {
    const xi = polygonPositions[i].longitude, yi = polygonPositions[i].latitude;
    const xj = polygonPositions[j].longitude, yj = polygonPositions[j].latitude;
    const intersect = ((yi > point.latitude) !== (yj > point.latitude))
      && (point.longitude < (xj - xi) * (point.latitude - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function findLOD1ByLocation(carto) {
  if (!carto || myEntities.length === 0) return null;
  for (let i = 0; i < myEntities.length; i++) {
    const ent = myEntities[i];
    if (!ent._polyCartoPositions || ent._polyCartoPositions.length < 3) continue;
    if (isPointInPolygon(carto, ent._polyCartoPositions)) return ent;
  }
  return null;
}

// =============================
// 15) INTERACTION
// =============================
function setupInteraction() {
  const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  const tip = document.getElementById('hoverTooltip');

  handler.setInputAction(m => {
    const inLod2View = document.getElementById('viewReal').classList.contains('active');

    if(inLod2View){
      const carto = getClickCartographic(m.endPosition);
      if(carto){
        const irr = irrRaster ? irrRaster.sampleFromCartographic(carto) : null;
        const shd = shadowRaster ? shadowRaster.sampleFromCartographic(carto) : null;

        tip.style.display = 'block';
        tip.style.left = (m.endPosition.x + 15) + 'px';
        tip.style.top  = (m.endPosition.y + 15) + 'px';
        tip.innerText =
          `Sunlight level (0‚Äì255, higher means more sunlight): ${irr ? irr.value : "N/A"}\nShade level (0‚Äì255, higher means more shade): ${shd ? shd.value : "N/A"}`;
        return;
      }
      tip.style.display = 'none';
      return;
    }

    const pick = viewer.scene.pick(m.endPosition);
    if(pick && pick.id && pick.id._b) {
      tip.style.display = 'block';
      tip.style.left = (m.endPosition.x + 15) + 'px';
      tip.style.top = (m.endPosition.y + 15) + 'px';

      const val = getVal(pick.id, activeInd, activeScen);
      let unit = (activeInd==='EUI' ? "kWh per m¬≤ per year" : (activeInd==='PV' ? "kWh per year" : "kg CO‚ÇÇ per year"));
      tip.innerText = `BAG ID: ${pick.id._b.ID}\n${Math.round(val)} ${unit}`;
    } else {
      tip.style.display = 'none';
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

  handler.setInputAction(c => {
    const inLod2View = document.getElementById('viewReal').classList.contains('active');
    const carto = getClickCartographic(c.position);

    if(inLod2View){
      lastPrototypeCarto = carto;

      const picked = viewer.scene.pick(c.position);
      if(picked && picked.getProperty) applyLod2Highlight(picked);
      else clearLod2Highlight();

      const bagFromTiles = getBagIdFromLod2Pick(picked);
      let ent = bagFromTiles ? entByBagId.get(bagFromTiles) : null;

      if(!ent && carto) ent = findLOD1ByLocation(carto);

      if(ent){
        lastPrototypeNote = bagFromTiles ? "Identifier match" : "Spatial match";
        selectedEnt = ent;
        renderInfoPrototype(ent);
      } else {
        if(carto) renderInfoGroundRaster(carto);
        else closeInfo();
      }

      updateLeftLegend();
      viewer.scene.requestRender();
      return;
    }

    const pick = viewer.scene.pick(c.position);
    if (pick && pick.id && pick.id._b) {
      selectedEnt = pick.id;
      document.getElementById('infoPanel').style.display = 'block';
      renderInfo(selectedEnt);
    } else {
      if(carto) renderInfoGroundRaster(carto);
      else closeInfo();
    }

    updateLeftLegend();
    viewer.scene.requestRender();
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
}

// =============================
// 16) INFO RENDERERS
// =============================
function formatLonLat(carto){
  const lon = Cesium.Math.toDegrees(carto.longitude);
  const lat = Cesium.Math.toDegrees(carto.latitude);
  return { lon, lat, lonStr: lon.toFixed(6), latStr: lat.toFixed(6) };
}

function renderInfoGroundRaster(carto){
  selectedEnt = null;

  document.getElementById('indivActions').style.display = 'none';
  document.getElementById('tradeoffBox').style.display = 'none';
  document.getElementById('chartContainer').style.display = 'none';
  document.getElementById('downloadRow').style.display = 'none';

  const irr = irrRaster ? irrRaster.sampleFromCartographic(carto) : null;
  const shd = shadowRaster ? shadowRaster.sampleFromCartographic(carto) : null;
  const ll = formatLonLat(carto);

  document.getElementById('infoId').innerText = "Location sample";
  document.getElementById('infoAddr').innerText = `Lon ${ll.lonStr}, Lat ${ll.latStr}`;

    const container = document.getElementById('dynamicStats');
    container.innerHTML = `
    <div class="stat-row">
      <span class="stat-label">Sunlight level (0‚Äì255)</span>
      <span class="stat-val">${irr ? irr.value : "N/A"}</span>
    </div>
    <div class="stat-row" style="border-bottom:none;">
      <span class="stat-label">Shade level (0‚Äì255)</span>
      <span class="stat-val">${shd ? shd.value : "N/A"}</span>
    </div>
  `;
  document.getElementById('infoPanel').style.display = 'block';
}

function pixelToIrradianceKwhM2Yr(px){
  if(!Number.isFinite(px)) return NaN;
  const min = Number(IRR_MIN_REAL);
  const max = Number(IRR_MAX_REAL);
  if(!Number.isFinite(min) || !Number.isFinite(max) || max <= min) return NaN;
  return min + (max - min) * (px / 255);
}

function applyPrototypeShadowVis(){
  const d = BASE_SHADOW_DARKNESS - (0.18 * prototypeShadowMitigation);
  viewer.shadowMap.darkness = Cesium.Math.clamp(d, 0.08, 0.45);
  viewer.scene.requestRender();
}
function refreshPrototypePanel(){
  if(document.getElementById('viewReal').classList.contains('active') && selectedEnt){
    renderInfoPrototype(selectedEnt);
    viewer.scene.requestRender();
  }
}

function renderInfoPrototype(ent){
  selectedEnt = ent;

  document.getElementById('indivActions').style.display = 'none';
  document.getElementById('tradeoffBox').style.display = 'none';
  document.getElementById('chartContainer').style.display = 'none';
  document.getElementById('downloadRow').style.display = 'none';

  const b = ent._b || {};
  const id = b.ID ? `BAG ID: ${b.ID}` : 'Building';

  // EnergyEST strictly from CSV map if possible
  let baseEst = NaN;
  if(b.ID){
    const v = energyEstMap.get(normalizeBagId(b.ID));
    if(v !== undefined) baseEst = v;
  }
  if(!Number.isFinite(baseEst) && Number.isFinite(b.EnergyEST)) baseEst = b.EnergyEST;

  const estAfterRetro = Number.isFinite(baseEst) ? Math.max(0, baseEst * (1 - prototypeRetrofit)) : NaN;

  const sampleCarto = b.CentroidCarto || lastPrototypeCarto;
  const irr = (sampleCarto && irrRaster) ? irrRaster.sampleFromCartographic(sampleCarto) : null;
  const shd = (sampleCarto && shadowRaster) ? shadowRaster.sampleFromCartographic(sampleCarto) : null;

  const irrKwhM2Yr = irr ? pixelToIrradianceKwhM2Yr(irr.value) : NaN;

  let shadeFracRaw = shd ? clamp01(shd.value / 255) : NaN;
  if(Number.isFinite(shadeFracRaw) && prototypeInvertShadow) shadeFracRaw = 1 - shadeFracRaw;

  const effectiveShade = Number.isFinite(shadeFracRaw) ? (shadeFracRaw * (1 - prototypeShadowMitigation)) : NaN;

  const areaM2 = Number(b.FootprintAreaM2 || 0);

  let solarKwh = NaN;
  if(Number.isFinite(irrKwhM2Yr) && areaM2 > 0){
    const shadeFactor = (prototypeApplyShadowToPV && Number.isFinite(effectiveShade)) ? (1 - effectiveShade) : 1;
    solarKwh = irrKwhM2Yr * areaM2 * prototypePVCoverage * prototypePVEff * shadeFactor;
  }

  const netKwh = (Number.isFinite(solarKwh) && Number.isFinite(estAfterRetro)) ? Math.max(0, estAfterRetro - solarKwh) : NaN;

  const cls = energyClassFromEst(baseEst);
  // Map the energy class index to a label and colour.  Unknown classes
  // (-1) display as ‚ÄúN/A‚Äù rather than ‚ÄúUNKNOWN‚Äù and use a muted colour.
  const clsName = (cls === 2) ? "HIGH" : (cls === 1 ? "MID" : (cls === 0 ? "LOW" : "N/A"));
  const clsColor = (cls === 2) ? "#ef4444" : (cls === 1 ? "#f59e0b" : (cls === 0 ? "#10b981" : "#94a3b8"));

  const ll = sampleCarto ? formatLonLat(sampleCarto) : null;

  document.getElementById('infoId').innerText = id;
  document.getElementById('infoAddr').innerText = `LOD 2.2 ‚Ä¢ ${lastPrototypeNote || ""}${ll ? ` ‚Ä¢ Lon ${ll.lonStr}, Lat ${ll.latStr}` : ""}`;

  const container = document.getElementById('dynamicStats');

  const fmt = (n, unit) => Number.isFinite(n)
    ? `${Math.round(n).toLocaleString()} <small style="font-size:12px;color:#64748b;">${unit}</small>`
    : `N/A`;

  container.innerHTML = `
    <div class="stat-row">
      <span class="stat-label">Building energy estimate</span>
      <span class="stat-val">${fmt(baseEst, "kWh per year")}</span>
    </div>

    <div class="stat-row">
      <span class="stat-label">Energy class</span>
      <span class="stat-val" style="color:${clsColor}; font-size:14px;">${clsName}</span>
    </div>

    <div class="stat-row">
      <span class="stat-label">Roof/footprint area</span>
      <span class="stat-val">${areaM2 > 0 ? `${Math.round(areaM2).toLocaleString()} <small style="font-size:12px;color:#64748b;">m¬≤</small>` : "N/A"}</span>
    </div>

    <div class="stat-row">
      <span class="stat-label">Roof sunlight</span>
      <span class="stat-val">${fmt(irrKwhM2Yr, "kWh per m¬≤ per year")}</span>
    </div>

    <div class="stat-row">
      <span class="stat-label">Roof shade</span>
      <span class="stat-val">${Number.isFinite(shadeFracRaw) ? `${(shadeFracRaw*100).toFixed(0)}<small style="font-size:12px;color:#64748b;">%</small>` : "N/A"}</span>
    </div>

    <div class="stat-row">
      <span class="stat-label">After insulation savings</span>
      <span class="stat-val">${fmt(estAfterRetro, "kWh per year")}</span>
    </div>

    <div class="stat-row">
      <span class="stat-label">Solar output</span>
      <span class="stat-val">${fmt(solarKwh, "kWh per year")}</span>
    </div>

    <div class="stat-row" style="border-bottom:none;">
      <span class="stat-label">Remaining demand</span>
      <span class="stat-val">${fmt(netKwh, "kWh per year")}</span>
    </div>
  `;

  document.getElementById('infoPanel').style.display = 'block';
}

// =============================
// 17) ENVIRONMENT
// =============================
window.updateEnvironment = function() {
  currentMonth = 5;
  document.getElementById('monthName').innerText = "June 2024";
  const date = new Date("2024-06-25T13:00:00");
  viewer.clock.currentTime = Cesium.JulianDate.fromDate(date);
  updateVis();
  viewer.scene.requestRender();
};

// =============================
// 18) LOD1 CONTROLS
// =============================
window.setIndicator = function(i) {
  // Update the active indicator (layer) and toggle button states.  Accepts
  // 'EUI', 'PV', 'CO2' and the new 'Label' indicator.  All other values are
  // ignored.  Button IDs follow the pattern btnEUI, btnPV, btnCO2, btnLabel.
  activeInd = i;
  ['btnEUI','btnPV','btnCO2','btnLabel'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.classList.remove('active');
  });
  const activeBtn = document.getElementById('btn' + i);
  if(activeBtn) activeBtn.classList.add('active');
  updateVis();
  updateLeftLegend();
};

window.setScenario = function(s) {
  activeScen = s;
  // Remove active state from all scenario buttons.  Targeted scenarios have been
  // removed from the UI so there is no need to include them in this list.
  ['scenBase','scenPV','scenIns','scenHP','scenP2P'].forEach(id=>{ const el=document.getElementById(id); if(el) el.classList.remove('active'); });
  // Map scenario identifiers to button IDs.  Only the five core scenarios are supported.
  const map = {
    baseline:'scenBase',
    addPV:'scenPV',
    insulate:'scenIns',
    heatPump:'scenHP',
    p2p:'scenP2P'
  };
  const btnId = map[s];
  const btnEl = btnId ? document.getElementById(btnId) : null;
  if(btnEl) btnEl.classList.add('active');
  updateVis();
  updateLeftLegend();
};

// =============================
// 19) PDF
// =============================
window.generatePDF = function() {
  if(document.getElementById('viewReal').classList.contains('active')){
    alert("Switch to LOD 1 to export report.");
    return;
  }
  if(!selectedEnt) return;
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  const b = selectedEnt._b;
  const eco = calculateTradeoffs(selectedEnt);

  // Header bar
  doc.setFillColor(15, 23, 42); doc.rect(0, 0, 210, 40, 'F');
  doc.setTextColor(255, 255, 255); doc.setFontSize(22); doc.text("Twekkelerveld Energy Report", 15, 25);

  // Building profile section
  doc.setTextColor(0, 0, 0); doc.setFontSize(14); doc.text("Building Profile", 15, 55);
  doc.setFontSize(10);
  doc.text(`BAG ID: ${b.ID}`, 15, 65);
  doc.text(`Year Built: ${b.Year}`, 15, 70);
  doc.text(`Floor Area: ${b.Area} m¬≤`, 15, 75);

  // Energy segment and financial details
  const seg = b.ClusterLabel || "N/A";
  doc.text(`Energy segment: ${seg}`, 15, 80);
  doc.text(`Capex (upfront): ‚Ç¨${Math.round(eco.cost).toLocaleString()}`, 15, 85);
  doc.text(`Opex baseline: ‚Ç¨${Math.round(eco.baseTotal).toLocaleString()} /yr`, 15, 90);
  doc.text(`Opex new: ‚Ç¨${Math.round(eco.newTotal).toLocaleString()} /yr`, 15, 95);
  doc.text(`Annual savings: ‚Ç¨${Math.round(eco.savings).toLocaleString()} /yr`, 15, 100);
  doc.text(`Break-even time: ${eco.payback} yrs`, 15, 105);

  // Include building chart image lower down
  const canvas = document.getElementById('buildingChart');
  const imgData = canvas.toDataURL("image/png", 1.0);
  doc.addImage(imgData, 'PNG', 15, 115, 180, 90);

  // Save the PDF
  doc.save(`EnergyReport_${b.ID}.pdf`);
};

// =============================
// 20) CORE CALCS (LOD1) ‚Äî DATA-DRIVEN BASELINE + AGE LOGIC
// =============================

// PV generation assumption for scenarios (only used for Balance/P2P + CO2 PV saving):
function pvGenScenarioKwh(b, scen){
  // baseline: use current installed PV used if present, else 0
  const base = Number.isFinite(b.PV_USED) ? b.PV_USED : 0;

  if(scen === "baseline") return base;

  // +50% scenario: represent increased adoption using remaining potential (data-driven)
  // PVgen = base + 0.5*(PV_POT - base), clamped
  if(scen === "addPV"){
    const pot = Number.isFinite(b.PV_POT) ? b.PV_POT : 0;
    const gen = base + 0.5 * Math.max(0, pot - base);
    return Math.max(0, Math.min(gen, pot));
  }

  // p2p: assume full potential can be produced locally (upper bound, still data-driven by pv_kwh_pot)
  if(scen === "p2p"){
    const pot = Number.isFinite(b.PV_POT) ? b.PV_POT : 0;
    return Math.max(0, pot);
  }

  // other scenarios keep baseline PV
  return base;
}

// insulation saving rate from age_mult_norm (older buildings ‚Üí higher savings potential)
function insulationSavingRate(b){
  const a = Number.isFinite(b.AGE_NORM) ? clamp01(b.AGE_NORM) : 0.5;
  // 0.15..0.35 (tunable but tied to your age_mult_norm)
  return 0.15 + 0.20 * a;
}

// COP from age (older buildings slightly lower COP)
function copFromAge(b){
  const a = Number.isFinite(b.AGE_NORM) ? clamp01(b.AGE_NORM) : 0.5;
  // COP 4.0 (newer) ‚Üí 3.0 (older)
  return 4.0 - 1.0 * a;
}

function getVal(e, ind, scen) {
  const b = e._b;

  // Determine which upgrades apply based on the active scenario.  In
  // targeted scenarios the building's energy‚Äëlabel group is used to
  // decide whether insulation, heat pump or PV are applied.  For
  // example, in the ‚ÄúretroDG‚Äù scenario only buildings with a
  // certified label in group C‚ÄìD‚ÄìE‚ÄìG (i.e. non‚ÄëA/B) receive
  // insulation.  Buildings without certified labels fall back to
  // Proxy estimates and are treated according to their estimated
  // cluster (HIGH ‚Üí treated as EG, MID ‚Üí CD, LOW ‚Üí AB).
  let hasPV = b.customPV || (scen === 'addPV') || (scen === 'p2p');
  let hasRetro = b.customRetro || (scen === 'insulate');
  let hasHP = (scen === 'heatPump');
  // Targeted: retrofit D‚ÄìG labels
  if(scen === 'retroDG'){
    const grp = b.LabelGroup;
    // If no certified label, infer from EnergyEst class index (ClusterLabel)
    let targetGroup = grp;
    if(!targetGroup){
      const idx = energyClassFromEst(b.EnergyEST);
      targetGroup = (idx === 2) ? 'EG' : (idx === 1 ? 'CD' : 'AB');
    }
    hasRetro = hasRetro || ['CD','EG'].includes(targetGroup);
  }
  // Targeted: heat pump for A‚ÄìC labels
  if(scen === 'heatAC'){
    const grp = b.LabelGroup;
    let targetGroup = grp;
    if(!targetGroup){
      const idx = energyClassFromEst(b.EnergyEST);
      targetGroup = (idx === 2) ? 'EG' : (idx === 1 ? 'CD' : 'AB');
    }
    hasHP = hasHP || ['AB','CD'].includes(targetGroup);
  }
  // Targeted: PV priority for low labels (E‚ÄìG)
  if(scen === 'pvLow'){
    const grp = b.LabelGroup;
    let targetGroup = grp;
    if(!targetGroup){
      const idx = energyClassFromEst(b.EnergyEST);
      targetGroup = (idx === 2) ? 'EG' : (idx === 1 ? 'CD' : 'AB');
    }
    hasPV = hasPV || ['EG'].includes(targetGroup);
  }

  // Baseline from dataset
  let currGasM3 = Number.isFinite(b.AbsGas) ? b.AbsGas : 0;
  let currElKwh = Number.isFinite(b.AbsEl)  ? b.AbsEl  : 0;

  // Apply insulation: reduce gas (heating) with age-driven saving rate
  if (hasRetro) {
    const s = insulationSavingRate(b);
    currGasM3 *= (1 - s);
  }

  // Heat pump: convert remaining gas heat to electricity with COP (age-driven)
  if (hasHP) {
    const cop = copFromAge(b);
    const gasKwhHeat = currGasM3 * 9.77;
    const hpElec = (cop > 0) ? (gasKwhHeat / cop) : gasKwhHeat;
    currGasM3 = 0;
    currElKwh += hpElec;
  }

  // PV generation scenario (only for balance, CO2 saving, tradeoffs)
  const pvGen = hasPV ? pvGenScenarioKwh(b, scen) : 0;

  // UI layer: PV potential is data field (pv_kwh_pot)
  if (ind === 'PV') return Number.isFinite(b.PV_POT) ? b.PV_POT : 0;
  if (ind === 'Generation') return pvGen;

  // EUI baseline must use EUI_age_kwh_m2 (already stored in b.EUI_BASE)
  if (ind === 'EUI') {
    if(scen === "baseline" && !b.customRetro && !b.customPV) return Number.isFinite(b.EUI_BASE) ? b.EUI_BASE : 0;

    // PV scenario: use your precomputed field if present
    if((scen === "addPV" || scen === "p2p") && !b.customRetro){
      if(Number.isFinite(b.EUI_NETPV_50) && scen === "addPV") return b.EUI_NETPV_50;
      if(Number.isFinite(b.EUI_NETPV_100) && scen === "p2p") return b.EUI_NETPV_100;
      if(Number.isFinite(b.EUI_NETPV) && scen === "addPV") return b.EUI_NETPV; // fallback
    }

    // Otherwise compute from simulated consumption (still consistent with dataset units)
    const totalKwh = (currGasM3 * 9.77) + currElKwh;
    const area = (Number.isFinite(b.Area) && b.Area > 0) ? b.Area : 1;
    return totalKwh / area;
  }

  // CO2: baseline from dataset; scenario uses implied factors derived from your dataset
  if (ind === 'CO2') {
    if(scen === "baseline" && !b.customRetro && !b.customPV) return Number.isFinite(b.CO2_BASE) ? b.CO2_BASE : 0;

    const efE = Number.isFinite(b.EF_ELEC) ? b.EF_ELEC : PARAMS.co2.elec;
    const efG = Number.isFinite(b.EF_GAS)  ? b.EF_GAS  : PARAMS.co2.gas;

    // PV self-consumption capped by electricity demand
    const pvUsedKwh = Math.max(0, Math.min(pvGen, currElKwh));
    const elecCO2 = Math.max(0, (currElKwh - pvUsedKwh) * efE);
    const gasCO2  = Math.max(0, currGasM3 * efG);
    return gasCO2 + elecCO2;
  }

  if (ind === 'AbsGas') return currGasM3;
  if (ind === 'AbsEl') return currElKwh;

  if (ind === 'Balance') {
    const monthGasKwh = (currGasM3 * 9.77) * heatCurve[currentMonth];
    // Divide annual electricity usage by 12 to obtain a monthly value.  Using 1/12
    // instead of a rounded 0.083 constant improves accuracy for monthly breakdowns.
    const monthElKwh = currElKwh / 12;
    const monthGen = pvGen * solarCurve[currentMonth];
    return monthGen - (monthGasKwh + monthElKwh);
  }

  return 0;
}

function calculateTradeoffs(e) {
  const b = e._b;
  let cost = 0, savings = 0, note = "";
  const isPV = b.customPV || activeScen === 'addPV' || activeScen === 'p2p';
  const isRetro = b.customRetro || activeScen === 'insulate';
  const isHP = activeScen === 'heatPump';

  // Costs (unchanged UI; keep same structure)
  if (isPV) cost += ((Number.isFinite(b.PV_POT)?b.PV_POT:0) / 350) * PARAMS.costs.pvPerWp * 350 + 1000;
  if (isRetro) cost += (Number.isFinite(b.Area)?b.Area:0) * PARAMS.costs.insulationSqM * (isPV ? 0.85 : 1);
  if (isHP) cost += (isRetro ? PARAMS.costs.allElectric : PARAMS.costs.hybridPump);

  // Baseline annual energy bill from baseline consumption
  const baseGas = getVal(e, 'AbsGas', 'baseline');
  const baseEl  = getVal(e, 'AbsEl', 'baseline');
  const baseTotal = (baseGas * PARAMS.prices.gas) + (baseEl * PARAMS.prices.elecImport);

  const newGas = getVal(e, 'AbsGas', activeScen);
  const newEl  = getVal(e, 'AbsEl', activeScen);
  const newPV  = getVal(e, 'Generation', activeScen);

  // ‚úÖ Correct self-consumption model (no weird /0.3):
  const selfCons = Math.min(newPV, newEl);
  const exported = Math.max(0, newPV - selfCons);
  const imported = Math.max(0, newEl - selfCons);
  const exportPrice = (activeScen === 'p2p') ? PARAMS.prices.p2p : PARAMS.prices.feedIn;

  const newTotal = (newGas * PARAMS.prices.gas) + (imported * PARAMS.prices.elecImport) - (exported * exportPrice);
  savings = baseTotal - newTotal;

  if (activeScen === 'p2p') note = "Local energy sharing price @ ‚Ç¨0.15/kWh";
  else if (isPV) note = "Feed-in tariff @ ‚Ç¨0.05/kWh";
  else if (isHP) note = (newGas > 0) ? "Hybrid heat pump" : "All-electric heat pump";

  const payback = savings > 0 ? (cost/savings).toFixed(1) : "N/A";
  // return capex (cost), savings, payback and also baseline and new operating costs
  return { cost, savings, payback, note, baseTotal, newTotal };
}

// =============================
// 20b) ENERGY SEGMENTATION ‚Äî K-MEANS CLUSTERING
// =============================
/**
 * Compute k-means clustering on annual energy consumption (kWh) for all loaded entities.
 * Assigns each entity a cluster index, rank (0 = low, 1 = medium, 2 = high, etc.) and a descriptive label.
 * The clustering is recomputed whenever entities are loaded.  See call near entity initialization.
 * @param {number} k - Number of clusters to compute. Default is 3.
 */
function computeEnergyClusters(k = 3) {
  // If there are no entities, skip clustering
  if(!myEntities || myEntities.length === 0) return;
  /**
   * Prepare an array of values and entity references for segmentation.  We attempt
   * to derive a reasonable energy consumption figure for each building using the
   * following precedence:
   *   1. Explicit total annual energy (AbsEnergy) when available.
   *   2. A combination of measured gas and electricity usage (AbsGas + AbsEl).
   *   3. If both are missing, estimate annual consumption by multiplying the
   *      baseline energy use intensity (EUI_BASE, in kWh/m¬≤) by the building's
   *      floor area.  This fallback ensures we have variation across buildings
   *      even when absolute consumption figures are absent in the data.  Any
   *      non‚Äëfinite values are treated as zero.
   */
  const pts = myEntities.map(e => {
    const b = e._b || {};
    let val = 0;
    if(Number.isFinite(b.AbsEnergy) && b.AbsEnergy > 0) {
      val = b.AbsEnergy;
    } else {
      const gas = Number.isFinite(b.AbsGas) ? b.AbsGas : 0;
      const elec = Number.isFinite(b.AbsEl) ? b.AbsEl : 0;
      if(gas > 0 || elec > 0) {
        // convert gas to kWh using a factor of 9.77, sum with electricity
        val = (gas * 9.77) + elec;
      } else {
        // approximate consumption from EUI (kWh/m¬≤) and area
        const eui = Number.isFinite(b.EUI_BASE) ? b.EUI_BASE : 0;
        const area = Number.isFinite(b.Area) ? b.Area : 0;
        val = eui * area;
      }
    }
    if(!Number.isFinite(val) || val < 0) val = 0;
    return { entity: e, val: val };
  });
  const n = pts.length;
  if(n === 0) return;
  // Sort the values to derive quantile thresholds.  We use quantiles rather than k‚Äëmeans
  // because k‚Äëmeans can converge to a single cluster when the data distribution is
  // narrow or missing.  Dividing the sorted values into three equal‚Äësized groups
  // ensures that the Low, Medium and High segments better reflect variation across
  // the neighbourhood, even with sparse data.
  const sortedVals = pts.map(p => p.val).sort((a,b) => a-b);
  // Compute indices for 1/3 and 2/3 quantiles.  Clamp indices to the array bounds.
  const idx1 = Math.floor((n - 1) / 3);
  const idx2 = Math.floor((2 * (n - 1)) / 3);
  const threshold1 = sortedVals[idx1] ?? 0;
  const threshold2 = sortedVals[idx2] ?? threshold1;
  // Assign a rank and descriptive label to each entity based on the thresholds.
  for(const p of pts){
    let rank = 0;
    if(p.val <= threshold1) {
      rank = 0;
    } else if(p.val <= threshold2) {
      rank = 1;
    } else {
      rank = 2;
    }
    const label = rank === 0 ? "Low" : (rank === 1 ? "Medium" : "High");
    const b = p.entity._b || {};
    b.Cluster = rank;      // in this quantile scheme the cluster index matches the rank
    b.ClusterRank = rank;
    b.ClusterLabel = label;
  }
}

// =============================
// 21) VISUALIZATION (LOD1)
// =============================
window.updateVis = function() {
  if (!myEntities || myEntities.length === 0) return;
  // In the 3D prototype view (LOD 2.2) the LOD 1 visualisation is hidden, so
  // skip all processing when that view is active.  The energy colours for
  // LOD 2 are handled separately by setupLod2EnergyStyling().
  if (document.getElementById('viewReal').classList.contains('active')) return;

  const isSharing = (activeScen === 'p2p');
  const slider = Number(document.getElementById('slider').value || 0);

  let monthConsTotal = 0;
  let monthGenTotal = 0;

  // Special handling for the discrete energy label layer.  When the
  // indicator is set to 'Label', buildings are coloured according to their
  // certified energy label (A‚ÄìG) rather than by a continuous metric.  The
  // threshold slider has no effect on this layer.  Aggregated monthly
  // consumption and generation values are still computed in the background
  // using the current scenario, so the summary statistics remain relevant.
  if (activeInd === 'Label') {
    for (const e of myEntities) {
      const b = e._b || {};
      // Only show certified buildings when the filter is enabled
      if (showCertifiedOnly && b.ProvSource !== 'Certified') {
        e.show = false;
        continue;
      }
      // Always show the building
      e.show = true;
      // Assign colour based on label letter, defaulting to grey for proxies
      const letter = b.LabelLetter ? b.LabelLetter.toUpperCase() : null;
      const hex = (letter && LABEL_COLOR_MAP[letter]) ? LABEL_COLOR_MAP[letter] : '#4b5563';
      const c = Cesium.Color.fromCssColorString(hex);
      e.polygon.material = new Cesium.ColorMaterialProperty(c);
      // Compute consumption and generation for aggregated stats
      const mGas = getVal(e, 'AbsGas', activeScen) * 9.77 * heatCurve[currentMonth];
      // Electricity consumption per month uses a precise 1/12 factor instead of 0.083
      const mEl  = getVal(e, 'AbsEl', activeScen) / 12;
      const mGen = getVal(e, 'Generation', activeScen) * solarCurve[currentMonth];
      monthConsTotal += (mGas + mEl);
      monthGenTotal += mGen;
    }
    // Update aggregated statistics
    document.getElementById('aggEUI').innerText = Math.round(monthConsTotal / 1000).toLocaleString();
    document.getElementById('aggPV').innerText  = Math.round(monthGenTotal / 1000).toLocaleString();
    const net = (monthGenTotal - monthConsTotal) / 1000;
    const netEl = document.getElementById('aggNet');
    netEl.innerText = Math.round(net).toLocaleString();
    netEl.style.color = net >= 0 ? 'var(--accent-success)' : '#f87171';
    if (selectedEnt) renderInfo(selectedEnt);
    updateLeftLegend();
    viewer.scene.requestRender();
    return;
  }

  // Continuous layers (EUI, PV, CO2, p2p).  Compute min/max values for
  // colouring and temporary storage of values.  Also compute monthly
  // consumption and generation for aggregated statistics.  Skip buildings
  // without certified labels when filtering by certification.
  let minV = Infinity, maxV = -Infinity;
  for (const e of myEntities) {
    // Skip unlabeled buildings when filtering by certification
    if (showCertifiedOnly && (!e._b || e._b.ProvSource !== 'Certified')) {
      e._tmpVal = 0;
      continue;
    }
    const valVisual = isSharing ? getVal(e, 'Balance', 'p2p') : getVal(e, activeInd, activeScen);
    e._tmpVal = valVisual;
    minV = Math.min(minV, valVisual);
    maxV = Math.max(maxV, valVisual);
    const mGas = getVal(e, 'AbsGas', activeScen) * 9.77 * heatCurve[currentMonth];
    // Use 1/12 factor for monthly electricity consumption
    const mEl  = getVal(e, 'AbsEl', activeScen) / 12;
    const mGen = getVal(e, 'Generation', activeScen) * solarCurve[currentMonth];
    monthConsTotal += (mGas + mEl);
    monthGenTotal += mGen;
  }
  let thresh = 0;
  if (!isSharing) {
    thresh = Math.abs(maxV) * (slider / 100);
  }
  document.getElementById('threshVal').innerText = Math.round(thresh).toLocaleString();
  for (const e of myEntities) {
    // Hide unlabeled buildings when filtering by certification
    if (showCertifiedOnly && (!e._b || e._b.ProvSource !== 'Certified')) {
      e.show = false;
      continue;
    }
    const valVisual = e._tmpVal;
    if (!isSharing) {
      if (Math.abs(valVisual) < thresh) { e.show = false; continue; }
      e.show = true;
      const denom = (maxV - minV);
      const ratio = denom > 0 ? (valVisual - minV) / denom : 0;
      const r = Cesium.Math.clamp(ratio, 0, 1);
      const colors = {
        EUI: { l: Cesium.Color.fromCssColorString('#10b981'), h: Cesium.Color.fromCssColorString('#ef4444') },
        PV:  { l: Cesium.Color.fromCssColorString('#ef4444'), h: Cesium.Color.fromCssColorString('#10b981') },
        CO2: { l: Cesium.Color.fromCssColorString('#2dd4bf'), h: Cesium.Color.fromCssColorString('#d946ef') }
      };
      const range = colors[activeInd] || colors.EUI;
      const c = Cesium.Color.lerp(range.l, range.h, r, new Cesium.Color());
      e.polygon.material = new Cesium.ColorMaterialProperty(c);
    } else {
      e.show = true;
      const maxAbs = Math.max(Math.abs(minV), Math.abs(maxV), 1);
      const norm = Math.max(-1, Math.min(1, valVisual / maxAbs));
      const c = norm < 0
        ? Cesium.Color.lerp(Cesium.Color.WHITE, Cesium.Color.fromCssColorString('#ef4444'), Math.abs(norm), new Cesium.Color())
        : Cesium.Color.lerp(Cesium.Color.WHITE, Cesium.Color.fromCssColorString('#3b82f6'), norm, new Cesium.Color());
      e.polygon.material = new Cesium.ColorMaterialProperty(c);
    }
  }
  // Update aggregated statistics
  document.getElementById('aggEUI').innerText = Math.round(monthConsTotal / 1000).toLocaleString();
  document.getElementById('aggPV').innerText  = Math.round(monthGenTotal / 1000).toLocaleString();
  const net = (monthGenTotal - monthConsTotal) / 1000;
  const netEl = document.getElementById('aggNet');
  netEl.innerText = Math.round(net).toLocaleString();
  netEl.style.color = net >= 0 ? 'var(--accent-success)' : '#f87171';
  if (selectedEnt) renderInfo(selectedEnt);
  updateLeftLegend(minV, maxV);
  viewer.scene.requestRender();
};

function initSeasonChart() {
  const ctx = document.getElementById('seasonCanvas').getContext('2d');
  seasonChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: months,
      datasets: [
        { label: 'Solar', data: solarCurve.map(v=>v*100), borderColor: '#facc15', borderWidth: 2, pointRadius: 0, tension:0.4 },
        { label: 'Heat', data: heatCurve.map(v=>v*100), borderColor: '#3b82f6', borderWidth: 2, pointRadius: 0, tension:0.4 }
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false }, annotation: { annotations: { line1: { type: 'line', xMin: 5, xMax: 5, borderColor: 'white', borderWidth: 2, borderDash: [2, 2] } } } },
      scales: { x: { display: false }, y: { display: false } }
    }
  });
}

function updateChart(e) {
  const ctx = document.getElementById('buildingChart').getContext('2d');
  if (myChart) myChart.destroy();

  const annualPV = getVal(e, 'Generation', activeScen);
  const annualGasM3 = getVal(e, 'AbsGas', activeScen);
  const annualElKwh = getVal(e, 'AbsEl', activeScen);
  const baseGasM3 = getVal(e, 'AbsGas', 'baseline');
  const baseElKwh = getVal(e, 'AbsEl', 'baseline');

  const dataPV = solarCurve.map(pct => annualPV * pct);

  // Multiply annual values by heat curve for gas and divide electricity by 12 for monthly consumption
  const dataCons = heatCurve.map(hPct => (annualGasM3 * 9.77 * hPct) + (annualElKwh / 12));
  const dataBaseCons = heatCurve.map(hPct => (baseGasM3 * 9.77 * hPct) + (baseElKwh / 12));

  myChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: months,
      datasets: [
        { label: 'Baseline', data: dataBaseCons, borderColor: '#64748b', borderDash: [5, 5], borderWidth: 1, pointRadius: 0, fill: false },
        { label: 'New Demand', data: dataCons, borderColor: '#f87171', backgroundColor: 'rgba(248, 113, 113, 0.1)', fill: true },
        { label: 'Solar Gen', data: dataPV, borderColor: '#3b82f6', backgroundColor: 'rgba(59, 130, 246, 0.1)', fill: true }
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { labels: { font: {family:'Inter'} } }, tooltip: {mode:'index', intersect:false} },
      scales: { x: { grid: {display:false} }, y: { display:false } }
    }
  });
}

function renderInfo(e) {
  if(document.getElementById('viewReal').classList.contains('active')) return;

  document.getElementById('indivActions').style.display = '';
  document.getElementById('chartContainer').style.display = '';
  document.getElementById('downloadRow').style.display = '';

  const b = e._b;
  document.getElementById('infoId').innerText = b.ID ? `BAG ID: ${b.ID}` : "Building";
  document.getElementById('infoAddr').innerText = `Year: ${b.Year} | Floor area: ${Math.round(b.Area).toLocaleString()} m¬≤`;

  const btnPV = document.getElementById('btnIndivPV');
  const btnRet = document.getElementById('btnIndivRetro');
  if(b.customPV) { btnPV.classList.add('applied'); btnPV.innerText = "Solar panels added ‚úì"; } else { btnPV.classList.remove('applied'); btnPV.innerText = "+ Add solar panels"; }
  if(b.customRetro) { btnRet.classList.add('applied'); btnRet.innerText = "Insulation added ‚úì"; } else { btnRet.classList.remove('applied'); btnRet.innerText = "+ Add insulation"; }

  const container = document.getElementById('dynamicStats');
  container.innerHTML = '';

  // Compose label/provenance information.  Only display the certified letter (A‚ÄìG)
  // to avoid confusing group codes (AB/CD/EG) or match/mismatch indicators.  When
  // a certified label is present we show just the letter; otherwise we fall
  // back to generic explanations.
  let labelInfo = '';
  if (b.ProvSource === 'Certified' && b.LabelLetter) {
    // Only the energy label letter (A‚ÄìG) is shown to the user
    const letter = b.LabelLetter;
    labelInfo = `${letter}`;
  } else if (b.ProvSource === 'Certified') {
    // Certified but missing a letter ‚Äì generic note
    labelInfo = 'Certified label';
  } else {
    // No certified label exists ‚Äì describe the proxy estimate
    labelInfo = 'No certified energy label ‚Äì proxy estimate based on age and usage';
  }

  // EnergyEST (CSV-first)
  let est = NaN;
  if(b.ID){
    const v = energyEstMap.get(normalizeBagId(b.ID));
    if(v !== undefined) est = v;
  }
  if(!Number.isFinite(est) && Number.isFinite(b.EnergyEST)) est = b.EnergyEST;

  if (activeScen === 'p2p') {
    const monBal = getVal(e, 'Balance', 'p2p');
    const status = monBal > 0 ? "NET SELLER" : "NET BUYER";
    container.innerHTML = `
      <div class="stat-row"><span class="stat-label">Role (June)</span><span class="stat-val" style="color:${monBal > 0 ? "#3b82f6" : "#f87171"}; font-size:16px;">${status}</span></div>
      <div class="stat-row"><span class="stat-label">Local sharing balance (June)</span><span class="stat-val">${Math.round(monBal).toLocaleString()} <small>kWh in month</small></span></div>
      <div class="stat-row" style="border-bottom:none;"><span class="stat-label">Building energy estimate</span><span class="stat-val">${Number.isFinite(est) ? `${Math.round(est).toLocaleString()} <small style="font-size:12px;color:#64748b;">kWh per year</small>` : "N/A"}</span></div>
    `;
    // append energy segment information if available
    if(b.ClusterLabel){
      container.innerHTML += `<div class="stat-row" style="border-bottom:none;"><span class="stat-label">Energy segment</span><span class="stat-val">${b.ClusterLabel}</span></div>`;
    }
    // append energy label info
    if(labelInfo){
      container.innerHTML += `<div class="stat-row" style="border-bottom:none;"><span class="stat-label">Energy label</span><span class="stat-val">${labelInfo}</span></div>`;
    }
  } else {
    const annualVal = getVal(e, activeInd, activeScen);
    let unit = activeInd === 'EUI' ? 'kWh per m¬≤ per year' : (activeInd === 'PV' ? 'kWh per year' : 'kg CO‚ÇÇ per year');
    let label = activeInd === 'EUI' ? 'Energy use per m¬≤' : (activeInd === 'PV' ? 'Solar electricity potential' : 'Carbon emissions');

    container.innerHTML = `
      <div class="stat-row"><span class="stat-label">${label}</span><span class="stat-val">${Math.round(annualVal).toLocaleString()} <small style="font-size:12px; color:#64748b;">${unit}</small></span></div>
      <div class="stat-row" style="border-bottom:none;"><span class="stat-label">Building energy estimate</span><span class="stat-val">${Number.isFinite(est) ? `${Math.round(est).toLocaleString()} <small style="font-size:12px;color:#64748b;">kWh per year</small>` : "N/A"}</span></div>
    `;
    // append energy segment information if available
    if(b.ClusterLabel){
      container.innerHTML += `<div class="stat-row" style="border-bottom:none;"><span class="stat-label">Energy segment</span><span class="stat-val">${b.ClusterLabel}</span></div>`;
    }
    // append energy label info
    if(labelInfo){
      container.innerHTML += `<div class="stat-row" style="border-bottom:none;"><span class="stat-label">Energy label</span><span class="stat-val">${labelInfo}</span></div>`;
    }
  }

  const tradeBox = document.getElementById('tradeoffBox');
  if(activeScen !== 'baseline' || b.customPV || b.customRetro) {
    tradeBox.style.display = 'block';
    const eco = calculateTradeoffs(e);
    const pColor = (parseFloat(eco.payback) > 15 || eco.payback === "N/A") ? "#f87171" : "#10b981";
    // populate capex/opex and savings, include time units
    document.getElementById('tradeCost').innerText = "‚Ç¨" + Math.round(eco.cost).toLocaleString();
    document.getElementById('tradeOpexBase').innerText = "‚Ç¨" + Math.round(eco.baseTotal).toLocaleString() + " /yr";
    document.getElementById('tradeOpexNew').innerText = "‚Ç¨" + Math.round(eco.newTotal).toLocaleString() + " /yr";
    document.getElementById('tradeSave').innerText = "‚Ç¨" + Math.round(eco.savings).toLocaleString() + " /yr";
    document.getElementById('tradePay').innerText = eco.payback + " yrs";
    document.getElementById('tradePay').style.color = pColor;
    document.getElementById('tradeNote').innerText = eco.note;
  } else {
    tradeBox.style.display = 'none';
  }

  updateChart(e);
  document.getElementById('infoPanel').style.display = 'block';
}

// =============================
// 22) LEFT LEGEND
// =============================
function fmtRange(n, unit){
  if(!Number.isFinite(n)) return "‚Äî";
  const v = Math.round(n);
  return `${v.toLocaleString()} ${unit}`;
}

function updateLeftLegend(minScenario=null, maxScenario=null){
  const inLod2 = document.getElementById('viewReal').classList.contains('active');

  const titleEl = document.getElementById('legTitle');
  const subEl   = document.getElementById('legSub');
  const gradEl  = document.getElementById('legGradient');
  const minEl   = document.getElementById('legMinLabel');
  const maxEl   = document.getElementById('legMaxLabel');
  const noteEl  = document.getElementById('legNote');
  const selEl   = document.getElementById('legSelectedVal');

  if(inLod2 && selectedEnt && selectedEnt._b){
    let est = NaN;
    const id = selectedEnt._b.ID;
    if(id){
      const v = energyEstMap.get(normalizeBagId(id));
      if(v !== undefined) est = v;
    }
    if(!Number.isFinite(est) && Number.isFinite(selectedEnt._b.EnergyEST)) est = selectedEnt._b.EnergyEST;
    selEl.innerText = Number.isFinite(est) ? `${Math.round(est).toLocaleString()} EnergyEst` : "‚Äî";
  } else if(!inLod2 && activeInd === 'Label' && selectedEnt && selectedEnt._b){
    // For the energy label layer show the letter (or proxy) rather than a numeric value
    const letter = selectedEnt._b.LabelLetter;
    selEl.innerText = letter ? letter.toUpperCase() : '‚Äî';
  } else if(!inLod2 && selectedEnt && selectedEnt._b){
    const v = (activeScen === 'p2p') ? getVal(selectedEnt,'Balance','p2p') : getVal(selectedEnt,activeInd,activeScen);
    const unit = (activeScen === 'p2p') ? "kWh in month" : (activeInd==='EUI'?'kWh per m¬≤ per year':(activeInd==='PV'?'kWh per year':'kg CO‚ÇÇ per year'));
    selEl.innerText = Number.isFinite(v) ? `${Math.round(v).toLocaleString()} ${unit}` : '‚Äî';
  } else {
    selEl.innerText = '‚Äî';
  }

  if(inLod2){
    titleEl.innerText = "LOD 2.2 ‚Ä¢ Energy estimate classes";
    subEl.innerText = "3D buildings are coloured by energy estimate class (LOW / MID / HIGH).";
    gradEl.style.background = "linear-gradient(90deg, #15803d, #d97706, #b91c1c)";
    minEl.innerText = "LOW";
    maxEl.innerText = "HIGH";
    const p33 = (ENERGYEST_P33 !== null) ? Math.round(ENERGYEST_P33).toLocaleString() : "‚Äî";
    const p66 = (ENERGYEST_P66 !== null) ? Math.round(ENERGYEST_P66).toLocaleString() : "‚Äî";
    noteEl.innerText = `Bands (EnergyEst): LOW < ${p33} ‚Ä¢ MID ${p33}‚Äì${p66} ‚Ä¢ HIGH > ${p66}`;
    return;
  }

  if(activeScen === 'p2p'){
    titleEl.innerText = "LOD 1 ‚Ä¢ Local energy sharing balance";
    subEl.innerText = "Monthly net balance under local energy sharing.";
    gradEl.style.background = "linear-gradient(90deg, #ef4444, #ffffff, #3b82f6)";
    minEl.innerText = "Needs energy";
    maxEl.innerText = "Has extra solar";
    noteEl.innerText = "Red = deficit (buys locally) ‚Ä¢ Blue = surplus (sells locally). Intensity shows magnitude.";
    return;
  }

  // Legend for the discrete energy label layer.  Render a segmented gradient and
  // update labels accordingly.  This must come before the default continuous
  // layers so that it overrides their settings.  Bands are equi‚Äëspaced and
  // coloured according to the LABEL_COLOR_MAP defined in the global scope.
  if(activeInd === 'Label'){
    titleEl.innerText = 'LOD 1 ‚Ä¢ Certified energy label (A‚ÄìG)';
    subEl.innerText = 'Buildings coloured by their certified energy label (proxy where none).';
    // Build a multi‚Äëstop gradient string from the colour map.  Each label
    // occupies an equal fraction of the gradient.  Unknown labels use the
    // neutral grey colour.
    const keys = ['A','B','C','D','E','F','G'];
    const stops = keys.length;
    let gradStops = '';
    for(let i=0;i<stops;i++){
      const col = LABEL_COLOR_MAP[keys[i]];
      const start = (i / stops * 100).toFixed(3) + '%';
      const end   = ((i + 1) / stops * 100).toFixed(3) + '%';
      gradStops += `${col} ${start}, ${col} ${end}`;
      if(i < stops - 1) gradStops += ', ';
    }
    gradEl.style.background = `linear-gradient(90deg, ${gradStops})`;
    minEl.innerText = 'A (best)';
    maxEl.innerText = 'G (worst)';
    noteEl.innerText = 'Green = most efficient, Red = least efficient.';
    return;
  }

  const unit = (activeInd==='EUI'?'kWh per m¬≤ per year':(activeInd==='PV'?'kWh per year':'kg CO‚ÇÇ per year'));
  const label = (activeInd==='EUI'?'Energy use per m¬≤':(activeInd==='PV'?'Solar electricity potential':'Carbon emissions'));

  titleEl.innerText = `LOD 1 ‚Ä¢ ${label}`;
  subEl.innerText = "Colours represent neighbourhood values after applying the selected scenario.";

  if(activeInd === 'EUI'){
    gradEl.style.background = "linear-gradient(90deg, #10b981, #ef4444)";
    noteEl.innerText = "Lower values mean less energy use per square meter per year.";
  } else if(activeInd === 'PV'){
    gradEl.style.background = "linear-gradient(90deg, #ef4444, #10b981)";
    noteEl.innerText = "Higher values mean higher expected solar electricity potential per year.";
  } else {
    gradEl.style.background = "linear-gradient(90deg, #2dd4bf, #d946ef)";
    noteEl.innerText = "Higher values mean higher estimated operational carbon emissions per year.";
  }

  const minUse = Number.isFinite(minScenario) ? minScenario : bounds[activeInd].min;
  const maxUse = Number.isFinite(maxScenario) ? maxScenario : bounds[activeInd].max;

  minEl.innerText = `Min: ${fmtRange(minUse, unit)}`;
  maxEl.innerText = `Max: ${fmtRange(maxUse, unit)}`;
}

// =============================
// 23) UI ACTIONS
// =============================
window.toggleIndividualUpgrade = function(type) {
  if(selectedEnt) {
    const b = selectedEnt._b;
    if(type === 'PV') b.customPV = !b.customPV;
    if(type === 'Retrofit') b.customRetro = !b.customRetro;
    updateVis();
    renderInfo(selectedEnt);
    updateLeftLegend();
  }
};

window.closeInfo = function() {
  document.getElementById('infoPanel').style.display = 'none';
  selectedEnt = null;
  updateLeftLegend();
  viewer.scene.requestRender();
};

window.searchLocation = function() {
  const q = document.getElementById('searchInput').value.toLowerCase().trim();
  const qNorm = normalizeBagId(q);

  const found = myEntities.find(e => {
    const idStr = String(e._b.ID || "").toLowerCase();
    const idNorm = normalizeBagId(e._b.ID || "");
    return (qNorm && idNorm === qNorm) || idStr.includes(q) || String(e._b.Year).includes(q);
  });

  if(found) {
    viewer.flyTo(found, { offset: new Cesium.HeadingPitchRange(0, -0.8, 200), duration: 2 });

    if(document.getElementById('viewReal').classList.contains('active')){
      selectedEnt = found;
      lastPrototypeNote = "Search result";
      renderInfoPrototype(found);
    } else {
      selectedEnt = found;
      renderInfo(found);
      document.getElementById('infoPanel').style.display = 'block';
    }

    updateLeftLegend();
    viewer.scene.requestRender();
  } else {
    alert("Building not found");
  }
};

// =============================
// LOD2 overlays helper
// =============================
function applyLod2Overlays(){
  const inLod2 = document.getElementById('viewReal').classList.contains('active');
  if(irrRaster && irrRaster.imageryLayer) irrRaster.imageryLayer.show = (inLod2 && L2_SHOW_IRR_OVERLAY);
  if(shadowRaster && shadowRaster.imageryLayer) shadowRaster.imageryLayer.show = (inLod2 && L2_SHOW_SHADOW_OVERLAY);
}
</script>
</body>
</html>
